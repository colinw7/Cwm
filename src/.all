CONCAT_ID=##concat##
##concat##CGradient.cpp
#include <CGradient.h>
#include <CImageGC.h>
#include <CImageDraw.h>
#include <CRGBA.h>

#define CGradientDataMgrInst CGradientDataMgr::getInstance()

class CGradientDataMgr {
 private:
  typedef std::list<CGradientData *> CGradientDataList;

  CGradientDataList gradient_data_list_;

 public:
  static CGradientDataMgr *getInstance();

  CGradientDataMgr();
 ~CGradientDataMgr();

  CGradientData *get(const CRGBA &start, const CRGBA &end,
                     int width, int height, CGradientDir direction);
  CGradientData *lookup(const CRGBA &start, const CRGBA &end,
                        int width, int height, CGradientDir direction);
  CGradientData *add(const CRGBA &start, const CRGBA &end,
                     int width, int height, CGradientDir direction);


  void incReference(CGradientData *gradient_data);
  void decReference(CGradientData *gradient_data);

  void remove(CGradientData *gradient_data);
};

class CGradientData {
 private:
  CImagePtr    image_;
  CRGBA        start_;
  CRGBA        end_;
  int          width_;
  int          height_;
  CGradientDir direction_;
  int          count_;

 public:
  CGradientData(const CRGBA &start, const CRGBA &end, int width, int height,
                CGradientDir direction);
 ~CGradientData();

  bool match(const CRGBA &start, const CRGBA &end, int width, int height, CGradientDir direction);

  void incReference();
  void decReference();

  int getNumReferences() const { return count_; }

  CImagePtr getImage() const { return image_; }

  const CRGBA &getStart() const { return start_; }
  const CRGBA &getEnd  () const { return end_  ; }
};

CGradient::
CGradient(const CRGBA &start, const CRGBA &end, int width, int height, CGradientDir direction) :
 gradient_data_(0)
{
  gradient_data_ = CGradientDataMgrInst->get(start, end, width, height, direction);

  CGradientDataMgrInst->incReference(gradient_data_);
}

CGradient::
~CGradient()
{
  CGradientDataMgrInst->decReference(gradient_data_);
}

CImagePtr
CGradient::
getImage() const
{
  return gradient_data_->getImage();
}

const CRGBA &
CGradient::
getStart() const
{
  return gradient_data_->getStart();
}

const CRGBA &
CGradient::
getEnd() const
{
  return gradient_data_->getEnd();
}

CGradientDataMgr *
CGradientDataMgr::
getInstance()
{
  static CGradientDataMgr *instance;

  if (! instance)
    instance = new CGradientDataMgr();

  return instance;
}

CGradientDataMgr::
CGradientDataMgr() :
 gradient_data_list_()
{
}

CGradientDataMgr::
~CGradientDataMgr()
{
  CGradientDataList::iterator p1 = gradient_data_list_.begin();
  CGradientDataList::iterator p2 = gradient_data_list_.end  ();

  for ( ; p1 != p2; ++p1)
    delete *p1;
}

CGradientData *
CGradientDataMgr::
get(const CRGBA &start, const CRGBA &end, int width, int height, CGradientDir direction)
{
  CGradientData *gradient_data = lookup(start, end, width, height, direction);

  if (gradient_data == 0)
    gradient_data = add(start, end, width, height, direction);

  return gradient_data;
}

CGradientData *
CGradientDataMgr::
lookup(const CRGBA &start, const CRGBA &end, int width, int height, CGradientDir direction)
{
  CGradientDataList::iterator p1 = gradient_data_list_.begin();
  CGradientDataList::iterator p2 = gradient_data_list_.end  ();

  for ( ; p1 != p2; ++p1) {
    if ((*p1)->match(start, end, width, height, direction))
      return *p1;
  }

  return 0;
}

CGradientData *
CGradientDataMgr::
add(const CRGBA &start, const CRGBA &end, int width, int height, CGradientDir direction)
{
  CGradientData *gradient_data = new CGradientData(start, end, width, height, direction);

  gradient_data_list_.push_back(gradient_data);

  return gradient_data;
}

void
CGradientDataMgr::
remove(CGradientData *gradient_data)
{
  gradient_data_list_.remove(gradient_data);
}

void
CGradientDataMgr::
incReference(CGradientData *gradient_data)
{
  gradient_data->incReference();
}

void
CGradientDataMgr::
decReference(CGradientData *gradient_data)
{
  gradient_data->decReference();

  if (gradient_data->getNumReferences() <= 0)
    remove(gradient_data);
}

CGradientData::
CGradientData(const CRGBA &start, const CRGBA &end, int width, int height,
              CGradientDir direction) :
 image_(), start_(start), end_(end), width_(width), height_(height),
 direction_(direction), count_(0)
{
  std::string fileName = "app://CGradientData?";

  fileName += "start="     + start.toString() + "&" +
              "end="       + end  .toString() + "&" +
              "width="     + CStrUtil::toString(width ) + "&"
              "height="    + CStrUtil::toString(height) + "&"
              "direction=" + CStrUtil::toString(height);

  CImageNameSrc src(fileName);

  image_ = CImageMgrInst->createImage(src);

  image_->setDataSize(width, height);

  CRGBA rgba(start);

  CImageDraw draw(image_);

  if      (direction == CGRADIENT_DIR_VERTICAL) {
    CRGBA drgba = (end - start)/(height - 1.0);

    CImageGC gc;

    for (int i = 0; i < height; i++) {
      gc.setForeground(rgba);

      draw.drawHLine(gc, 0, i, width - 1);

      rgba += drgba;
    }
  }
  else if (direction == CGRADIENT_DIR_HORIZONTAL) {
    CRGBA drgba = (end - start)/(width - 1.0);

    CImageGC gc;

    for (int i = 0; i < width; i++) {
      gc.setForeground(rgba);

      draw.drawVLine(gc, i, 0, height - 1);

      rgba += drgba;
    }
  }
  else if (direction == CGRADIENT_DIR_RDIAGONAL) {
    CRGBA drgba1 = (end - start)/(2.0*(width  - 1.0));
    CRGBA drgba2 = (end - start)/(2.0*(height - 1.0));

    CImageGC gc;

    for (int y1 = 0; y1 < height; y1++) {
      CRGBA rgba1 = rgba;

      for (int x1 = 0; x1 < width; x1++) {
        gc.setForeground(rgba);

        draw.drawPoint(gc, x1, y1);

        rgba += drgba1;
      }

      rgba = rgba1 + drgba2;
    }
  }
  else if (direction == CGRADIENT_DIR_LDIAGONAL) {
    CRGBA drgba1 = (end - start)/(2.0*(width  - 1.0));
    CRGBA drgba2 = (end - start)/(2.0*(height - 1.0));

    CImageGC gc;

    for (int y1 = height - 1; y1 >= 0; y1--) {
      CRGBA rgba1 = rgba;

      for (int x1 = width - 1; x1 >= 0; x1--) {
        gc.setForeground(rgba);

        draw.drawPoint(gc, x1, y1);

        rgba += drgba1;
      }

      rgba = rgba1 + drgba2;
    }
  }
}

bool
CGradientData::
match(const CRGBA &start, const CRGBA &end, int width, int height, CGradientDir direction)
{
  return (width == width_ && height == height_ && direction == direction_ &&
          start == start_ && end == end_);
}

CGradientData::
~CGradientData()
{
}

void
CGradientData::
incReference()
{
  ++count_;
}

void
CGradientData::
decReference()
{
  --count_;
}
##concat##CImageDraw.cpp
#include <CImageDraw.h>
#include <CImageGC.h>
#include <CMathGen.h>

#include <CLine2D.h>
#include <CBresenham.h>

CImageDraw::
CImageDraw(CImagePtr image) :
 image_(image), compose_(false)
{
}

void
CImageDraw::
setImage(CImagePtr image)
{
  image_ = image;
}

void
CImageDraw::
clear(const CImageGC &gc)
{
  if (image_->hasColormap()) {
    int color_ind;

    gc.getBackground(color_ind);

    image_->setColorIndexData(color_ind);
  }
  else {
    CRGBA rgba;

    gc.getBackground(rgba);

    image_->setRGBAData(rgba);
  }
}

void
CImageDraw::
fill(const CImageGC &gc)
{
  if (image_->hasColormap()) {
    int color_ind;

    gc.getForeground(color_ind);

    image_->setColorIndexData(color_ind);
  }
  else {
    CRGBA rgba;

    gc.getForeground(rgba);

    image_->setRGBAData(rgba);
  }
}

void
CImageDraw::
drawImage(const CImageGC &, int x, int y, CImagePtr image)
{
  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  int iwidth1  = image->getWidth ();
  int iheight1 = image->getHeight();

  int x1 = x;
  int x2 = std::min(x + iwidth1  - 1, iwidth  - 1);
  int y1 = y;
  int y2 = std::min(y + iheight1 - 1, iheight - 1);

  if (image_->hasColormap()) {
    int color_ind;

    for (int y = y1; y <= y2; ++y)
      for (int x = x1; x <= x2; ++x) {
        color_ind = image->getColorIndexPixel(x - x1, y - y1);

        image_->drawColorIndexPoint(x, y, color_ind);
      }
  }
  else {
    CRGBA rgba;

    for (int y = y1; y <= y2; ++y)
      for (int x = x1; x <= x2; ++x) {
        image->getRGBAPixel(x - x1, y - y1, rgba);

        image_->drawRGBAPoint(x, y, rgba);
      }
  }
}

void
CImageDraw::
drawPolygon(const CImageGC &gc, int *x, int *y, int num_xy)
{
  int i1 = num_xy - 1;
  int i2 = 0;

  for ( ; i2 < num_xy; i1 = i2, ++i2)
    drawLine(gc, x[i1], y[i1], x[i2], y[i2]);
}

void
CImageDraw::
fillPolygon(const CImageGC &gc, int *x, int *y, int num_xy)
{
  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  int ymin = iheight;
  int ymax = -1;

  for (int i1 = 0; i1 < num_xy; ++i1) {
    ymin = std::min(ymin, y[i1]);
    ymax = std::max(ymax, y[i1]);
  }

  ymin = std::max(ymin, 0);
  ymax = std::min(ymax, iheight - 1);

  for (int yy = ymin; yy <= ymax; ++yy) {
    int xmin = iwidth;
    int xmax = -1;

    for (int i1 = num_xy - 1, i2 = 0; i2 < num_xy; i1 = i2, ++i2) {
      if ((y[i1] < yy && y[i2] < yy) ||
          (y[i1] > yy && y[i2] > yy) ||
          y[i1] == y[i2])
        continue;

      double factor = double(x[i2] - x[i1])/double(y[i2] - y[i1]);

      int xx = CMathGen::Round((yy - y[i1])*factor + x[i1]);

      xmin = std::min(xmin, xx);
      xmax = std::max(xmax, xx);
    }

    xmin = std::max(xmin, 0);
    xmax = std::min(xmax, iwidth - 1);

    if (xmin > xmax)
      continue;

    drawLine(gc, xmin, yy, xmax, yy);
  }
}

void
CImageDraw::
drawRectangle(const CImageGC &gc, int x, int y, int width, int height)
{
  int x1 = x + width  - 1;
  int y1 = y + height - 1;

  drawLine(gc, x , y , x1, y );
  drawLine(gc, x1, y , x1, y1);
  drawLine(gc, x1, y1, x , y1);
  drawLine(gc, x , y1, x , y );
}

void
CImageDraw::
fillRectangle(const CImageGC &gc, int x, int y, int width, int height)
{
  if (compose_) {
    int iwidth  = image_->getWidth ();
    int iheight = image_->getHeight();

    int x1 = x;
    int x2 = std::min(x + width  - 1, iwidth  - 1);
    int y1 = y;
    int y2 = std::min(y + height - 1, iheight - 1);

    if (image_->hasColormap()) {
      int color_ind;

      gc.getForeground(color_ind);

      for (int y = y1; y <= y2; ++y)
        for (int x = x1; x <= x2; ++x)
          image_->drawColorIndexPoint(x, y, color_ind);
    }
    else {
      CRGBA rgba;

      gc.getForeground(rgba);

      for (int y = y1; y <= y2; ++y)
        for (int x = x1; x <= x2; ++x)
          image_->drawRGBAPoint(x, y, rgba);
    }
  }
  else {
    int x2 = x + width  - 1;
    int y2 = y + height - 1;

    if (image_->hasColormap()) {
      int color_ind;

      gc.getForeground(color_ind);

      image_->fillColorIndexRectangle(x, y, x2, y2, color_ind);
    }
    else {
      CRGBA rgba;

      gc.getForeground(rgba);

      image_->fillRGBARectangle(x, y, x2, y2, rgba);
    }
  }
}

void
CImageDraw::
drawButton(const CImageGC &gc, int x, int y, int width, int height,
           int thickness)
{
  if (image_->hasColormap())
    return;

  CRGBA rgba;

  gc.getForeground(rgba);

  CRGBA rgba1 = rgba;
  CRGBA rgba2 = rgba;

  rgba1.scaleAlpha(0.4);
  rgba2.scaleAlpha(0.8);

  // top

  {
    int x1 = x;
    int x2 = x + width - 2;
    int y1 = y;

    for (int i = 0; i < thickness; ++i, x1++, x2--)
      drawRGBAHLine(x1, y1 + i, x2 - x1 + 1, rgba1);
  }

  // left

  {
    int x1 = x;
    int y1 = y + 1;
    int y2 = y + height - 2;

    for (int i = 0; i < thickness; ++i, y1++, y2--)
      drawRGBAVLine(x1 + i, y1, y2 - y1 + 1, rgba1);
  }

  // bottom

  {
    int x1 = x;
    int y1 = y + height - 1;
    int x2 = x + width - 1;

    for (int i = 0; i < thickness; ++i, x1++, x2--)
      drawRGBAHLine(x1, y1 - i, x2 - x1 + 1, rgba2);
  }

  // right

  {
    int x1 = x + width - 1;
    int y1 = y;
    int y2 = y + height - 2;

    for (int i = 0; i < thickness; ++i, y1++, y2--)
      drawRGBAVLine(x1 - i, y1, y2 - y1 + 1, rgba2);
  }

  fillRectangle(gc, x + thickness, y + thickness,
                width - 2*thickness, height - 2*thickness);
}

void
CImageDraw::
drawHLine(const CImageGC &gc, int x, int y, int length)
{
  if (image_->hasColormap()) {
    int color_ind;

    gc.getForeground(color_ind);

    drawColorIndexHLine(x, y, length, color_ind);
  }
  else {
    CRGBA rgba;

    gc.getForeground(rgba);

    drawRGBAHLine(x, y, length, rgba);
  }
}

void
CImageDraw::
drawColorIndexHLine(int x, int y, int length, int color_ind)
{
  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  int x1 = x;
  int x2 = std::min(x + length - 1, iwidth - 1);

  if (y < 0 || y >= iheight)
    return;

  for (int x = x1; x <= x2; ++x)
    image_->drawColorIndexPoint(x, y, color_ind);
}

void
CImageDraw::
drawRGBAHLine(int x, int y, int length, const CRGBA &rgba)
{
  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  int x1 = x;
  int x2 = std::min(x + length - 1, iwidth - 1);

  if (y < 0 || y >= iheight)
    return;

  for (int x = x1; x <= x2; ++x)
    image_->drawRGBAPoint(x, y, rgba);
}

void
CImageDraw::
drawVLine(const CImageGC &gc, int x, int y, int length)
{
  if (image_->hasColormap()) {
    int color_ind;

    gc.getForeground(color_ind);

    drawColorIndexVLine(x, y, length, color_ind);
  }
  else {
    CRGBA rgba;

    gc.getForeground(rgba);

    drawRGBAVLine(x, y, length, rgba);
  }
}

void
CImageDraw::
drawColorIndexVLine(int x, int y, int length, int color_ind)
{
  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  int y1 = y;
  int y2 = std::min(y + length - 1, iheight - 1);

  if (x < 0 || x >= iwidth)
    return;

  for (int y = y1; y <= y2; ++y)
    image_->drawColorIndexPoint(x, y, color_ind);
}

void
CImageDraw::
drawRGBAVLine(int x, int y, int length, const CRGBA &rgba)
{
  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  int y1 = y;
  int y2 = std::min(y + length - 1, iheight - 1);

  if (x < 0 || x >= iwidth)
    return;

  for (int y = y1; y <= y2; ++y)
    image_->drawRGBAPoint(x, y, rgba);
}

void
CImageDraw::
drawDLine(const CImageGC &gc, int x1, int y1, int x2, int y2)
{
  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  if (x1 < 0 || x1 >= iwidth  || x2 < 0 || x2 >= iwidth  ||
      y1 < 0 || y1 >= iheight || y2 < 0 || y2 >= iheight)
    return;

  int dx = (x2 > x1 ? 1 : -1);
  int dy = (y2 > y1 ? 1 : -1);

  int x = x1;
  int y = y1;

  if (image_->hasColormap()) {
    int color_ind;

    gc.getForeground(color_ind);

    while (true) {
      if      (dx ==  1 && x > x2) break;
      else if (dx == -1 && x < x2) break;
      if      (dy ==  1 && y > y2) break;
      else if (dy == -1 && y < y2) break;

      image_->drawColorIndexPoint(x, y, color_ind);

      x += dx;
      y += dy;
    }
  }
  else {
    CRGBA rgba;

    gc.getForeground(rgba);

    while (true) {
      if      (dx ==  1 && x > x2) break;
      else if (dx == -1 && x < x2) break;
      if      (dy ==  1 && y > y2) break;
      else if (dy == -1 && y < y2) break;

      image_->drawRGBAPoint(x, y, rgba);

      x += dx;
      y += dy;
    }
  }
}

void
CImageDraw::
drawLine(const CImageGC &gc, int x1, int y1, int x2, int y2)
{
  class CImageDrawBresenham : public CBresenham {
   public:
    CImageDrawBresenham(CImageDraw *draw, const CImageGC *gc) :
     draw_(draw), gc_(gc) {
    }

    void drawPoint(int x, int y) {
      draw_->drawPoint(*gc_, x, y);
    }

   private:
    CImageDraw     *draw_;
    const CImageGC *gc_;
  };

  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  CLine2D line(x1, y1, x2, y2);
  CBBox2D bbox(0, 0, iwidth - 1, iheight - 1);

  CLine2D cline;

  if (! line.clip(bbox, cline))
    return;

  CImageDrawBresenham bresenham(this, &gc);

  bresenham.drawLine(cline.start().x, cline.start().y,
                     cline.end  ().x, cline.end  ().y);
}

void
CImageDraw::
drawPoint(const CImageGC &gc, int x, int y)
{
  int iwidth  = image_->getWidth ();
  int iheight = image_->getHeight();

  if (x < 0 || x >= iwidth  ||
      y < 0 || y >= iheight)
    return;

  if (image_->hasColormap()) {
    int color_ind;

    gc.getForeground(color_ind);

    image_->drawColorIndexPoint(x, y, color_ind);
  }
  else {
    CRGBA rgba;

    gc.getForeground(rgba);

    image_->drawRGBAPoint(x, y, rgba);
  }
}
##concat##CImageGC.cpp
#include <CImageGC.h>

CImageGC::
CImageGC()
{
}

void
CImageGC::
setForeground(const CRGBA &rgba)
{
  fg_rgba_ = rgba;
}

void
CImageGC::
setForeground(int ind)
{
  fg_ind_ = ind;
}

void
CImageGC::
setBackground(const CRGBA &rgba)
{
  bg_rgba_ = rgba;
}

void
CImageGC::
setBackground(int ind)
{
  bg_ind_ = ind;
}
##concat##CwmCmdIcon.cpp
#include <CwmI.h>

// IconMar: Handles Toolbar Command Icons

CwmCmdIconMgr *
CwmCmdIconMgr::
getInstance()
{
  static CwmCmdIconMgr *instance;

  if (! instance)
    instance = new CwmCmdIconMgr();

  return instance;
}

CwmCmdIconMgr::
CwmCmdIconMgr()
{
}

CwmCmdIconMgr::
~CwmCmdIconMgr()
{
  deleteAll();
}

void
CwmCmdIconMgr::
addCmdIcon(CwmScreen &screen, CwmCustomIcon &icon_def)
{
  CwmCmdIcon *cmd_icon = new CwmCmdIcon(screen, icon_def);

  command_icon_list_.push_back(cmd_icon);

  Window xwin = cmd_icon->getXWindow()->getXWin();

  command_icon_map_[xwin] = cmd_icon;
}

CwmCmdIcon *
CwmCmdIconMgr::
lookup(const CwmWindow &window)
{
  Window xwin = window.getXWin();

  return lookup(xwin);
}

CwmCmdIcon *
CwmCmdIconMgr::
lookup(Window xwin)
{
  CmdIconMap::iterator picon1 = command_icon_map_.find(xwin);

  if (picon1 == command_icon_map_.end())
    return 0;

  return (*picon1).second;
}

void
CwmCmdIconMgr::
deleteAll()
{
  std::for_each(command_icon_list_.begin(), command_icon_list_.end(), CDeletePointer());

  command_icon_list_.clear();
}

//--------------

CwmCmdIcon::
CwmCmdIcon(CwmScreen &screen, CwmCustomIcon &icon_def) :
 screen_(screen)
{
  graphics_ = icon_def.getGraphics(screen);

  //------

  icon_x_ = icon_def.getX();
  icon_y_ = icon_def.getY();

  pixmap_dx_ = 0;
  label_dx_  = 0;

  //------

  image_ = icon_def.getImage(screen);

  pixmap_mask_ = None;
  label_mask_  = None;

  //------

  pixmap_width_  = image_->getWidth ();
  pixmap_height_ = image_->getHeight();

  label_ = icon_def.getLabel();

  graphics_->getTextSize(label_, &label_width_, &label_height_);

  if (label_width_ > pixmap_width_)
    pixmap_dx_ += (label_width_  - pixmap_width_)/2;
  else
    label_dx_  += (pixmap_width_ - label_width_ )/2;

  //------

  icon_width_  = std::max(pixmap_width_, label_width_);
  icon_height_ = pixmap_height_ + label_height_;

  //------

  command_ = icon_def.getCommand();

  //------

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask   |
                    KeyPressMask    | ExposureMask;

  xwindow_ = new CwmWindow(screen_, screen_.getRoot(),
                           icon_x_, icon_y_, icon_width_, icon_height_,
                           event_mask, CWM_CURSOR_TITLE);

  //------

  xwindow_->addCallback(CWM_CALLBACK_DOUBLE_CLICK_1, &CwmCmdIcon::invokeProc, (CwmData) this);

  //------

  xwindow_->map();

  xwindow_->lower();

  //------

  reposition();
}

CwmCmdIcon::
~CwmCmdIcon()
{
  delete xwindow_;
  delete graphics_;
  delete pixmap_mask_;
  delete label_mask_;
}

void
CwmCmdIcon::
reposition()
{
  int x11 = icon_x_;
  int y11 = icon_y_;
  int x21 = icon_x_ + icon_width_  - 1;
  int y21 = icon_y_ + icon_height_ - 1;

  int x12 = x11;
  int y12 = y11;
  int x22 = x21;
  int y22 = y21;

  CwmGrid *grid = screen_.getIconGrid();

  grid->remove(this);

  grid->add(this, &x12, &y12, &x22, &y22, CWM_INSERT_TOP, CWM_INSERT_LEFT);

  int dx = x12 - x11;
  int dy = y12 - y11;

  icon_x_ += dx;
  icon_y_ += dy;

  xwindow_->move(icon_x_, icon_y_);
}

void
CwmCmdIcon::
move()
{
  int dx, dy;

  xwindow_->raise();

  CwmMoveWindowInst->moveInteractive(screen_, xwindow_, icon_x_, icon_y_,
                                     icon_width_, icon_height_, &dx, &dy);

  if (icon_x_ + dx < 0)
    dx = -icon_x_;

  if (icon_y_ + dy < 0)
    dy = -icon_y_;

  if (icon_x_ + icon_width_  + dx > screen_.getWidth())
    dx = screen_.getWidth()  - icon_x_ - icon_width_;

  if (icon_y_ + icon_height_ + dy > screen_.getHeight())
    dy = screen_.getHeight() - icon_y_ - icon_height_;

  icon_x_ += dx;
  icon_y_ += dy;

  reposition();

  xwindow_->lower();

  redraw();
}

void
CwmCmdIcon::
redraw()
{
#ifdef SHAPE
  if (pixmap_mask_ == None)
    createMask();
#endif

  image_->draw(xwindow_, graphics_, pixmap_dx_, 0);

  if (label_ != "")
    graphics_->drawTextCentered(xwindow_, label_dx_, pixmap_height_,
                                label_width_, label_height_, label_);
}

void
CwmCmdIcon::
createMask()
{
  pixmap_mask_ = image_->createMask();

  CwmMachineInst->shapeCombineMask(xwindow_->getXWin(),
                                   pixmap_mask_->getXPixmap(),
                                   pixmap_dx_, 0, ShapeSet);

  if (label_ != "") {
    label_mask_ = new CwmMask(screen_, graphics_, label_width_, label_height_);

    label_mask_->drawString(0, 0, label_);

    label_mask_->combine(xwindow_, label_dx_, pixmap_height_, ShapeUnion);
  }
  else
    label_mask_ = 0;
}

void
CwmCmdIcon::
invokeProc(CwmWindow *, CwmData data, CwmData)
{
  CwmCmdIcon *icon = (CwmCmdIcon *) data;

  icon->invoke();
}

void
CwmCmdIcon::
invoke()
{
  if (command_.size() > 0) {
    UnixCmd command(screen_, command_);

    command.run();
  }
}
##concat##CwmColormapMgr.cpp
#include <CwmI.h>

CwmColormapMgr::
CwmColormapMgr(CwmScreen &screen) :
 screen_(screen), window_(0), cmap_(screen.getColormap())
{
}

CwmColormapMgr::
~CwmColormapMgr()
{
}

void
CwmColormapMgr::
install(CwmWMWindow *window)
{
  Colormap cmap;

  Window cmap_window = window->getColormapWindowHint();

  if (cmap_window != None)
    cmap = CwmMachineInst->getWindowColormap(cmap_window);
  else
    cmap = window->getColormap();

  install(window, cmap);
}

void
CwmColormapMgr::
uninstall()
{
  Colormap cmap = screen_.getColormap();

  install(0, cmap);
}

void
CwmColormapMgr::
install(CwmWMWindow *window, Colormap cmap)
{
  if (cmap != cmap_)
    screen_.installColormap(cmap);

  window_ = window;
  cmap_   = cmap;
}
##concat##CwmColorMgr.cpp
#include <CwmI.h>
#include <CXColor.h>
#include <CXScreen.h>
#include <CRGBName.h>

CwmColorMgr::
CwmColorMgr(CwmScreen &screen)
{
  color_mgr_ = new CXColorMgr(*screen.getCXScreen());
}

CwmColorMgr::
~CwmColorMgr()
{
  delete color_mgr_;
}

CwmColor *
CwmColorMgr::
getColor(Pixel fg, Pixel bg)
{
  const CXColor &fg_color = color_mgr_->getCXColor(fg);
  const CXColor &bg_color = color_mgr_->getCXColor(bg);

  ColorPair color_pair(fg_color, bg_color);

  ColorList::const_iterator pcolor1 = colors_.find(color_pair);
  ColorList::const_iterator pcolor2 = colors_.end ();

  if (pcolor1 != pcolor2)
    return (*pcolor1).second;

  CwmColor *color = new CwmColor(fg_color, bg_color);

  colors_[color_pair] = color;

  return color;
}

Pixel
CwmColorMgr::
getPixel(const std::string &name, Pixel default_pixel)
{
  std::string name1 = CStrUtil::toLower(name);

  NamedColorMap::const_iterator pnamed_color1 = named_colors_.find(name1);
  NamedColorMap::const_iterator pnamed_color2 = named_colors_.end ();

  if (pnamed_color1 != pnamed_color2)
    return (*pnamed_color1).second->getPixel();

  const CXColor *color;
  double         r, g, b;

  if (CRGBName::lookup(name, &r, &g, &b))
    color = &color_mgr_->getCXColor(CRGBA(r, g, b));
  else
    color = &color_mgr_->getCXColor(default_pixel);

  named_colors_[name1] = color;

  return color->getPixel();
}
##concat##CwmConfig.cpp
#include <CwmI.h>
#include <CConfig.h>

CwmConfig *
CwmConfig::
getInstance()
{
  static CwmConfig *instance;

  if (! instance)
    instance = new CwmConfig();

  return instance;
}

CwmConfig::
CwmConfig()
{
  config_ = new CConfig("Cwm");
}

CwmConfig::
~CwmConfig()
{
  delete config_;
}

void
CwmConfig::
save()
{
  config_->save();
}

string
CwmConfig::
getSectionValue(const std::string &path, const std::string &section, const std::string &fallback)
{
  std::string value = fallback;

  if (! config_->getValue(path, section, value))
    value = fallback;

  return value;
}

string
CwmConfig::
getValue(const std::string &path, const std::string &fallback)
{
  std::string value = fallback;

  if (! config_->getValue(path, "", value))
    value = fallback;

  return value;
}

int
CwmConfig::
getSectionValue(const std::string &path, const std::string &section, int fallback)
{
  int value = fallback;

  std::string str;

  if (! config_->getValue(path, section, str))
    return value;

  if (CStrUtil::isInteger(str))
    value = CStrUtil::toInteger(str);

  return value;
}

int
CwmConfig::
getValue(const std::string &path, int fallback)
{
  int value = fallback;

  std::string str;

  if (! config_->getValue(path, "", str))
    return value;

  if (CStrUtil::isInteger(str))
    value = CStrUtil::toInteger(str);

  return value;
}

void
CwmConfig::
setSectionValue(const std::string &path, const std::string &section, const std::string &value)
{
  config_->setValue(path, section, value);
}

void
CwmConfig::
setValue(const std::string &path, const std::string &value)
{
  config_->setValue(path, "", value);
}

void
CwmConfig::
getGroups(const std::string &path, StringVectorT &groupNames, StringVectorT &groupPaths)
{
  config_->getGroups(path, groupNames, groupPaths);
}

void
CwmConfig::
getSections(const std::string &path, StringVectorT &sections)
{
  config_->getSections(path, sections);
}
##concat##Cwm.cpp
#include <CwmI.h>
#include <CArgs.h>
#include <COSUser.h>
#include <COSSignal.h>

Cwm::
Cwm()
{
  argc_         = 0;
  argv_         = 0;
  pedantic_     = false;
  synchronize_  = false;
  root_image_   = "";
  home_dir_     = "";
  print_hints_  = false;
  display_name_ = "";
  gnome_        = false;

  setHomeDir();
}

Cwm::
~Cwm()
{
}

Cwm *
Cwm::
getInstance()
{
  static Cwm *instance;

  if (! instance)
    instance = new Cwm();

  return instance;
}

void
Cwm::
init(int argc, char **argv)
{
  CwmMachineInst->log("Start Cwm\n");

  saveArgs(argc, argv);

  parseArgs(&argc, argv);

  if (! CwmMachineInst->init(display_name_))
    term(1);

  if (synchronize_)
    CwmMachineInst->synchronize();

  setSignals();

  controlScreens();

  processWindows();

  drawRootImages();

  addCustomIcons();

  if (CwmResourceDataInst->getClickToFocus())
    initClickToFocus();

  processScreenStartup();

  CwmMessageInst->init();

  CwmWMWindow::processEvents();

  exit(0);
}

void
Cwm::
term(int retcode)
{
  CwmMachineInst->term();

  CwmMachineInst->log("End Cwm\n");

  exit(retcode);
}

void
Cwm::
saveArgs(int argc, char **argv)
{
  argc_ = argc;
  argv_ = new char * [argc + 3];

  int i;

  for (i = 0; i < argc; i++)
    argv_[i] = strdup(argv[i]);

  argv_[i] = 0;
}

void
Cwm::
parseArgs(int *argc, char **argv)
{
  std::string opts = "\
 -display:s     (Set Display Name) \
--root:s        (Set Root Image) \
--debug:f       (Set Debug Mode) \
--sync:f        (Set X Server Synchronous) \
--pedantic:f    (Core Dump on Errors) \
--print_hints:f (Display Hints) \
--gnome         (Run Under Gnome)";

  CArgs *cargs = new CArgs(opts);

  cargs->parse(argc, argv);

  display_name_ = cargs->getStringArg ("-display");
  root_image_   = cargs->getStringArg ("--root");
  synchronize_  = cargs->getBooleanArg("--sync");
  pedantic_     = cargs->getBooleanArg("--pedantic");
  print_hints_  = cargs->getBooleanArg("--print_hints");
  gnome_        = cargs->getBooleanArg("--gnome");

  if (cargs->getBooleanArg("--debug"))
    CwmMachineInst->setDebug(true);
}

void
Cwm::
setHomeDir()
{
  home_dir_ = COSUser::getUserHome();
}

void
Cwm::
setSignals()
{
  COSSignal::addSignalHandler(SIGHUP , (CwmSigHandler) &Cwm::signalHandler);
  COSSignal::addSignalHandler(SIGINT , (CwmSigHandler) &Cwm::signalHandler);
  COSSignal::addSignalHandler(SIGTERM, (CwmSigHandler) &Cwm::signalHandler);
  COSSignal::addSignalHandler(SIGQUIT, (CwmSigHandler) &Cwm::signalHandler);
}

void
Cwm::
controlScreens()
{
  if (! CwmMachineInst->controlScreens())
    term(1);

  CwmMachineInst->flushEvents();
}

void
Cwm::
processWindows()
{
  CwmGrabServer grab;

  int num_screens = CwmMachineInst->getNumScreens();

  for (int i = 0; i < num_screens; ++i) {
    CwmScreen &screen = CwmMachineInst->getScreen(i);

    processScreenWindows(screen);
  }
}

void
Cwm::
processScreenWindows(CwmScreen &screen)
{
  Window *children;
  int     num_children;

  if (! screen.getWindows(&children, &num_children))
    return;

  for (int i = 0; i < num_children; ++i) {
    if (children[i] != None &&
        CwmEventMgrInst->isDestroyPending(children[i]))
      children[i] = None;

    if (children[i] != None)
      resetIconWindows(i, children, num_children);

    if (children[i] != None &&
        ! CwmMachineInst->isWMWindow(children[i]))
      children[i] = None;
  }

  for (int i = 0; i < num_children; i++) {
    if (children[i] != None &&
        CwmEventMgrInst->isDestroyPending(children[i]))
      children[i] = None;

    if (children[i] != None) {
      CwmMachineInst->unmapWindow(children[i]);

      screen.addWMWindow(children[i]);
    }
  }

  if (children != 0)
    XFree(children);
}

void
Cwm::
resetIconWindows(int i, Window *children, int num_children)
{
  Window icon_window = CwmMachineInst->getWMIconWindowHint(children[i]);

  if (icon_window == None)
    return;

  for (int j = 0; j < num_children; ++j)
    if (children[j] == icon_window)
      children[j] = None;
}

void
Cwm::
drawRootImages()
{
  int num_screens = CwmMachineInst->getNumScreens();

  for (int i = 0; i < num_screens; ++i) {
    CwmScreen &screen = CwmMachineInst->getScreen(i);

    CwmDesk *desk = screen.getCurrentDesk();

    desk->drawRootImage();
  }
}

void
Cwm::
addCustomIcons()
{
  int num_screens = CwmMachineInst->getNumScreens();

  for (int i = 0; i < num_screens; ++i) {
    CwmScreen &screen = CwmMachineInst->getScreen(i);

    CwmCustomIconMgrInst->addCustomIcons(screen);
  }
}

void
Cwm::
initClickToFocus()
{
  CwmMachineInst->resetInputFocus();

  CwmScreen &screen = CwmMachineInst->getScreen(0);

  screen.getRoot()->warpPointer(0, 0);
}

void
Cwm::
processScreenStartup()
{
  CwmGrabServer grab;

  int num_screens = CwmMachineInst->getNumScreens();

  for (int i = 0; i < num_screens; ++i) {
    CwmScreen &screen = CwmMachineInst->getScreen(i);

    CwmResourceDataInst->loadStartupCommands(screen);
  }
}

void
Cwm::
printScreenWindows(CwmScreen &screen)
{
  Window *children;
  int     num_children;

  if (! screen.getWindows(&children, &num_children))
    return;

  for (int i = 0; i < num_children; ++i)
    CwmMachineInst->logf("Window %x\n", (int) children[i]);

  if (children != 0)
    XFree(children);
}

void
Cwm::
restart(CwmScreen &, const std::string &program)
{
  if (program == "") {
    if (root_image_ != "") {
      argv_[argc_++] = strdup("--root");
      argv_[argc_++] = strdup(root_image_.c_str());
      argv_[argc_++] = 0;
    }

    cleanup();

    execvp(argv_[0], argv_);
  }
  else {
    CStrWords words = CStrUtil::toWords(program, 0);

    char **words1 = new char * [words.size() + 1];

    int i;

    for (i = 0; i < words.size(); ++i)
      words1[i] = (char *) words[i].getWord().c_str();

    words1[i] = 0;

    cleanup();

    execvp(words1[0], words1);
  }
}

void
Cwm::
quit()
{
  cleanup();

  term(0);
}

void
Cwm::
cleanup()
{
  CwmWindowGlobalNotifyMgrInst->clear();

  CwmMachineInst->resetInputFocus();

  CwmCmdIconMgrInst->deleteAll();

  CwmCustomDeskIconMgrInst->deleteAll();

  CwmWindowEventFunctionMgrInst->removeAllEventFunctions();

  CwmRootEventFunctionMgrInst->deleteAll();

  CwmNamedMenuMgrInst->deleteAll();

  CwmMachineInst->term();
}

void
Cwm::
signalHandler(int sig)
{
  std::string sigstr = COSSignal::strsignal(sig);

  CwmMachineInst->debugf("Signal %s(%d) received\n", sigstr.c_str(), sig);

  if      (sig == SIGINT)
    CwmInst->restart(CwmMachineInst->getScreen(0), "");
  else if (sig == SIGTERM)
    CwmInst->quit();
}

void
Cwm::
setRootImage(const std::string &filename)
{
  root_image_ = filename;
}
##concat##CwmCursorMgr.cpp
#include <CwmI.h>

struct CwmCursorDef {
  CwmCursorType type;
  CCursorType   xtype;
};

static CwmCursorDef
cursor_def[] = {
  { CWM_CURSOR_TITLE , CURSOR_TYPE_TOP_LEFT_ARROW      },
  { CWM_CURSOR_N     , CURSOR_TYPE_TOP_SIDE            },
  { CWM_CURSOR_S     , CURSOR_TYPE_BOTTOM_SIDE         },
  { CWM_CURSOR_W     , CURSOR_TYPE_LEFT_SIDE           },
  { CWM_CURSOR_E     , CURSOR_TYPE_RIGHT_SIDE          },
  { CWM_CURSOR_NW    , CURSOR_TYPE_TOP_LEFT_CORNER     },
  { CWM_CURSOR_NE    , CURSOR_TYPE_TOP_RIGHT_CORNER    },
  { CWM_CURSOR_SW    , CURSOR_TYPE_BOTTOM_LEFT_CORNER  },
  { CWM_CURSOR_SE    , CURSOR_TYPE_BOTTOM_RIGHT_CORNER },
  { CWM_CURSOR_MOVE  , CURSOR_TYPE_FLEUR               },
  { CWM_CURSOR_MENU  , CURSOR_TYPE_SB_LEFT_ARROW       },
  { CWM_CURSOR_BUSY  , CURSOR_TYPE_WATCH               },
  { CWM_CURSOR_SELECT, CURSOR_TYPE_ARROW               },
  { CWM_CURSOR_QUERY , CURSOR_TYPE_QUESTION_ARROW      },
  { CWM_CURSOR_PLACE , CURSOR_TYPE_TOP_LEFT_ANGLE      },
  { CWM_CURSOR_NONE  , CURSOR_TYPE_TOP_LEFT_ARROW      },
};

CwmCursorMgr::
CwmCursorMgr(CwmScreen &screen) :
 screen_(screen)
{
  CwmColor *color = CwmResourceDataInst->getCursorColor(screen_);

  CRGBA fg_rgba = color->getFgRGBA();
  CRGBA bg_rgba = color->getBgRGBA();

  for (int i = 0; cursor_def[i].type != CWM_CURSOR_NONE; ++i) {
    CwmXCursor *cursor = new CwmXCursor(screen_, cursor_def[i].xtype);

    if (cursor_def[i].type != CWM_CURSOR_BUSY)
      cursor->recolor(bg_rgba, fg_rgba);

    cursor_list_.push_back(cursor);

    cursor_map_[cursor_def[i].type] = cursor;
  }
}

CwmCursorMgr::
~CwmCursorMgr()
{
  std::for_each(cursor_list_.begin(), cursor_list_.end(), CDeletePointer());
}

Cursor
CwmCursorMgr::
getCursor(CwmCursorType type) const
{
  CursorMap::const_iterator pcursor = cursor_map_.find(type);

  if (pcursor == cursor_map_.end())
    return None;

  return (*pcursor).second->getCursor()->getXCursor();
}

CwmXCursor::
CwmXCursor(CwmScreen &screen, CCursorType type)
{
  xcursor_ = new CXCursor(*screen.getCXScreen(), type);
}

CwmXCursor::
~CwmXCursor()
{
  delete xcursor_;
}

void
CwmXCursor::
recolor(CRGBA &bg, CRGBA &fg)
{
  xcursor_->recolor(bg, fg);
}
##concat##CwmCustomIcon.cpp
#include <CwmI.h>

CwmCustomIconMgr *
CwmCustomIconMgr::
getInstance()
{
  static CwmCustomIconMgr *instance;

  if (! instance)
    instance = new CwmCustomIconMgr();

  return instance;
}

CwmCustomIconMgr::
CwmCustomIconMgr()
{
}

CwmCustomIconMgr::
~CwmCustomIconMgr()
{
  std::for_each(custom_icons_.begin(), custom_icons_.end(), CDeletePointer());
}

void
CwmCustomIconMgr::
addCustomIcon(const std::string &icon, const std::string &label, const std::string &command,
              const std::string &bg, const std::string &fg, int x, int y)
{
  CwmCustomIcon *custom_icon =
    new CwmCustomIcon(icon, label, command, bg, fg, x, y);

  custom_icons_.push_back(custom_icon);
}

void
CwmCustomIconMgr::
addCustomIcons(CwmScreen &screen)
{
  CustomIconList::const_iterator picon1 = custom_icons_.begin();
  CustomIconList::const_iterator picon2 = custom_icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    CwmCmdIconMgrInst->addCmdIcon(screen, **picon1);
}

CwmCustomIcon::
CwmCustomIcon(const std::string &icon, const std::string &label, const std::string &command,
              const std::string &bg, const std::string &fg, int x, int y) :
 icon_(icon), label_(label), command_(command), bg_(bg), fg_(fg), x_(x), y_(y)
{
}

CwmCustomIcon::
~CwmCustomIcon()
{
}

string
CwmCustomIcon::
getIcon() const
{
  return icon_;
}

string
CwmCustomIcon::
getLabel() const
{
  return label_;
}

string
CwmCustomIcon::
getCommand() const
{
  return command_;
}

string
CwmCustomIcon::
getBg() const
{
  if (bg_.size() > 0)
    return bg_;
  else
    return CwmResourceDataInst->getIconBackground();
}

string
CwmCustomIcon::
getFg() const
{
  if (fg_.size() > 0)
    return fg_;
  else
    return CwmResourceDataInst->getIconForeground();
}

int
CwmCustomIcon::
getX() const
{
  return x_;
}

int
CwmCustomIcon::
getY() const
{
  return y_;
}

CwmImage *
CwmCustomIcon::
getImage(CwmScreen &screen) const
{
  CwmImage *image = CwmImageMgrInst->getImage(screen, getIcon());

  if (image != 0 && (image->getWidth() > 64 || image->getHeight() > 64))
    image = CwmImageMgrInst->getImage(screen, getIcon(), 64, 64);

  if (image == 0)
    image = CwmImageMgrInst->getImage(screen, "", 64, 64);

  return image;
}

Pixel
CwmCustomIcon::
getBgPixel(CwmScreen &screen) const
{
  std::string bg_color = getBg();

  return screen.getPixel(bg_color, screen.getWhitePixel());
}

Pixel
CwmCustomIcon::
getFgPixel(CwmScreen &screen) const
{
  std::string fg_color = getFg();

  return screen.getPixel(fg_color, screen.getBlackPixel());
}

CwmColor *
CwmCustomIcon::
getColor(CwmScreen &screen) const
{
  Pixel fg = getFgPixel(screen);
  Pixel bg = getBgPixel(screen);

  return screen.getColor(fg, bg);
}

CwmFont *
CwmCustomIcon::
getFont(CwmScreen &screen) const
{
  return CwmResourceDataInst->getIconFont(screen);
}

CwmGraphics *
CwmCustomIcon::
getGraphics(CwmScreen &screen) const
{
  CwmColor *color = getColor(screen);
  CwmFont  *font  = getFont (screen);

  CwmGraphics *graphics = new CwmGraphics(screen, font, color);

  return graphics;
}
##concat##CwmDebug.cpp
#include <CwmI.h>

void
CwmDebug::
print(const std::string &msg)
{
  if (debug_)
    CwmMachineInst->logf("Debug: %s", msg.c_str());
}
##concat##CwmDecorationClose.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmCloseChild::
CwmCloseChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_TITLE)
{
  info_string_ = "Close";
  sides_       = CSIDE_TYPE_NOT_RIGHT;
}

void
CwmCloseChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = frame->getWidth() -
            decoration_->getRightBorder() -
            decoration_->getButtonWidth();
  *y      = decoration_->getTopBorder();
  *width  = decoration_->getButtonWidth();
  *height = decoration_->getTitleHeight();

  if (*x <= decoration_->getLeftBorder() + 4)
    *width = 0;
}

void
CwmCloseChild::
detail()
{
  drawSides(sides_);

  int xc = getWidth ()/2;
  int yc = getHeight()/2;

  int size = 8;

  int x1 = xc - size/2;
  int x2 = xc + size/2;
  int y1 = yc - size/2;
  int y2 = yc + size/2;

  graphics_->drawDarkLine(xwindow_, x1    , y1 + 1, x2 - 1, y2    );
  graphics_->drawDarkLine(xwindow_, x1    , y1    , x2    , y2    );
  graphics_->drawDarkLine(xwindow_, x1 + 1, y1    , x2    , y2 - 1);
  graphics_->drawDarkLine(xwindow_, x1 + 1, y2    , x2    , y1 + 1);
  graphics_->drawDarkLine(xwindow_, x1    , y2    , x2    , y1    );
  graphics_->drawDarkLine(xwindow_, x1    , y2 - 1, x2 - 1, y1    );
}
##concat##CwmDecorationContainer.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask      |
  SubstructureRedirectMask;

CwmContainerChild::
CwmContainerChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_TITLE)
{
}

void
CwmContainerChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = decoration_->getLeftBorder();
  *y      = decoration_->getTopBorder() +
            decoration_->getTitleHeight();
  *width  = frame->getWidth() -
            decoration_->getLeftBorder() -
            decoration_->getRightBorder();
  *height = frame->getHeight() -
            decoration_->getTopBorder() -
            decoration_->getBottomBorder() -
            decoration_->getTitleHeight();
}

void
CwmContainerChild::
detail()
{
}
##concat##CwmDecoration.cpp
#include <CwmDecorationI.h>

CwmDecoration::
CwmDecoration(CwmWMWindow *window) :
 window_(window), has_focus_(false), rolled_up_(false)
{
  n_side_child_ = new CwmNSideChild(this, window);
  s_side_child_ = new CwmSSideChild(this, window);
  e_side_child_ = new CwmESideChild(this, window);
  w_side_child_ = new CwmWSideChild(this, window);

  nw_corner_child_ = new CwmNWCornerChild(this, window);
  ne_corner_child_ = new CwmNECornerChild(this, window);
  sw_corner_child_ = new CwmSWCornerChild(this, window);
  se_corner_child_ = new CwmSECornerChild(this, window);

  maximize_child_ = new CwmMaximizeChild(this, window);
  minimize_child_ = new CwmMinimizeChild(this, window);
  close_child_    = new CwmCloseChild   (this, window);

  menu_child_ = new CwmMenuChild(this, window);

  title_child_ = new CwmTitleChild(this, window);

  container_child_ = new CwmContainerChild(this, window);

  if (window->getBorderDecorationHint()) {
    top_border_    = 0;
    bottom_border_ = 3;
    left_border_   = 3;
    right_border_  = 3;
  }
  else {
    top_border_    = 0;
    bottom_border_ = 0;
    left_border_   = 0;
    right_border_  = 0;
  }

  outside_edge_width_ = 1;
  inside_edge_width_  = 0;

  button_width_ = 18;

  if (window->getTitleDecorationHint()) {
    title_height_ = window->getFontHeight() + 2;

    if (title_height_ < button_width_)
      title_height_ = button_width_;
  }
  else
    title_height_ = 0;

  if (title_height_ > 0)
    resize_height_ = title_height_;
  else
    resize_height_ = 6;

  resize_splitter_ = false;
}

CwmDecoration::
~CwmDecoration()
{
  delete container_child_;

  delete n_side_child_;
  delete s_side_child_;
  delete w_side_child_;
  delete e_side_child_;

  delete nw_corner_child_;
  delete ne_corner_child_;
  delete sw_corner_child_;
  delete se_corner_child_;

  delete maximize_child_;
  delete minimize_child_;
  delete close_child_;

  delete menu_child_;

  delete title_child_;
}

bool
CwmDecoration::
processExpose(XExposeEvent *event)
{
  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

  if (xwindow == 0)
    return false;

  if      (isMenu(xwindow))
    getMenu()->draw();
  else if (isTitle(xwindow))
    getTitle()->draw();
  else if (isMinimize(xwindow))
    getMinimize()->draw();
  else if (isMaximize(xwindow))
    getMaximize()->draw();
  else if (isClose(xwindow))
    getClose()->draw();
  else if (isNSide(xwindow))
    getNSide()->draw();
  else if (isSSide(xwindow))
    getSSide()->draw();
  else if (isWSide(xwindow))
    getWSide()->draw();
  else if (isESide(xwindow))
    getESide()->draw();
  else if (isNWCorner(xwindow))
    getNWCorner()->draw();
  else if (isNECorner(xwindow))
    getNECorner()->draw();
  else if (isSWCorner(xwindow))
    getSWCorner()->draw();
  else if (isSECorner(xwindow))
    getSECorner()->draw();

  return true;
}

bool
CwmDecoration::
processButtonPress(XButtonPressedEvent *event)
{
  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  if (window == 0)
    return false;

  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

  bool flag = true;

  if      (event->button == 1) {
    if      (isMenu(xwindow)) {
      menu_child_->select();

      window_->processWindowMenuAtPosition(0, menu_child_->getHeight());

      menu_child_->deselect();
    }
    else if (isTitle(xwindow)) {
      title_child_->select();

      window->raise();

      CwmMoveWindowInst->moveDelayed(window);

      title_child_->deselect();
    }
    else if (isMinimize(xwindow)) {
      minimize_child_->select();

      Window xwin =
        CwmEventMgrInst->waitForButtonRelease
         (minimize_child_->getXWindow(), CWM_LEFT_BUTTON);

      if (xwin == minimize_child_->getXWindow()->getXWin())
        window->iconise();

      minimize_child_->deselect();
    }
    else if (isMaximize(xwindow)) {
      maximize_child_->select();

      Window xwin =
        CwmEventMgrInst->waitForButtonRelease
         (maximize_child_->getXWindow(), CWM_LEFT_BUTTON);

      if (xwin == maximize_child_->getXWindow()->getXWin())
        window->maximize();

      maximize_child_->deselect();
    }
    else if (isClose(xwindow)) {
      window->close();
    }
    else if (isNSide(xwindow)) {
      window->raise();

      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_TOP);
    }
    else if (isSSide(xwindow)) {
      window->raise();

      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_BOTTOM);
    }
    else if (isWSide(xwindow)) {
      window->raise();

      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_LEFT);
    }
    else if (isESide(xwindow)) {
      window->raise();

      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_RIGHT);
    }
    else if (isNWCorner(xwindow)) {
      window->raise();

      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_TOP_LEFT);
    }
    else if (isNECorner(xwindow)) {
      window->raise();

      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_TOP_RIGHT);
    }
    else if (isSWCorner(xwindow)) {
      window->raise();

      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_BOTTOM_LEFT);
    }
    else if (isSECorner(xwindow)) {
      window->raise();

      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_BOTTOM_RIGHT);
    }
    else
      flag = false;
  }
  else if (event->button == 2) {
    if      (isMenu(xwindow)) {
      CwmWindowEventFunctionMgrInst->
        processEventFunction(window, CWM_WINDOW_MENU_AREA, (XEvent *) event);
    }
    else if (isTitle(xwindow)) {
      title_child_->select();

      CwmMoveWindowInst->moveDelayed(window);

      title_child_->deselect();
    }
    else if (isMinimize(xwindow)) {
      minimize_child_->select();

      Window xwin =
        CwmEventMgrInst->waitForButtonRelease
         (minimize_child_->getXWindow(), CWM_MIDDLE_BUTTON);

      if (xwin == minimize_child_->getXWindow()->getXWin())
        window->iconise();

      minimize_child_->deselect();
    }
    else if (isMaximize(xwindow)) {
      maximize_child_->select();

      Window xwin =
        CwmEventMgrInst->waitForButtonRelease
         (maximize_child_->getXWindow(), CWM_MIDDLE_BUTTON);

      if (xwin == maximize_child_->getXWindow()->getXWin())
        window->minimize();

      maximize_child_->deselect();
    }
    else if (isClose(xwindow)) {
    }
    else if (isNSide(xwindow))
      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_TOP);
    else if (isSSide(xwindow))
      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_BOTTOM);
    else if (isWSide(xwindow))
      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_LEFT);
    else if (isESide(xwindow))
      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_RIGHT);
    else if (isNWCorner(xwindow))
      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_TOP_LEFT);
    else if (isNECorner(xwindow))
      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_TOP_RIGHT);
    else if (isSWCorner(xwindow))
      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_BOTTOM_LEFT);
    else if (isSECorner(xwindow))
      CwmResizeWindowInst->resizeDelayed(window, CWM_RESIZE_BOTTOM_RIGHT);
    else
      flag = false;
  }
  else if (event->button == 3) {
    window->processWindowMenu();
  }

  return flag;
}

bool
CwmDecoration::
isMenu(CwmWindow *xwindow)
{
  return (menu_child_ != 0 && xwindow == menu_child_->getXWindow());
}

bool
CwmDecoration::
isTitle(CwmWindow *xwindow)
{
  return (title_child_ != 0 && xwindow == title_child_->getXWindow());
}

bool
CwmDecoration::
isMinimize(CwmWindow *xwindow)
{
  return (minimize_child_ != 0 && xwindow == minimize_child_->getXWindow());
}

bool
CwmDecoration::
isMaximize(CwmWindow *xwindow)
{
  return (maximize_child_ != 0 && xwindow == maximize_child_->getXWindow());
}

bool
CwmDecoration::
isClose(CwmWindow *xwindow)
{
  return (close_child_ != 0 && xwindow == close_child_->getXWindow());
}

bool
CwmDecoration::
isNSide(CwmWindow *xwindow)
{
  return (n_side_child_ != 0 && xwindow == n_side_child_->getXWindow());
}

bool
CwmDecoration::
isSSide(CwmWindow *xwindow)
{
  return (s_side_child_ != 0 && xwindow == s_side_child_->getXWindow());
}

bool
CwmDecoration::
isWSide(CwmWindow *xwindow)
{
  return (w_side_child_ != 0 && xwindow == w_side_child_->getXWindow());
}

bool
CwmDecoration::
isESide(CwmWindow *xwindow)
{
  return (e_side_child_ != 0 && xwindow == e_side_child_->getXWindow());
}

bool
CwmDecoration::
isNWCorner(CwmWindow *xwindow)
{
  return (nw_corner_child_ != 0 &&
          xwindow == nw_corner_child_->getXWindow());
}

bool
CwmDecoration::
isNECorner(CwmWindow *xwindow)
{
  return (ne_corner_child_ != 0 &&
          xwindow == ne_corner_child_->getXWindow());
}

bool
CwmDecoration::
isSWCorner(CwmWindow *xwindow)
{
  return (sw_corner_child_ != 0 &&
          xwindow == sw_corner_child_->getXWindow());
}

bool
CwmDecoration::
isSECorner(CwmWindow *xwindow)
{
  return (se_corner_child_ != 0 &&
          xwindow == se_corner_child_->getXWindow());
}

void
CwmDecoration::
print()
{
  CwmMachineInst->logf("  Container %x\n",
                       container_child_ ? container_child_->getXWindow() : 0);
  CwmMachineInst->logf("   Menu      %x\n",
                       menu_child_      ? menu_child_     ->getXWindow() : 0);
  CwmMachineInst->logf("   Title     %x\n",
                       title_child_     ? title_child_    ->getXWindow() : 0);
  CwmMachineInst->logf("   Minimize  %x\n",
                       minimize_child_  ? minimize_child_ ->getXWindow() : 0);
  CwmMachineInst->logf("   Maximize  %x\n",
                       maximize_child_  ? maximize_child_ ->getXWindow() : 0);
  CwmMachineInst->logf("   Close     %x\n",
                       close_child_     ? close_child_    ->getXWindow() : 0);
  CwmMachineInst->logf("   N Side    %x\n",
                       n_side_child_    ? n_side_child_   ->getXWindow() : 0);
  CwmMachineInst->logf("   S Side    %x\n",
                       s_side_child_    ? s_side_child_   ->getXWindow() : 0);
  CwmMachineInst->logf("   W Side    %x\n",
                       w_side_child_    ? w_side_child_   ->getXWindow() : 0);
  CwmMachineInst->logf("   E Side    %x\n",
                       e_side_child_    ? e_side_child_   ->getXWindow() : 0);
  CwmMachineInst->logf("   NW Corner %x\n",
                       nw_corner_child_ ? nw_corner_child_->getXWindow() : 0);
  CwmMachineInst->logf("   NE Corner %x\n",
                       ne_corner_child_ ? ne_corner_child_->getXWindow() : 0);
  CwmMachineInst->logf("   SW Corner %x\n",
                       sw_corner_child_ ? sw_corner_child_->getXWindow() : 0);
  CwmMachineInst->logf("   SE Corner %x\n",
                       se_corner_child_ ? se_corner_child_->getXWindow() : 0);
}

void
CwmDecoration::
focusIn(CwmGraphics *graphics)
{
  CwmFocusHighlightType highlight_type =
    CwmResourceDataInst->getFocusHighlightType();

  if      (highlight_type == CWM_FOCUS_HIGHLIGHT_TITLE)
    title_child_->setGraphics(graphics);
  else if (highlight_type == CWM_FOCUS_HIGHLIGHT_ALL) {
    container_child_->setGraphics(graphics);

    n_side_child_   ->setGraphics(graphics);
    s_side_child_   ->setGraphics(graphics);
    w_side_child_   ->setGraphics(graphics);
    e_side_child_   ->setGraphics(graphics);

    nw_corner_child_->setGraphics(graphics);
    ne_corner_child_->setGraphics(graphics);
    sw_corner_child_->setGraphics(graphics);
    se_corner_child_->setGraphics(graphics);

    menu_child_     ->setGraphics(graphics);
    title_child_    ->setGraphics(graphics);
    minimize_child_ ->setGraphics(graphics);
    maximize_child_ ->setGraphics(graphics);
    close_child_    ->setGraphics(graphics);
  }

  has_focus_ = true;
}

void
CwmDecoration::
focusOut(CwmGraphics *graphics)
{
  CwmFocusHighlightType highlight_type =
    CwmResourceDataInst->getFocusHighlightType();

  if      (highlight_type == CWM_FOCUS_HIGHLIGHT_TITLE)
    title_child_->setGraphics(graphics);
  else if (highlight_type == CWM_FOCUS_HIGHLIGHT_ALL) {
    container_child_->setGraphics(graphics);

    n_side_child_   ->setGraphics(graphics);
    s_side_child_   ->setGraphics(graphics);
    w_side_child_   ->setGraphics(graphics);
    e_side_child_   ->setGraphics(graphics);

    nw_corner_child_->setGraphics(graphics);
    ne_corner_child_->setGraphics(graphics);
    sw_corner_child_->setGraphics(graphics);
    se_corner_child_->setGraphics(graphics);

    menu_child_     ->setGraphics(graphics);
    title_child_    ->setGraphics(graphics);
    minimize_child_ ->setGraphics(graphics);
    maximize_child_ ->setGraphics(graphics);
    close_child_    ->setGraphics(graphics);
  }

  has_focus_ = false;
}

void
CwmDecoration::
rollUp()
{
  if (window_->getResizeHandleDecorationHint()) {
    n_side_child_   ->unmap();
    s_side_child_   ->unmap();
    w_side_child_   ->unmap();
    e_side_child_   ->unmap();

    nw_corner_child_->unmap();
    ne_corner_child_->unmap();
    sw_corner_child_->unmap();
    se_corner_child_->unmap();
  }

  menu_child_    ->unmap();
  minimize_child_->unmap();
  maximize_child_->unmap();
  close_child_   ->unmap();

  container_child_->unmap();

  rolled_up_ = true;
}

void
CwmDecoration::
rollDown()
{
  container_child_->map();

  menu_child_    ->map();
  minimize_child_->map();
  maximize_child_->map();
  close_child_   ->map();

  if (window_->getResizeHandleDecorationHint()) {
    n_side_child_->map();
    s_side_child_->map();
    w_side_child_->map();
    e_side_child_->map();

    nw_corner_child_->map();
    ne_corner_child_->map();
    sw_corner_child_->map();
    se_corner_child_->map();
  }

  rolled_up_ = false;
}

void
CwmDecoration::
decorate()
{
  if (window_->getResizeHandleDecorationHint()) {
    n_side_child_->map();
    s_side_child_->map();
    w_side_child_->map();
    e_side_child_->map();

    nw_corner_child_->map();
    ne_corner_child_->map();
    sw_corner_child_->map();
    se_corner_child_->map();
  }

  if (window_->getCloseDecorationHint())
    close_child_->map();

  if (window_->getMaximizeDecorationHint())
    maximize_child_->map();

  if (window_->getMinimizeDecorationHint())
    minimize_child_->map();

  if (window_->getMenuDecorationHint())
    menu_child_->map();

  if (window_->getTitleDecorationHint())
    title_child_->map();

  container_child_->map();

  CwmWindow *xwindow = menu_child_->getXWindow();

  xwindow->addCallback(CWM_CALLBACK_DOUBLE_CLICK_1,
                       &CwmDecoration::closeDoubleClickProc,
                       (CwmData) window_);
}

void
CwmDecoration::
redecorate()
{
  if (! rolled_up_) {
    if (window_->getResizeHandleDecorationHint()) {
      n_side_child_->update();
      s_side_child_->update();
      w_side_child_->update();
      e_side_child_->update();

      nw_corner_child_->update();
      ne_corner_child_->update();
      sw_corner_child_->update();
      se_corner_child_->update();
    }

    if (window_->getCloseDecorationHint())
      close_child_->update();

    if (window_->getMaximizeDecorationHint())
      maximize_child_->update();

    if (window_->getMinimizeDecorationHint())
      minimize_child_->update();

    if (window_->getMenuDecorationHint())
      menu_child_->update();

    if (window_->getTitleDecorationHint())
      title_child_->update();

    container_child_->update();
  }
  else
    title_child_->update();
}

void
CwmDecoration::
reparent(CwmWindow *user_xwindow)
{
  user_xwindow->reparent(container_child_->getXWindow(), 0, 0);
}

void
CwmDecoration::
redraw()
{
  menu_child_     ->draw();
  title_child_    ->draw();
  minimize_child_ ->draw();
  maximize_child_ ->draw();
  close_child_    ->draw();

  n_side_child_   ->draw();
  s_side_child_   ->draw();
  w_side_child_   ->draw();
  e_side_child_   ->draw();

  nw_corner_child_->draw();
  ne_corner_child_->draw();
  sw_corner_child_->draw();
  se_corner_child_->draw();
}

void
CwmDecoration::
closeDoubleClickProc(CwmWindow *, CwmData data, CwmData)
{
  CwmWMWindow *window = (CwmWMWindow *) data;

  window->close();
}

int
CwmDecoration::
getTopBorder() const
{
  return top_border_;
}

int
CwmDecoration::
getBottomBorder() const
{
  return bottom_border_;
}

int
CwmDecoration::
getLeftBorder() const
{
  return left_border_;
}

int
CwmDecoration::
getRightBorder() const
{
  return right_border_;
}

int
CwmDecoration::
getOutsideEdgeWidth() const
{
  return outside_edge_width_;
}

int
CwmDecoration::
getInsideEdgeWidth() const
{
  return inside_edge_width_;
}

int
CwmDecoration::
getButtonWidth () const
{
  return button_width_;
}

int
CwmDecoration::
getTitleHeight () const
{
  return title_height_;
}

int
CwmDecoration::
getResizeHeight() const
{
  return resize_height_;
}

bool
CwmDecoration::
hasResizeSplitter() const
{
  return resize_splitter_;
}
##concat##CwmDecorationESide.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmESideChild::
CwmESideChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_E)
{
}

void
CwmESideChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = frame->getWidth() -
            decoration_->getRightBorder();
  *y      = decoration_->getResizeHeight() +
            decoration_->getTopBorder();
  *width  = decoration_->getRightBorder();
  *height = frame->getHeight() -
            2*decoration_->getResizeHeight() -
            decoration_->getTopBorder() -
            decoration_->getBottomBorder();
}

void
CwmESideChild::
detail()
{
  int x1 = 0;
  int y1 = 0;
  int x2 = getWidth () - 1;
  int y2 = getHeight() - 1;

  int oe = decoration_->getOutsideEdgeWidth();
  int ie = decoration_->getInsideEdgeWidth ();

  // Outside Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawVDarkLine (xwindow_, x2 - i, y1, y2);

  // Inside Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawVLightLine(xwindow_, x1 + i, y1, y2);

  // Top and Bottom Splitters

  if (decoration_->hasResizeSplitter()) {
    graphics_->drawHDarkLine (xwindow_, x1 + 1, x2 - 1, y2);
    graphics_->drawHLightLine(xwindow_, x1 + 1, x2 - 1, y1);
  }
}
##concat##CwmDecorationMaximize.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmMaximizeChild::
CwmMaximizeChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_TITLE)
{
  info_string_ = "Maximize";
  sides_       = CSIDE_TYPE_ALL;
}

void
CwmMaximizeChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_    ->getFrame();
  CwmWindowChild *close = decoration_->getClose();

  *x      = frame->getWidth() -
            decoration_->getRightBorder() -
            decoration_->getButtonWidth();
  *y      = decoration_->getTopBorder();
  *width  = decoration_->getButtonWidth();
  *height = decoration_->getTitleHeight();

  if (close->getMapped())
    *x -= close->getWidth();

  if (*x <= decoration_->getLeftBorder() + 4)
    *width = 0;
}

void
CwmMaximizeChild::
detail()
{
  drawSides(sides_);

  int width  = getWidth ();
  int height = getHeight();

  int size = std::min(width - 8, height - 8);
  int xc   = width /2;
  int yc   = height/2;

  if (window_->isMaximized() || window_->isMinimized())
    graphics_->drawButtonIn (xwindow_, xc - size/2, yc - size/2, size, size, 1);
  else
    graphics_->drawButtonOut(xwindow_, xc - size/2, yc - size/2, size, size, 1);
}
##concat##CwmDecorationMenu.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmMenuChild::
CwmMenuChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_TITLE)
{
  info_string_ = "Menu";
  sides_       = CSIDE_TYPE_HORIZONTAL;
}

void
CwmMenuChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = decoration_->getLeftBorder();
  *y      = decoration_->getTopBorder ();
  *width  = decoration_->getButtonWidth();
  *height = decoration_->getTitleHeight();

  if (*x + *width >= frame->getWidth() - decoration_->getRightBorder() - 4)
    *width = 0;
}

void
CwmMenuChild::
detail()
{
  drawSidesOut(sides_);

  graphics_->drawButtonOut(xwindow_,
                           3, (getHeight() - 1)/2 - 2,
                           getWidth() - 8, 4,
                           1);
}
##concat##CwmDecorationMinimize.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmMinimizeChild::
CwmMinimizeChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_TITLE)
{
  info_string_ = "Minimize";
  sides_       = CSIDE_TYPE_ALL;
}

void
CwmMinimizeChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame    = window_    ->getFrame   ();
  CwmWindowChild *close    = decoration_->getClose   ();
  CwmWindowChild *maximize = decoration_->getMaximize();

  *x      = frame->getWidth() -
            decoration_->getRightBorder() -
            decoration_->getButtonWidth();
  *y      = decoration_->getTopBorder  ();
  *width  = decoration_->getButtonWidth();
  *height = decoration_->getTitleHeight();

  if (close->getMapped())
    *x -= close->getWidth();

  if (maximize->getMapped())
    *x -= maximize->getWidth();

  if (*x <= decoration_->getLeftBorder() + 4)
    *width = 0;
}

void
CwmMinimizeChild::
detail()
{
  drawSides(sides_);

  int width  = getWidth ();
  int height = getHeight();

  int size = 4;
  int xc   = width /2;
  int yc   = height/2;

  graphics_->drawButtonOut(xwindow_, xc - size/2, yc - size/2, size, size, 1);
}
##concat##CwmDecorationNECorner.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmNECornerChild::
CwmNECornerChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_NE)
{
}

void
CwmNECornerChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = frame->getWidth() -
            decoration_->getButtonWidth() -
            decoration_->getRightBorder();
  *y      = 0;
  *width  = decoration_->getButtonWidth() +
            decoration_->getRightBorder();
  *height = decoration_->getResizeHeight() +
            decoration_->getTopBorder();
}

void
CwmNECornerChild::
detail()
{
  int x1 = 0;
  int y1 = 0;
  int x2 = getWidth()  - 1;
  int y2 = getHeight() - 1;

  int w = decoration_->getRightBorder();
  int h = decoration_->getTopBorder  ();

  int oe = decoration_->getOutsideEdgeWidth();
  int ie = decoration_->getInsideEdgeWidth ();

  // Outside Top Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawHLightLine(xwindow_, x1, x2 - i, y1 + i);

  // Outside Right Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawVDarkLine (xwindow_, x2 - i, y1 + i + 1, y2);

  // Inside Right Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawVLightLine(xwindow_, x2 - w + 1 - i, y1 + h + i, y2);

  // Inside Top Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawHDarkLine (xwindow_, x1, x2 - w + 1 - i, y1 + h - 1 + i);

  // Top Left and Bottom Right Splitters

  if (decoration_->hasResizeSplitter()) {
    graphics_->drawVLightLine(xwindow_, x1, y1 + oe, y1 + (h - 1));
    graphics_->drawHDarkLine (xwindow_, x2 - (w - 2), x2 - oe, y2);
  }
}
##concat##CwmDecorationNSide.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmNSideChild::
CwmNSideChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_N)
{
}

void
CwmNSideChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = decoration_->getButtonWidth() +
            decoration_->getLeftBorder();
  *y      = 0;
  *width  = frame->getWidth() -
            2*decoration_->getButtonWidth() -
            decoration_->getLeftBorder () -
            decoration_->getRightBorder();
  *height = decoration_->getTopBorder();
}

void
CwmNSideChild::
detail()
{
  int x1 = 0;
  int y1 = 0;
  int x2 = getWidth () - 1;
  int y2 = getHeight() - 1;

  int oe = decoration_->getOutsideEdgeWidth();
  int ie = decoration_->getInsideEdgeWidth ();

  // Outside Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawHLightLine(xwindow_, x1, x2, y1 + i);

  // Inside Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawHDarkLine(xwindow_, x1, x2, y2 - i);

  // Left and Right Splitters

  if (decoration_->hasResizeSplitter()) {
    graphics_->drawVLightLine(xwindow_, x1, y1 + 1, y2 - 1);
    graphics_->drawVDarkLine (xwindow_, x2, y1 + 1, y2 - 1);
  }
}
##concat##CwmDecorationNWCorner.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmNWCornerChild::
CwmNWCornerChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_NW)
{
}

void
CwmNWCornerChild::
calcSize(int *x, int *y, int *width, int *height)
{
  *x      = 0;
  *y      = 0;
  *width  = decoration_->getButtonWidth() +
            decoration_->getLeftBorder ();
  *height = decoration_->getResizeHeight() +
            decoration_->getTopBorder   ();
}

void
CwmNWCornerChild::
detail()
{
  int x1 = 0;
  int y1 = 0;
  int x2 = getWidth()  - 1;
  int y2 = getHeight() - 1;

  int w = decoration_->getLeftBorder();
  int h = decoration_->getTopBorder ();

  int oe = decoration_->getOutsideEdgeWidth();
  int ie = decoration_->getInsideEdgeWidth ();

  // Outside Top Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawHLightLine(xwindow_, x1 + i, x2 - i, y1 + i);

  // Outside Left Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawVLightLine(xwindow_, x1 + i, y1 + i + 1, y2 - i);

  // Inside Top Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawHDarkLine(xwindow_, x1 + w - 1 + i, x2, y1 + h - 1 + i);

  // Inside Left Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawVDarkLine(xwindow_, x1 + w - 1 + i, y1 + h + i, y2);

  // Top Right and Bottom Left Splitters */

  if (decoration_->hasResizeSplitter()) {
    graphics_->drawVDarkLine(xwindow_, x2, y1 + 1, y1 + h - 1);
    graphics_->drawHDarkLine(xwindow_, x1 + w - 2, x1 + 1, y2);
  }
}
##concat##CwmDecorationSECorner.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmSECornerChild::
CwmSECornerChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_SE)
{
}

void
CwmSECornerChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = frame->getWidth () -
            decoration_->getButtonWidth() -
            decoration_->getRightBorder();
  *y      = frame->getHeight() -
            decoration_->getResizeHeight() -
            decoration_->getBottomBorder();
  *width  = decoration_->getButtonWidth () +
            decoration_->getRightBorder ();
  *height = decoration_->getResizeHeight() +
            decoration_->getBottomBorder();
}

void
CwmSECornerChild::
detail()
{
  int x1 = 0;
  int y1 = 0;
  int x2 = getWidth()  - 1;
  int y2 = getHeight() - 1;

  int w = decoration_->getRightBorder ();
  int h = decoration_->getBottomBorder();

  int oe = decoration_->getOutsideEdgeWidth();
  int ie = decoration_->getInsideEdgeWidth ();

  // Outside Bottom Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawHDarkLine(xwindow_, x1 + i, x2 - i, y2 - i);

  // Outside Right Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawVDarkLine(xwindow_, x2 - i, y2 - i - 1, y1 + i);

  // Inside Right Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawVLightLine(xwindow_, x2 - w + 1 - i, y1, y2 - h - i);

  // Inside Bottom Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawHLightLine(xwindow_, x1, x2 - w + 1 - i, y2 - h + 1 - i);

  // Top Right and Bottom Left Splitters

  if (decoration_->hasResizeSplitter()) {
    graphics_->drawVLightLine(xwindow_, x1, y2 - 1, y2 - h + 1);
    graphics_->drawHLightLine(xwindow_, x2 - w + 1, x2 - 1, y1);
  }
}
##concat##CwmDecorationSSide.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmSSideChild::
CwmSSideChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_S)
{
}

void
CwmSSideChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = decoration_->getButtonWidth() +
            decoration_->getLeftBorder ();
  *y      = frame->getHeight() -
            decoration_->getBottomBorder();
  *width  = frame->getWidth () -
            2*decoration_->getButtonWidth() -
            decoration_->getLeftBorder () -
            decoration_->getRightBorder();
  *height = decoration_->getBottomBorder();
}

void
CwmSSideChild::
detail()
{
  int x1 = 0;
  int y1 = 0;
  int x2 = getWidth () - 1;
  int y2 = getHeight() - 1;

  int oe = decoration_->getOutsideEdgeWidth();
  int ie = decoration_->getInsideEdgeWidth ();

  // Outside Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawHDarkLine(xwindow_, x1, x2, y2 - i);

  // Inside Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawHLightLine(xwindow_, x1, x2, y1 + i);

  // Top and Bottom Splitters

  if (decoration_->hasResizeSplitter()) {
    graphics_->drawVDarkLine (xwindow_, x2, y2 - 1, y1 + 1);
    graphics_->drawVLightLine(xwindow_, x1, y2 - 1, y1    );
  }
}
##concat##CwmDecorationSWCorner.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmSWCornerChild::
CwmSWCornerChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_SW)
{
}

void
CwmSWCornerChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = 0;
  *y      = frame->getHeight() -
            decoration_->getResizeHeight() -
            decoration_->getBottomBorder();
  *width  = decoration_->getButtonWidth () +
            decoration_->getLeftBorder  ();
  *height = decoration_->getResizeHeight() +
            decoration_->getBottomBorder();
}

void
CwmSWCornerChild::
detail()
{
  int x1 = 0;
  int y1 = 0;
  int x2 = getWidth()  - 1;
  int y2 = getHeight() - 1;

  int w = decoration_->getLeftBorder  ();
  int h = decoration_->getBottomBorder();

  int oe = decoration_->getOutsideEdgeWidth();
  int ie = decoration_->getInsideEdgeWidth ();

  // Outside Bottom Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawHDarkLine(xwindow_, x1 + i + 1, x2, y2 - i);

  // Outside Left Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawVLightLine(xwindow_, x1 + i, y1, y2 - i);

  // Inside Bottom Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawHLightLine(xwindow_, x1 + w + i, x2, y2 - h + 1 - i);

  // Inside Left Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawVDarkLine(xwindow_, x1 + w + 1 + i, y1, y2 - h + 1 - i);

  // Top Left and Bottom Right Splitters

  if (decoration_->hasResizeSplitter()) {
    graphics_->drawHLightLine(xwindow_, x1 + oe, x1 + (w - 1), y1);
    graphics_->drawVDarkLine (xwindow_, x2, y2 - (h - 2), y2 - oe);
  }
}
##concat##CwmDecorationTitle.cpp
#include <CwmDecorationI.h>
#include <CGradient.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmTitleChild::
CwmTitleChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_TITLE),
 gradient1_(0), gradient2_(0), gradient3_(0), gradient4_(0),
 gradient_width_(0), gradient_height_(0), focus_graphics_(0), nofocus_graphics_(0)
{
  sides_ = CSIDE_TYPE_HORIZONTAL;
}

CwmTitleChild::
~CwmTitleChild()
{
  delete gradient1_;
  delete gradient2_;
  delete gradient3_;
  delete gradient4_;
  delete focus_graphics_;
  delete nofocus_graphics_;
}

void
CwmTitleChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame    = window_    ->getFrame   ();
  CwmWindowChild *menu     = decoration_->getMenu    ();
  CwmWindowChild *close    = decoration_->getClose   ();
  CwmWindowChild *minimize = decoration_->getMinimize();
  CwmWindowChild *maximize = decoration_->getMaximize();

  if (! window_->getRolledUp()) {
    *x      = decoration_->getLeftBorder();
    *y      = decoration_->getTopBorder ();
    *width  = frame->getWidth() - *x - decoration_->getRightBorder();
    *height = decoration_->getTitleHeight();

    if (menu->getMapped()) {
      *x     += menu->getWidth();
      *width -= menu->getWidth();
    }

    if (close->getMapped())
      *width -= close->getWidth();

    if (minimize->getMapped())
      *width -= minimize->getWidth();

    if (maximize->getMapped())
      *width -= maximize->getWidth();
  }
  else {
    *x      = 0;
    *y      = 0;
    *width  = frame->getWidth();
    *height = decoration_->getTitleHeight();
  }
}

void
CwmTitleChild::
detail()
{
  CwmTitlePatternType type = CwmResourceDataInst->getTitlePatternType();

  if (type == CWM_TITLE_PATTERN_GRADIENT)
    detailGradient();
  else
    detailSolid();
}

void
CwmTitleChild::
detailGradient()
{
  std::string name = window_->getName();

  int width  = getWidth ();
  int height = getHeight();

  if (width <= 2 || height <= 2)
    return;

  if (width != gradient_width_ || height != gradient_height_) {
    delete gradient1_;
    delete gradient2_;
    delete gradient3_;
    delete gradient4_;

    gradient1_ = 0;
    gradient2_ = 0;
    gradient3_ = 0;
    gradient4_ = 0;
  }

  if (gradient1_ == 0) {
    CwmColor *color1 = CwmResourceDataInst->getTitleGradientColor(window_->getScreen());
    CwmColor *color2 = CwmResourceDataInst->getTitleGradientFocusColor(window_->getScreen());

    CRGBA start;
    CRGBA end;

    start = color2->getBgRGBA();
    end   = color2->getFgRGBA();

    gradient1_ = new CGradient(start, end, width - 2, height - 2, CGRADIENT_DIR_RDIAGONAL);

    start = color2->getFgRGBA();
    end   = color2->getBgRGBA();

    gradient2_ = new CGradient(start, end, width - 2, height - 2, CGRADIENT_DIR_RDIAGONAL);

    start = color1->getBgRGBA();
    end   = color1->getFgRGBA();

    gradient3_ = new CGradient(start, end, width - 2, height - 2, CGRADIENT_DIR_RDIAGONAL);

    start = color1->getFgRGBA();
    end   = color1->getBgRGBA();

    gradient4_ = new CGradient(start, end, width - 2, height - 2, CGRADIENT_DIR_RDIAGONAL);

    gradient_width_  = width;
    gradient_height_ = height;
  }

  CGradient *gradient = 0;

  if (decoration_->hasFocus()) {
    if (selected_)
      gradient = gradient1_;
    else
      gradient = gradient2_;
  }
  else {
    if (selected_)
      gradient = gradient3_;
    else
      gradient = gradient4_;
  }

  CImagePtr image1 = gradient->getImage();

  CwmImage *cimage = new CwmImage(window_->getScreen(), image1);

  cimage->draw(xwindow_, graphics_, 1, 1);

  delete cimage;

  graphics_->drawHLine(xwindow_, 0, width - 1,          0, gradient->getStart());
  graphics_->drawHLine(xwindow_, 0, width - 1, height - 1, gradient->getEnd  ());

  graphics_->drawVLine(xwindow_, 0        , 0, height - 1, gradient->getStart());
  graphics_->drawVLine(xwindow_, width - 1, 0, height - 1, gradient->getEnd  ());

  drawText(name);
}

void
CwmTitleChild::
detailSolid()
{
  std::string name = window_->getName();

  int width  = getWidth ();
  int height = getHeight();

  if (width <= 2 || height <= 2)
    return;

  if (focus_graphics_ == 0) {
    CwmFont  *font  = CwmResourceDataInst->getFocusFont(window_->getScreen());
    CwmColor *color = CwmResourceDataInst->getTitleFocusColor(window_->getScreen());

    focus_graphics_ = new CwmGraphics(window_->getScreen(), font, color);
  }

  if (nofocus_graphics_ == 0) {
    CwmFont  *font  = CwmResourceDataInst->getFont(window_->getScreen());
    CwmColor *color = CwmResourceDataInst->getTitleColor(window_->getScreen());

    nofocus_graphics_ = new CwmGraphics(window_->getScreen(), font, color);
  }

  if (decoration_->hasFocus())
    focus_graphics_  ->fillRectangle(xwindow_, 0, 0, width, height);
  else
    nofocus_graphics_->fillRectangle(xwindow_, 0, 0, width, height);

  drawText(name);
}
##concat##CwmDecorationWindow.cpp
#include <CwmDecorationI.h>

CwmWindowChild::
CwmWindowChild(CwmDecoration *decoration, CwmWMWindow *window,
               uint event_mask, CwmCursorType cursor) :
 decoration_(decoration), window_(window), xwindow_(None),
 selected_(false), info_string_("")
{
  xwindow_ = new CwmWindow(window_->getScreen(),
                           window_->getFrameWindow(),
                           0, 0, 1, 1,
                           event_mask, cursor);

  graphics_ = window_->getGraphics();

  xwindow_->setBackground(graphics_);

  xwindow_->addCallback(CWM_CALLBACK_IDLE,
                        &CwmWindowChild::idleProc,
                        (CwmData) this);
}

CwmWindowChild::
~CwmWindowChild()
{
  delete xwindow_;
}

CwmScreen &
CwmWindowChild::
getScreen() const
{
  return window_->getScreen();
}

void
CwmWindowChild::
update()
{
  int x, y, width, height;

  calcSize(&x, &y, &width, &height);

  if (width <= 0 || height <= 0) {
    unmap();

    return;
  }

  xwindow_->moveResize(x, y, width, height);

  map();
}

void
CwmWindowChild::
draw()
{
  xwindow_->setBackground(graphics_);

  CwmEventMgrInst->flushExposeEvents(xwindow_);

  xwindow_->clear();

  detail();
}

void
CwmWindowChild::
drawBorder()
{
  if (selected_)
    drawBorderIn();
  else
    drawBorderOut();
}

void
CwmWindowChild::
drawBorderOut()
{
  graphics_->drawButtonOut(xwindow_, 0, 0, getWidth(), getHeight(), 1);
}

void
CwmWindowChild::
drawBorderIn()
{
  graphics_->drawButtonIn(xwindow_, 0, 0, getWidth(), getHeight(), 1);
}

void
CwmWindowChild::
drawSides(int sides)
{
  if (selected_)
    drawSidesIn(sides);
  else
    drawSidesOut(sides);
}

void
CwmWindowChild::
drawSidesOut(int sides)
{
  graphics_->drawSidesOut(xwindow_, sides, 0, 0, getWidth(), getHeight(), 1);
}

void
CwmWindowChild::
drawSidesIn(int sides)
{
  graphics_->drawSidesIn(xwindow_, sides, 0, 0, getWidth(), getHeight(), 1);
}

void
CwmWindowChild::
drawText(const std::string &text)
{
  CHAlignType align = CwmResourceDataInst->getTitleAlign();

  graphics_->drawTextAligned(xwindow_,
                             1, 1,
                             getWidth() - 2, getHeight() - 2,
                             align, CVALIGN_TYPE_CENTER,
                             text);
}

void
CwmWindowChild::
map()
{
  xwindow_->map();
}

void
CwmWindowChild::
unmap()
{
  xwindow_->unmap();
}

void
CwmWindowChild::
select()
{
  if (selected_)
    return;

  selected_ = true;

  draw();

  CwmMachineInst->flushEvents();
}

void
CwmWindowChild::
deselect()
{
  if (! selected_)
    return;

  selected_ = false;

  draw();

  CwmMachineInst->flushEvents();
}

bool
CwmWindowChild::
getMapped() const
{
  return xwindow_->getMapped();
}

int
CwmWindowChild::
getX() const
{
  return xwindow_->getX();
}

int
CwmWindowChild::
getY() const
{
  return xwindow_->getY();
}

int
CwmWindowChild::
getWidth() const
{
  return xwindow_->getWidth();
}

int
CwmWindowChild::
getHeight() const
{
  return xwindow_->getHeight();
}

void
CwmWindowChild::
idleProc(CwmWindow *, CwmData data, CwmData detail)
{
  CwmWindowChild *window_child = (CwmWindowChild *) data;
  CwmIdleState   *idle_state   = (CwmIdleState   *) detail;

  CwmScreen &screen = window_child->window_->getScreen();

  if (window_child->info_string_ == "")
    return;

  if (idle_state->getActive())
    screen.showInfo(window_child->info_string_);
  else
    screen.hideInfo();
}
##concat##CwmDecorationWSide.cpp
#include <CwmDecorationI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask;

CwmWSideChild::
CwmWSideChild(CwmDecoration *decoration, CwmWMWindow *window) :
 CwmWindowChild(decoration, window, event_mask, CWM_CURSOR_W)
{
}

void
CwmWSideChild::
calcSize(int *x, int *y, int *width, int *height)
{
  CwmFrameWindow *frame = window_->getFrame();

  *x      = 0;
  *y      = decoration_->getResizeHeight() +
            decoration_->getTopBorder   ();
  *width  = decoration_->getLeftBorder();
  *height = frame->getHeight() -
            2*decoration_->getResizeHeight() -
            decoration_->getTopBorder() -
            decoration_->getBottomBorder();
}

void
CwmWSideChild::
detail()
{
  int x1 = 0;
  int y1 = 0;
  int x2 = getWidth () - 1;
  int y2 = getHeight() - 1;

  int oe = decoration_->getOutsideEdgeWidth();
  int ie = decoration_->getInsideEdgeWidth ();

  // Outside Hightlight

  for (int i = 0; i < oe; i++)
    graphics_->drawVLightLine(xwindow_, x1 + i, y1, y2);

  // Inside Hightlight

  for (int i = 0; i < ie; i++)
    graphics_->drawVDarkLine (xwindow_, x2 - i, y1, y2);

  // Top and Bottom Splitters

  if (decoration_->hasResizeSplitter()) {
    graphics_->drawHLightLine(xwindow_, x1 + 1, x2 - 1, y1);
    graphics_->drawHDarkLine (xwindow_, x1 + 1, x2 - 1, y2);
  }
}
##concat##CwmDeskIcon.cpp
#include <CwmDeskI.h>

CwmDeskIconMgr::
CwmDeskIconMgr(CwmDesk &desk) :
 desk_(desk)
{
  CwmWindowGlobalNotifyMgrInst->
    addProc(CWM_WINDOW_NOTIFY_CREATE, &CwmDeskIconMgr::createNotifyProc, this);
  CwmWindowGlobalNotifyMgrInst->
    addProc(CWM_WINDOW_NOTIFY_DESTROY, &CwmDeskIconMgr::destroyNotifyProc, this);
  CwmWindowGlobalNotifyMgrInst->
    addProc(CWM_WINDOW_NOTIFY_ICONISE, &CwmDeskIconMgr::iconiseNotifyProc, this);
  CwmWindowGlobalNotifyMgrInst->
    addProc(CWM_WINDOW_NOTIFY_RESTORE, &CwmDeskIconMgr::restoreNotifyProc, this);

  CwmDeskMgr *desk_mgr = desk_.getDeskMgr();

  desk_mgr->addNotifyProc(CWM_DESK_MGR_NOTIFY_CHANGE_START,
                          &CwmDeskIconMgr::deskChangeStartNotifyProc, this);
  desk_mgr->addNotifyProc(CWM_DESK_MGR_NOTIFY_CHANGE_END,
                          &CwmDeskIconMgr::deskChangeEndNotifyProc, this);

  move_event_    = 0;
  lower_event_   = 0;
  raise_event_   = 0;
  close_event_   = 0;
  restore_event_ = 0;
}

CwmDeskIconMgr::
~CwmDeskIconMgr()
{
  CwmDeskMgr *desk_mgr = desk_.getDeskMgr();

  desk_mgr->removeNotifyProc(CWM_DESK_MGR_NOTIFY_CHANGE_START,
                             &CwmDeskIconMgr::deskChangeStartNotifyProc, this);
  desk_mgr->removeNotifyProc(CWM_DESK_MGR_NOTIFY_CHANGE_END,
                             &CwmDeskIconMgr::deskChangeEndNotifyProc, this);

  CwmWindowGlobalNotifyMgrInst->
    removeProc(CWM_WINDOW_NOTIFY_CREATE, &CwmDeskIconMgr::createNotifyProc, this);
  CwmWindowGlobalNotifyMgrInst->
    removeProc(CWM_WINDOW_NOTIFY_DESTROY, &CwmDeskIconMgr::destroyNotifyProc, this);
  CwmWindowGlobalNotifyMgrInst->
    removeProc(CWM_WINDOW_NOTIFY_ICONISE, &CwmDeskIconMgr::iconiseNotifyProc, this);
  CwmWindowGlobalNotifyMgrInst->
    removeProc(CWM_WINDOW_NOTIFY_RESTORE, &CwmDeskIconMgr::restoreNotifyProc, this);

  delete move_event_;
  delete lower_event_;
  delete raise_event_;
  delete close_event_;
  delete restore_event_;
}

void
CwmDeskIconMgr::
createNotifyProc(CwmWMWindow *window, CwmWindowNotifyType, void *data)
{
  CwmDeskIconMgr *mgr = (CwmDeskIconMgr *) data;

  if (mgr->isWindowOnDesk(window)) {
    CwmDeskIcon *icon = new CwmDeskIcon(*mgr, window);

    mgr->addDeskIcon(icon);
  }
}

void
CwmDeskIconMgr::
destroyNotifyProc(CwmWMWindow *window, CwmWindowNotifyType, void *data)
{
  CwmDeskIconMgr *mgr = (CwmDeskIconMgr *) data;

  if (mgr->isWindowOnDesk(window)) {
    CwmDeskIcon *icon = mgr->lookup(window);

    if (icon != 0)
      mgr->removeDeskIcon(icon);

    delete icon;
  }
}

void
CwmDeskIconMgr::
iconiseNotifyProc(CwmWMWindow *window, CwmWindowNotifyType, void *data)
{
  CwmDeskIconMgr *mgr = (CwmDeskIconMgr *) data;

  if (mgr->isWindowOnDesk(window)) {
    CwmDeskIcon *icon = mgr->lookup(window);

    if (icon != 0)
      icon->map();
  }
}

void
CwmDeskIconMgr::
restoreNotifyProc(CwmWMWindow *window, CwmWindowNotifyType, void *data)
{
  CwmDeskIconMgr *mgr = (CwmDeskIconMgr *) data;

  if (mgr->isWindowOnDesk(window)) {
    CwmDeskIcon *icon = mgr->lookup(window);

    if (icon != 0)
      icon->unmap();
  }
}

void
CwmDeskIconMgr::
deskChangeStartNotifyProc(CwmDeskMgr *desk_mgr, CwmDeskMgrNotifyType, CwmData data)
{
  CwmDeskIconMgr *mgr = (CwmDeskIconMgr *) data;

  if (mgr->isCurrentDesk(desk_mgr))
    mgr->unmapIcons();
}

void
CwmDeskIconMgr::
deskChangeEndNotifyProc(CwmDeskMgr *desk_mgr, CwmDeskMgrNotifyType, CwmData data)
{
  CwmDeskIconMgr *mgr = (CwmDeskIconMgr *) data;

  if (mgr->isCurrentDesk(desk_mgr))
    mgr->mapIcons();
}

bool
CwmDeskIconMgr::
isCurrentDesk(CwmDeskMgr *desk_mgr)
{
  return (desk_mgr->getCurrentDesk() == &desk_);
}

bool
CwmDeskIconMgr::
isWindowOnDesk(CwmWMWindow *window)
{
  return (window->getDeskNum() == desk_.getNum());
}

void
CwmDeskIconMgr::
addDeskIcon(CwmDeskIcon *icon)
{
  desk_icon_map_[icon->getXWin()] = icon;
}

void
CwmDeskIconMgr::
removeDeskIcon(CwmDeskIcon *icon)
{
  CwmDeskIconMap::iterator picon = desk_icon_map_.find(icon->getXWin());

  if (picon != desk_icon_map_.end())
    desk_icon_map_.erase(picon);
}

void
CwmDeskIconMgr::
mapIcons()
{
  CwmDeskIconMap::const_iterator picon1 = desk_icon_map_.begin();
  CwmDeskIconMap::const_iterator picon2 = desk_icon_map_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    (*picon1).second->map();
}

void
CwmDeskIconMgr::
unmapIcons()
{
  CwmDeskIconMap::const_iterator picon1 = desk_icon_map_.begin();
  CwmDeskIconMap::const_iterator picon2 = desk_icon_map_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    (*picon1).second->unmap();
}

CwmDeskIcon *
CwmDeskIconMgr::
lookup(CwmWMWindow *window)
{
  Window xwin = window->getXWin();

  return lookup(xwin);
}

CwmDeskIcon *
CwmDeskIconMgr::
lookup(CwmWindow *xwindow)
{
  Window xwin = xwindow->getXWin();

  return lookup(xwin);
}

CwmDeskIcon *
CwmDeskIconMgr::
lookup(Window xwin)
{
  CwmDeskIconMap::iterator picon = desk_icon_map_.find(xwin);

  if (picon != desk_icon_map_.end())
    return (*picon).second;
  else
    return 0;
}

CXNamedEvent *
CwmDeskIconMgr::
getMoveEvent()
{
  if (move_event_ == 0)
    move_event_ = new CXNamedEvent("Alt<Key>F7");

  return move_event_;
}

CXNamedEvent *
CwmDeskIconMgr::
getLowerEvent()
{
  if (lower_event_ == 0)
    lower_event_ = new CXNamedEvent("Alt<Key>F3");

  return lower_event_;
}

CXNamedEvent *
CwmDeskIconMgr::
getRaiseEvent()
{
  if (raise_event_ == 0)
    raise_event_ = new CXNamedEvent("Alt<Key>F2");

  return raise_event_;
}

CXNamedEvent *
CwmDeskIconMgr::
getRestoreEvent()
{
  if (restore_event_ == 0)
    restore_event_ = new CXNamedEvent("Alt<Key>F5");

  return restore_event_;
}

CXNamedEvent *
CwmDeskIconMgr::
getCloseEvent()
{
  if (close_event_ == 0)
    close_event_ = new CXNamedEvent("Alt<Key>F4");

  return close_event_;
}

CwmDeskIcon::
CwmDeskIcon(CwmDeskIconMgr &mgr, CwmWMWindow *window) :
 mgr_(mgr), desk_(mgr_.getDesk()), screen_(window->getScreen()), window_(window)
{
  CwmColor *color = CwmResourceDataInst->getIconColor(screen_);
  CwmFont  *font  = CwmResourceDataInst->getIconFont (screen_);

  graphics_ = new CwmGraphics(*window, font, color);

  //------

  if (window->getIconXHint() != -1)
    icon_x_ = window->getIconXHint();
  else
    icon_x_ = 4;

  if (window->getIconYHint() != -1)
    icon_y_ = window->getIconYHint();
  else
    icon_y_ = 4;

  //------

  if (CwmResourceDataInst->getIconImageDecoration())
    image_ = window->getImage();
  else
    image_ = 0;

  pixmap_mask_  = 0;
  label_mask_   = 0;
  mask_created_ = false;

  //------

  if (CwmResourceDataInst->getIconLabelDecoration()) {
    std::string name = window->getIconName();

    int icon_label_width = CwmResourceDataInst->getIconLabelWidth();

    fmt_string_ = new CFmtString(name, icon_label_width);
  }
  else
    fmt_string_ = 0;

  //------

  calcSize();

  //------

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask   |
                    KeyPressMask    | ExposureMask;

  xwindow_ =
    new CwmWindow(screen_, screen_.getRoot(),
                  icon_x_, icon_y_,
                  icon_width_, icon_height_,
                  event_mask,
                  CWM_CURSOR_TITLE);

  //------

  menu_def_ = 0;

  //------

  xwindow_->addCallback(CWM_CALLBACK_DOUBLE_CLICK_1,
                        CwmDeskIcon::doubleClickProc,
                        (CwmData) this);
}

CwmDeskIcon::
~CwmDeskIcon()
{
  delete graphics_;

  delete xwindow_;

  delete menu_def_;

  delete pixmap_mask_;

  delete label_mask_;
}

Window
CwmDeskIcon::
getXWin() const
{
  return getXWindow()->getXWin();
}

void
CwmDeskIcon::
move()
{
  bool has_focus = CwmMachineInst->isFocusWindow(window_);

  if (has_focus) {
    CwmMachineInst->setFocusWindow(0);

    redraw();
  }

  removeFromGrid();

  xwindow_->raise();

  int dx, dy;

  CwmMoveWindowInst->moveInteractive(screen_, xwindow_, icon_x_, icon_y_,
                                     icon_width_, icon_height_, &dx, &dy);

  if (icon_x_ + dx < 0)
    dx = -icon_x_;

  if (icon_y_ + dy < 0)
    dy = -icon_y_;

  if (icon_x_ + icon_width_  + dx > screen_.getWidth ())
    dx = screen_.getWidth () - icon_x_ - icon_width_ ;

  if (icon_y_ + icon_height_ + dy > screen_.getHeight())
    dy = screen_.getHeight() - icon_y_ - icon_height_;

  icon_x_ += dx;
  icon_y_ += dy;

  xwindow_->lower();

  addToGrid();

  if (has_focus)
    CwmMachineInst->setFocusWindow(window_);

  if (has_focus)
    redraw();
}

void
CwmDeskIcon::
raise()
{
  xwindow_->raise();
}

void
CwmDeskIcon::
lower()
{
  xwindow_->lower();
}

void
CwmDeskIcon::
restore()
{
  unmap();

  window_->restore();
}

void
CwmDeskIcon::
close()
{
  window_->close();
}

void
CwmDeskIcon::
redraw()
{
  if (! mask_created_)
    createMask();

  //------

  std::string name = window_->getIconName();

  fmt_string_->setString(name);

  int width, height;

  getLabelSize(&width, &height);

  if (width != label_width_ || height != label_height_) {
    label_width_  = width;
    label_height_ = height;

    //------

    icon_width_ = std::max( label_width_ + 2* label_dx_, pixmap_width_ + 2*pixmap_dx_);

    icon_height_ = pixmap_dy_ + pixmap_height_ + std::max(pixmap_dy_, label_dy_) +
                   label_dy_  + label_height_;

    //------

    pixmap_offset_ = (icon_width_ - pixmap_width_)/2;
    label_offset_  = (icon_width_ - label_width_ )/2;

    //------

    xwindow_->moveResize(icon_x_, icon_y_, icon_width_, icon_height_);

    //------

    createMask();
  }

  //------

  if (CwmResourceDataInst->getIconImageDecoration())
    image_->draw(xwindow_, graphics_, pixmap_dx_ + pixmap_offset_, pixmap_dy_);

  if (CwmResourceDataInst->getIconLabelDecoration()) {
    int y = pixmap_dy_ + pixmap_height_ + std::max(pixmap_dy_, label_dy_);

    int num_lines = fmt_string_->getNumLines();

    for (int i = 0; i < num_lines; ++i) {
      int width1, height1;

      std::string line = CStrUtil::stripSpaces(fmt_string_->getLine(i));

      graphics_->getTextSize(line, &width1, &height1);

      graphics_->drawTextCentered(xwindow_, label_dx_ + label_offset_, y,
                                  label_width_, height1, line);

      y += height1 + 1;
    }
  }

  if (CwmResourceDataInst->getIconImageBorder())
    graphics_->drawButtonOut(xwindow_, 0, 0, xwindow_->getWidth (), xwindow_->getHeight(), 2);

  if (CwmMachineInst->isFocusWindow(window_)) {
    //int dy = (pixmap_width_ > label_width_ ? 1 : 0);

    int x1 = 0;
    int x2 = xwindow_->getWidth() - 1;

    int y1 = 0;
    int y2 = xwindow_->getHeight() - 1;

    int x[4] = { x1, x2, x2, x1 };
    int y[4] = { y1, y1, y2, y2 };

    for (int i1 = 0; i1 < 4; ++i1) {
      int i2 = (i1 + 1) % 4;

      graphics_->drawLine(xwindow_, x[i1], y[i1], x[i2], y[i2]);
    }
  }
}

void
CwmDeskIcon::
createMask()
{
  int op = ShapeSet;

  if (CwmResourceDataInst->getIconImageDecoration()) {
    delete pixmap_mask_;

    pixmap_mask_ = image_->createMask();

    CwmMachineInst->shapeCombineMask(xwindow_->getXWin(), pixmap_mask_->getXPixmap(),
                                     pixmap_dx_ + pixmap_offset_, pixmap_dy_, op);

    op = ShapeUnion;
  }

  if (CwmResourceDataInst->getIconLabelDecoration()) {
    delete label_mask_;

    label_mask_ = new CwmMask(screen_, graphics_, label_width_, label_height_);

    int y = 0;

    int num_lines = fmt_string_->getNumLines();

    for (int i = 0; i < num_lines; ++i) {
      int width1, height1;

      std::string line = CStrUtil::stripSpaces(fmt_string_->getLine(i));

      graphics_->getTextSize(line, &width1, &height1);

      label_mask_->drawString((label_width_ - width1)/2, y, line);

      y += height1 + 1;
    }

    label_mask_->combine(xwindow_, label_dx_ + label_offset_,
                         pixmap_dy_ + pixmap_height_ + std::max(pixmap_dy_, label_dy_), op);
  }

  mask_created_ = true;
}

void
CwmDeskIcon::
map()
{
  xwindow_->map();

  xwindow_->lower();

  //------

  window_->addNotifyProc(CWM_WINDOW_NOTIFY_FOCUS_IN, &CwmDeskIcon::focusInNotifyProc, this);
  window_->addNotifyProc(CWM_WINDOW_NOTIFY_FOCUS_OUT, &CwmDeskIcon::focusOutNotifyProc, this);

  //------

  addToGrid();
}

void
CwmDeskIcon::
unmap()
{
  window_->removeNotifyProc(CWM_WINDOW_NOTIFY_FOCUS_IN, &CwmDeskIcon::focusInNotifyProc, this);
  window_->removeNotifyProc(CWM_WINDOW_NOTIFY_FOCUS_OUT, &CwmDeskIcon::focusOutNotifyProc, this);

  //------

  xwindow_->unmap();

  removeFromGrid();
}

bool
CwmDeskIcon::
getMapped() const
{
  return xwindow_->getMapped();
}

void
CwmDeskIcon::
setBackground(CwmGraphics *graphics)
{
  xwindow_->setBackground(graphics);

  redraw();
}

bool
CwmDeskIcon::
isWindow(Window xwin)
{
  if (xwindow_->getXWin() == xwin)
    return true;

  return false;
}

bool
CwmDeskIcon::
isWindow(CwmWindow *xwindow)
{
  if (xwindow_ == xwindow)
    return true;

  return false;
}

void
CwmDeskIcon::
addToGrid()
{
  int x11 = icon_x_;
  int y11 = icon_y_;
  int x21 = icon_x_ + icon_width_  - 1;
  int y21 = icon_y_ + icon_height_ - 1;

  int x12 = x11;
  int y12 = y11;
  int x22 = x21;
  int y22 = y21;

  CwmGrid *grid = screen_.getIconGrid();

  grid->add(this, &x12, &y12, &x22, &y22, CWM_INSERT_LEFT, CWM_INSERT_BOTTOM);

  icon_x_ = x12;
  icon_y_ = y12;

  xwindow_->move(icon_x_, icon_y_);
}

void
CwmDeskIcon::
removeFromGrid()
{
  CwmGrid *grid = screen_.getIconGrid();

  grid->remove(this);
}

void
CwmDeskIcon::
processKeyPress(XKeyPressedEvent *event)
{
  XEvent *event1 = (XEvent *) event;

  if      (mgr_.getMoveEvent   ()->matchEvent(event1))
    move();
  else if (mgr_.getLowerEvent  ()->matchEvent(event1))
    lower();
  else if (mgr_.getRaiseEvent  ()->matchEvent(event1))
    raise();
  else if (mgr_.getRestoreEvent()->matchEvent(event1))
    restore();
  else if ( mgr_.getCloseEvent ()->matchEvent(event1))
    close();
}

void
CwmDeskIcon::
calcSize()
{
  pixmap_dx_ = 0;
  pixmap_dy_ = 0;

  if (CwmResourceDataInst->getIconImageBorder()) {
    pixmap_dx_ += 2;
    pixmap_dy_ += 2;
  }

  if (CwmResourceDataInst->getIconImageDecoration()) {
    pixmap_width_  = image_->getWidth ();
    pixmap_height_ = image_->getHeight();
  }

  //------

  label_dx_ = 0;
  label_dy_ = 0;

  if (CwmResourceDataInst->getIconImageBorder()) {
    label_dx_ += 2;
    label_dy_ += 2;
  }

  if (CwmResourceDataInst->getIconImageDecoration() &&
      CwmResourceDataInst->getIconLabelDecoration())
    label_dy_ = 2;

  getLabelSize(&label_width_, &label_height_);

  //------

  icon_width_ = std::max( label_width_ + 2* label_dx_, pixmap_width_ + 2*pixmap_dx_);

  icon_height_ = pixmap_dy_ + pixmap_height_ + std::max(pixmap_dy_, label_dy_) +
                 label_dy_  + label_height_;

  //------

  pixmap_offset_ = (icon_width_ - pixmap_width_ - 2*pixmap_dx_)/2;
  label_offset_  = (icon_width_ - label_width_  - 2*label_dy_ )/2;

}

void
CwmDeskIcon::
getLabelSize(int *width, int *height)
{
  *width  = 0;
  *height = 0;

  if (! CwmResourceDataInst->getIconLabelDecoration())
    return;

  int num_lines = fmt_string_->getNumLines();

  for (int i = 0; i < num_lines; ++i) {
    std::string line = fmt_string_->getLine(i);

    int width1, height1;

    graphics_->getTextSize(line, &width1, &height1);

    if (width1 > *width)
      *width = width1;

    *height += height1 + 1;
  }

  bool clip = true;

  if (CwmMachineInst->isFocusWindow(window_) &&
      CwmResourceDataInst->getIconActiveLabelDecoration())
    clip = false;

  if (! CwmResourceDataInst->getIconClipLabelDecoration())
    clip = false;

  if (! CwmResourceDataInst->getIconImageDecoration())
    clip = false;

  if (clip)
    *width = pixmap_width_;
  else {
    if (*width < pixmap_width_)
      *width = pixmap_width_;
  }
}

void
CwmDeskIcon::
focusIn()
{
  if (! CwmResourceDataInst->getIconLabelDecoration())
    return;

  calcSize();

  xwindow_->resize(icon_width_, icon_height_);
}

void
CwmDeskIcon::
focusOut()
{
  if (! CwmResourceDataInst->getIconLabelDecoration())
    return;

  calcSize();

  xwindow_->resize(icon_width_, icon_height_);
}

void
CwmDeskIcon::
processMenu()
{
  if (menu_def_ == 0)
    createMenuDef();

  CwmMenu::processWindowMenu(screen_, xwindow_, menu_def_);
}

void
CwmDeskIcon::
createMenuDef()
{
  menu_def_ = new CwmMenuDef();

  menu_def_->addButton("", "Restore", 'R', "Alt<Key>F5",
                       (CwmMenuProc) CwmDeskIcon::restoreProc, (CwmData) this);

  menu_def_->addButton("", "Move", 'M', "Alt<Key>F7",
                       (CwmMenuProc) CwmDeskIcon::moveProc, (CwmData) this);

  menu_def_->addButton("", "Raise", 'a', "Alt<Key>F2",
                       (CwmMenuProc) CwmDeskIcon::raiseProc, (CwmData) this);

  menu_def_->addButton("", "Lower", 'L', "Alt<Key>F3",
                       (CwmMenuProc) CwmDeskIcon::lowerProc, (CwmData) this);

  if (window_->getCloseFunctionHint()) {
    menu_def_->addSplitter("--------");

    menu_def_->addButton("", "Close", 'C', "Alt<Key>F4",
                         (CwmMenuProc) CwmDeskIcon::closeProc, (CwmData) this);
  }
}

void
CwmDeskIcon::
doubleClickProc(CwmWindow *, CwmData data, CwmData)
{
  CwmDeskIcon *icon = (CwmDeskIcon *) data;

  icon->restore();
}

void
CwmDeskIcon::
restoreProc(CwmDeskIcon *icon, CwmData)
{
  icon->restore();
}

void
CwmDeskIcon::
moveProc(CwmDeskIcon *icon, CwmData)
{
  icon->move();
}

void
CwmDeskIcon::
raiseProc(CwmDeskIcon *icon, CwmData)
{
  icon->raise();
}

void
CwmDeskIcon::
lowerProc(CwmDeskIcon *icon, CwmData)
{
  icon->lower();
}

void
CwmDeskIcon::
closeProc(CwmDeskIcon *icon, CwmData)
{
  icon->close();
}

void
CwmDeskIcon::
circulateUpProc(CwmDeskIcon *icon, CwmData)
{
  icon->screen_.circulateUp();
}

void
CwmDeskIcon::
circulateDownProc(CwmDeskIcon *icon, CwmData)
{
  icon->screen_.circulateDown();
}

void
CwmDeskIcon::
focusNextProc(CwmDeskIcon *icon, CwmData)
{
  CwmMachineInst->focusNext(icon->screen_);
}

void
CwmDeskIcon::
focusPrevProc(CwmDeskIcon *icon, CwmData)
{
  CwmMachineInst->focusPrev(icon->screen_);
}

void
CwmDeskIcon::
namedMenuProc(CwmDeskIcon *icon, CwmData data)
{
  std::string *name = (string *) data;

  CwmMenuDef *menu_def_ = CwmNamedMenuMgrInst->lookupMenuDef(*name);

  if (menu_def_ == 0) {
    CwmMachineInst->logf("Menu %s not found\n", (*name).c_str());
    return;
  }

  CwmMenu::processMenu(icon, menu_def_);
}

void
CwmDeskIcon::
focusInNotifyProc(CwmWMWindow *, CwmWindowNotifyType, void *data)
{
  CwmDeskIcon *icon = (CwmDeskIcon *) data;

  icon->focusIn();
}

void
CwmDeskIcon::
focusOutNotifyProc(CwmWMWindow *, CwmWindowNotifyType, void *data)
{
  CwmDeskIcon *icon = (CwmDeskIcon *) data;

  icon->focusOut();
}

CwmCustomDeskIconMgr *
CwmCustomDeskIconMgr::
getInstance()
{
  static CwmCustomDeskIconMgr *instance;

  if (! instance)
    instance = new CwmCustomDeskIconMgr();

  return instance;
}

void
CwmCustomDeskIconMgr::
setIcon(const std::string &pattern, const std::string &icon)
{
  CwmCustomDeskIcon *custom_icon = lookup(pattern);

  custom_icon->setIcon(icon);
}

void
CwmCustomDeskIconMgr::
setIconSmall(const std::string &pattern, const std::string &icon)
{
  CwmCustomDeskIcon *custom_icon = lookup(pattern);

  custom_icon->setIconSmall(icon);
}

string
CwmCustomDeskIconMgr::
getIcon(CwmWMWindow *window)
{
  std::string res_name  = window->getResName ();
  std::string res_class = window->getResClass();

  int num_icons = icons_.size();

  for (int i = 0; i < num_icons; i++) {
    if (icons_[i]->compare(res_name ) ||
        icons_[i]->compare(res_class))
      return icons_[i]->getIcon();
  }

  return "";
}

string
CwmCustomDeskIconMgr::
getIconSmall(CwmWMWindow *window)
{
  std::string res_name  = window->getResName ();
  std::string res_class = window->getResClass();

  int num_icons = icons_.size();

  for (int i = 0; i < num_icons; i++) {
    if (icons_[i]->compare(res_name) || icons_[i]->compare(res_class))
      return icons_[i]->getIconSmall();
  }

  return "";
}

void
CwmCustomDeskIconMgr::
deleteAll()
{
  int num_icons = icons_.size();

  for (int i = 0; i < num_icons; i++)
    delete icons_[i];

  icons_.clear();
}

CwmCustomDeskIcon *
CwmCustomDeskIconMgr::
lookup(const std::string &pattern)
{
  int num_icons = icons_.size();

  for (int i = 0; i < num_icons; i++)
    if (icons_[i]->isPattern(pattern))
      return icons_[i];

  CwmCustomDeskIcon *custom_icon = new CwmCustomDeskIcon(pattern);

  icons_.push_back(custom_icon);

  return custom_icon;
}

CwmCustomDeskIcon::
CwmCustomDeskIcon(const std::string &pattern) :
 pattern_(pattern), compile_(0), icon_(""), icon_small_("")
{
  compile_ = new CGlob(pattern_.c_str());
}

CwmCustomDeskIcon::
~CwmCustomDeskIcon()
{
  delete compile_;
}

bool
CwmCustomDeskIcon::
compare(const std::string &name)
{
  return compile_->compare(name);
}
##concat##CwmDeskMgr.cpp
#include <CwmDeskI.h>

CwmDeskMgr::
CwmDeskMgr(CwmScreen &screen, int num_desks) :
 screen_(screen)
{
  for (int i = 0; i < num_desks; i++) {
    CwmDesk *desk = new CwmDesk(this, i);

    desks_.push_back(desk);
  }

  current_desk_ = 0;
  menu_def_     = 0;
}

CwmDeskMgr::
~CwmDeskMgr()
{
  notify_procs_.clear();

  std::for_each(desks_.begin(), desks_.end(), CDeletePointer());
}

void
CwmDeskMgr::
changeDesk(int desk_num)
{
  if (desk_num < 0 || desk_num >= (int) desks_.size())
    return;

  changeDesk(desks_[desk_num]);
}

void
CwmDeskMgr::
changeDesk(CwmDesk *desk)
{
  if (desk == current_desk_)
    return;

  callNotifyProcs(CWM_DESK_MGR_NOTIFY_CHANGE_START);

  if (current_desk_ != 0)
    current_desk_->hide();

  current_desk_ = desk;

  current_desk_->show();

  CwmGnomeInst->setCurrentDesktop(screen_);

  CwmGnomeInst->setListOfManagedClients(screen_);

  callNotifyProcs(CWM_DESK_MGR_NOTIFY_CHANGE_END);
}

void
CwmDeskMgr::
processMenu()
{
  CwmMenuDef *menu_def = getMenuDef();

  for (int i = 0; i < (int) desks_.size(); i++) {
    CwmMenuEntry *entry = menu_def->getEntry(i + 2);

    entry->setSelected(desks_[i] == current_desk_);
  }

  CwmMenu::processWindowMenu(screen_, screen_.getRoot(), menu_def);
}

CwmMenuDef *
CwmDeskMgr::
getMenuDef()
{
  if (menu_def_ != 0)
    return menu_def_;

  menu_def_ = new CwmMenuDef();

  menu_def_->addTitle   ("Desk");
  menu_def_->addSplitter("----");

  for (int i = 0; i < (int) desks_.size(); i++) {
    std::string desk_name = desks_[i]->getName();
    char   mnemonic  = desks_[i]->getMnemonic();

    menu_def_->addToggle("",
                         desk_name, mnemonic, "",
                         (CwmMenuProc) CwmDeskMgr::moveToDesk,
                         (CwmData) this, (CwmData) desks_[i]);
  }

  return menu_def_;
}

void
CwmDeskMgr::
moveToDesk(CwmDeskMgr *desk_mgr, CwmDesk *desk)
{
  desk_mgr->changeDesk(desk);
}

int
CwmDeskMgr::
getDeskNum(CwmWMWindow *window)
{
  CwmDesk *desk = getDesk(window);

  if (desk != 0)
    return desk->getNum();

  return 0;
}

CwmDesk *
CwmDeskMgr::
getDesk(int num)
{
  if (num < 0 || num >= (int) desks_.size()) {
    CwmMachineInst->logf("Invalid Desk Number %d\n", num);
    return 0;
  }

  return desks_[num];
}

CwmDesk *
CwmDeskMgr::
getDesk(CwmWMWindow *window)
{
  int num_desks = desks_.size();

  for (int i = 0; i < num_desks; i++) {
    CwmDesk *desk = desks_[i];

    CwmDesk::WMWindowList windows = desk->getWindows();

    CwmDesk::WMWindowList::const_iterator pwindow1 = windows.begin();
    CwmDesk::WMWindowList::const_iterator pwindow2 = windows.end  ();

    for ( ; pwindow1 != pwindow2; ++pwindow1)
      if (*pwindow1 == window)
        return desk;
  }

  return 0;
}

int
CwmDeskMgr::
getCurrentDeskNum() const
{
  return current_desk_->getNum();
}

CwmDeskResourceMgr *
CwmDeskResourceMgr::
getInstance()
{
  static CwmDeskResourceMgr *instance;

  if (! instance)
    instance = new CwmDeskResourceMgr();

  return instance;
}

CwmDeskResourceMgr::
CwmDeskResourceMgr()
{
}

CwmDeskResourceMgr::
~CwmDeskResourceMgr()
{
}

string
CwmDeskResourceMgr::
getDeskName(int desk_num)
{
  if (desk_name_.find(desk_num) != desk_name_.end())
    return desk_name_[desk_num];
  else
    return CStrUtil::toString(desk_num);
}

bool
CwmDeskResourceMgr::
getDeskDisplayIcons(int desk_num)
{
  if (desk_display_icons_.find(desk_num) != desk_display_icons_.end())
    return desk_display_icons_[desk_num];
  else
    return false;
}

bool
CwmDeskResourceMgr::
getDeskDisplayToolBar(int desk_num)
{
  if (desk_display_toolbar_.find(desk_num) != desk_display_toolbar_.end())
    return desk_display_toolbar_[desk_num];
  else
    return true;
}

string
CwmDeskResourceMgr::
getDeskImage(int desk_num)
{
  if (desk_image_name_.find(desk_num) != desk_image_name_.end())
    return desk_image_name_[desk_num];
  else
    return "";
}

void
CwmDeskResourceMgr::
setDeskName(int desk_num, const std::string &name)
{
  desk_name_[desk_num] = name;
}

void
CwmDeskResourceMgr::
setDeskDisplayIcons(int desk_num, bool display_icons)
{
  desk_display_icons_[desk_num] = display_icons;
}

void
CwmDeskResourceMgr::
setDeskDisplayToolBar(int desk_num, bool display_toolbar)
{
  desk_display_toolbar_[desk_num] = display_toolbar;
}

void
CwmDeskResourceMgr::
setDeskImage(int desk_num, const std::string &image_name)
{
  desk_image_name_[desk_num] = image_name;
}

void
CwmDeskMgr::
addNotifyProc(CwmDeskMgrNotifyType type,
              CwmDeskMgrNotifyProc proc, void *data)
{
  CwmDeskMgrNotifyData *notify_proc =
    new CwmDeskMgrNotifyData(type, proc, data);

  notify_procs_.push_back(notify_proc);
}

void
CwmDeskMgr::
removeNotifyProc(CwmDeskMgrNotifyType type, CwmDeskMgrNotifyProc proc,
                 void *data)
{
  DeskMgrNotifyDataList::const_iterator pnotify_proc1 = notify_procs_.begin();
  DeskMgrNotifyDataList::const_iterator pnotify_proc2 = notify_procs_.end  ();

  while (pnotify_proc1 != pnotify_proc2) {
    if ((*pnotify_proc1)->match(type, proc, data)) {
      notify_procs_.remove(*pnotify_proc1);

      delete *pnotify_proc1;

      pnotify_proc1 = notify_procs_.begin();
      pnotify_proc2 = notify_procs_.end  ();
    }
    else
      ++pnotify_proc1;
  }
}

void
CwmDeskMgr::
callNotifyProcs(CwmDeskMgrNotifyType type)
{
  DeskMgrNotifyDataList::const_iterator pnotify_proc1 = notify_procs_.begin();
  DeskMgrNotifyDataList::const_iterator pnotify_proc2 = notify_procs_.end  ();

  for ( ; pnotify_proc1 != pnotify_proc2; ++pnotify_proc1)
    (*pnotify_proc1)->setCalled(false);

  pnotify_proc1 = notify_procs_.begin();

  while (pnotify_proc1 != pnotify_proc2) {
    if ((*pnotify_proc1)->isType(type) && ! (*pnotify_proc1)->getCalled()) {
      (*pnotify_proc1)->setCalled(true);

      (*pnotify_proc1)->call(this);

      pnotify_proc1 = notify_procs_.begin();
      pnotify_proc2 = notify_procs_.end  ();
    }
    else
      ++pnotify_proc1;
  }
}

void
CwmDeskMgr::
enable()
{
  int num_desks = desks_.size();

  for (int i = 0; i < num_desks; i++)
    desks_[i]->enable();
}

void
CwmDeskMgr::
disable()
{
  int num_desks = desks_.size();

  for (int i = 0; i < num_desks; i++)
    desks_[i]->disable();
}

CwmDesk::
CwmDesk(CwmDeskMgr *mgr, int num) :
 mgr_(mgr), num_(num), root_image_(0)
{
  name_ = CwmDeskResourceMgrInst->getDeskName(num);

  mnemonic_ = name_[0];

  root_image_spec_ = CwmDeskResourceMgrInst->getDeskImage(num);

  if (root_image_spec_ == "")
    root_image_spec_ = CwmInst->getRootImage();

  if (CwmDeskResourceMgrInst->getDeskDisplayIcons(num))
    icon_mgr_ = new CwmDeskIconMgr(*this);
  else
    icon_mgr_ = 0;

  if (CwmDeskResourceMgrInst->getDeskDisplayToolBar(num))
    toolbar_mgr_ = new CwmToolBarMgr(*this);
  else
    toolbar_mgr_ = 0;
}

CwmDesk::
~CwmDesk()
{
  delete icon_mgr_;
  delete toolbar_mgr_;
}

void
CwmDesk::
addWMWindow(CwmWMWindow *window)
{
  windows_.push_back(window);

  CwmScreen &screen = mgr_->getScreen();

  CwmGnomeInst->setListOfManagedClients(screen);
}

void
CwmDesk::
removeWMWindow(CwmWMWindow *window)
{
  windows_.remove(window);

  CwmScreen &screen = mgr_->getScreen();

  CwmGnomeInst->setListOfManagedClients(screen);
}

void
CwmDesk::
hide()
{
  WMWindowList::const_iterator pwindow1 = windows_.begin();
  WMWindowList::const_iterator pwindow2 = windows_.end  ();

  for ( ; pwindow1 != pwindow2; ++pwindow1)
    if (! (*pwindow1)->isIconised())
      (*pwindow1)->unmap();
}

void
CwmDesk::
show()
{
  WMWindowList::const_iterator pwindow1 = windows_.begin();
  WMWindowList::const_iterator pwindow2 = windows_.end  ();

  for ( ; pwindow1 != pwindow2; ++pwindow1)
    if (! (*pwindow1)->isIconised())
      (*pwindow1)->map();

  drawRootImage();
}

void
CwmDesk::
setRootImage(const std::string &spec)
{
  root_image_spec_ = spec;

  initRootImage();
}

void
CwmDesk::
drawRootImage()
{
  if (root_image_ == 0)
    initRootImage();

  CwmGrabServer grab;

  root_image_->draw();
}

void
CwmDesk::
initRootImage()
{
  CwmGrabServer grab;

  root_image_ = new CwmRootImage(mgr_->getScreen(), root_image_spec_);
}

CwmScreen &
CwmDesk::
getScreen() const
{
  return mgr_->getScreen();
}

CwmToolBar *
CwmDesk::
getToolBar() const
{
  if (toolbar_mgr_ != 0)
    return toolbar_mgr_->getToolBar();
  else
    return 0;
}

void
CwmDesk::
enable()
{
  if (toolbar_mgr_ != 0)
    toolbar_mgr_->enable();
}

void
CwmDesk::
disable()
{
  if (toolbar_mgr_ != 0)
    toolbar_mgr_->disable();
}
##concat##CwmEventMgr.cpp
#include <CwmI.h>
#include <CXAtom.h>

#include <cassert>
#include <sstream>

CwmEventMgr::
CwmEventMgr()
{
  last_event_time_   = 0;

  multiclick_window_ = None;
  multiclick_button_ = 0;
  multiclick_time_   = 0;
  multiclick_count_  = 0;

  save_event_window_ = None;
  save_event_mask_   = 0;
}

CwmEventMgr::
~CwmEventMgr()
{
}

CwmEventMgr *
CwmEventMgr::
getInstance()
{
  static CwmEventMgr *instance;

  if (! instance)
    instance = new CwmEventMgr();

  return instance;
}

void
CwmEventMgr::
flushEvents(bool sync)
{
  CwmMachineInst->flushEvents(sync);
}

void
CwmEventMgr::
processEvents()
{
  XEvent event;

  while (eventPending()) {
    CwmMachineInst->nextEvent(&event);

    processEvent(&event);
  }
}

bool
CwmEventMgr::
eventPending()
{
  return CwmMachineInst->eventPending();
}

XEvent *
CwmEventMgr::
processNextEvent()
{
  static XEvent event;

  bool event_found = false;

  CwmIdleInst->start();

  while (! event_found) {
    CwmMachineInst->nextEvent(&event);

    event_found = processEvent(&event);
  }

  CwmIdleInst->start();

  return &event;
}

bool
CwmEventMgr::
processEvent(XEvent *event)
{
  if (CwmMachineInst->getDebug())
    printEvent(event);

  memcpy(&last_event_, event, sizeof(XEvent));

  switch (event->type) {
    case MapRequest:
      return processMapRequest((XMapRequestEvent *) event);
    case MapNotify:
      return processMapNotify((XMapEvent *) event);
    case UnmapNotify:
      return processUnmapNotify((XUnmapEvent *) event);
    case ConfigureRequest:
      return processConfigureRequest((XConfigureRequestEvent *) event);
    case ConfigureNotify:
      return processConfigureNotify((XConfigureEvent *) event);
    case ReparentNotify:
      return processReparentNotify((XReparentEvent *) event);
    case EnterNotify:
      return processEnterNotify((XEnterWindowEvent *) event);
    case LeaveNotify:
      return processLeaveNotify((XLeaveWindowEvent *) event);
    case ButtonPress:
      return processButtonPress((XButtonPressedEvent *) event);
    case ButtonRelease:
      return processButtonRelease((XButtonReleasedEvent *) event);
    case KeyPress:
      return processKeyPress((XKeyPressedEvent *) event);
    case KeyRelease:
      return processKeyRelease((XKeyReleasedEvent *) event);
    case MotionNotify:
      return processMotionNotify((XMotionEvent *) event);
    case Expose:
      return processExpose((XExposeEvent *) event);
    case NoExpose:
      return processNoExpose((XNoExposeEvent *) event);
    case FocusIn:
      return processFocusIn((XFocusChangeEvent *) event);
    case FocusOut:
      return processFocusOut((XFocusChangeEvent *) event);
    case PropertyNotify:
      return processPropertyNotify((XPropertyEvent *) event);
    case VisibilityNotify:
      return processVisibilityNotify((XVisibilityEvent *) event);
    case DestroyNotify:
      return processDestroyNotify((XDestroyWindowEvent *) event);
    case ColormapNotify:
      return processColormapNotify((XColormapEvent *) event);
    case ClientMessage:
      return processClientMessage((XClientMessageEvent *) event);
    case MappingNotify:
      return processMappingNotify((XMappingEvent *) event);
    default:
      CwmMachineInst->logf("Unhandled Event %s\n", CwmMachineInst->getEventName(event).c_str());
      break;
  }

  return false;
}

void
CwmEventMgr::
printEvent(XEvent *event)
{
  if (event->type == MotionNotify)
    return;

  Window xwin = CwmMachineInst->getEventWindow(event);

  if (! CwmMachineInst->isValidWindow(xwin))
    CwmMachineInst->logf("printEvent: Invalid Window %x, Event %s\n", (uint) xwin,
                         CwmMachineInst->getEventName(event).c_str());

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(xwin);

  std::string name;

  if (window != 0)
    name = window->getName();
  else {
    std::ostringstream ost;

    ost << std::hex << (uint) xwin;

    name = ost.str();
  }

  std::string event_name = CwmMachineInst->getEventName(event);

  event_name += " " + name;

  if (event->type != MotionNotify)
    CwmMachineInst->debugf("%s\n", event_name.c_str());
}

int
CwmEventMgr::
getLastEventType()
{
  return last_event_.type;
}

Time
CwmEventMgr::
getLastEventTime()
{
  return last_event_time_;
}

bool
CwmEventMgr::
processMapRequest(XMapRequestEvent *event)
{
  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  if (window != 0) {
    if (window->isIconised())
      window->restore();

    return false;
  }

  CwmScreen &screen = CwmMachineInst->getWindowScreen(event->window);

  CwmGrabServer grab;

  window = screen.addWMWindow(event->window);

  CwmUserWindow *user = window->getUser();

  if (user != 0)
    user->sendConfigureNotify();

  return false;
}

bool
CwmEventMgr::
processMapNotify(XMapEvent *event)
{
  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  if (window == 0)
    return false;

  window->restore();

  return false;
}

bool
CwmEventMgr::
processUnmapNotify(XUnmapEvent *event)
{
  CwmWMWindow *window = CwmMachineInst->getUserWindowWMWindow(event->window);

  if (window == 0)
    return false;

  if (CwmMachineInst->getDebug())
    window->print();

  if (isDestroyPending(event->window)) {
    CwmUserWindow *user = window->getUser();

    if (user != 0) {
      CwmWindow *xwindow = user->getXWindow();

      if (event->window == xwindow->getXWin())
        user->setXWindow(None);
    }
  }

  if (! window->getRolledUp()) {
    CwmGrabServer grab;

    window->remove();
  }

  return false;
}

bool
CwmEventMgr::
processConfigureRequest(XConfigureRequestEvent *event)
{
  XEvent event1;

  if (CwmMachineInst->checkWindowTypedEvent(event->window, MapRequest, &event1))
    processMapRequest((XMapRequestEvent *) &event1);

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  XWindowChanges xwc;
  uint           mask;

  if (window != 0) {
    CwmMachineInst->debugf("ConfigureRequest %s\n", window->getName().c_str());

    if (event->value_mask & CWX)
      CwmMachineInst->debugf("X = %d\n", event->x);
    if (event->value_mask & CWY)
      CwmMachineInst->debugf("Y = %d\n", event->y);
    if (event->value_mask & CWWidth)
      CwmMachineInst->debugf("Width = %d\n", event->width);
    if (event->value_mask & CWHeight)
      CwmMachineInst->debugf("Height = %d\n", event->height);
    if (event->value_mask & CWBorderWidth)
      CwmMachineInst->debugf("Border = %d\n", event->border_width);

    CwmMachineInst->debugf("Mask %x\n", event->value_mask);

    CwmUserWindow *user = window->getUser();

    if (user != 0) {
      CwmWindow *xwindow = user->getXWindow();

      if (event->window != xwindow->getXWin()) {
        CwmMachineInst->log("Configure on non-user window\n");
        return false;
      }
    }

    mask = CWX | CWY | CWWidth | CWHeight;

    mask &= event->value_mask;

    CwmMachineInst->debugf("Mask %x\n", mask);

    xwc.x      = event->x;
    xwc.y      = event->y;
    xwc.width  = event->width;
    xwc.height = event->height;

    CwmFrameWindow *frame = window->getFrame();

    CwmDecoration *decoration = window->getDecoration();

    if (! (event->value_mask & CWX))
      xwc.x = frame->getX() + decoration->getLeftBorder();

    if (! (event->value_mask & CWY))
      xwc.y = frame->getY() + decoration->getTopBorder() +
              decoration->getTitleHeight();

    if (! (event->value_mask & CWWidth))
      xwc.width = user->getWidth();

    if (! (event->value_mask & CWHeight))
      xwc.height = user->getHeight();

    frame->moveResize(xwc.x - decoration->getLeftBorder (),
                      xwc.y - decoration->getTopBorder  () - decoration->getTitleHeight(),
                      xwc.width  + (frame->getWidth () - user->getWidth ()),
                      xwc.height + (frame->getHeight() - user->getHeight()));

    if (event->value_mask & CWStackMode) {
      if (window->isIconised())
        window->restore();

      CwmWMWindow *sibling = 0;

      if ((event->value_mask & CWSibling) && (event->above != None))
        sibling = CwmMachineInst->getWindowWMWindow(event->above);

      window->getFrameWindow()->setStackMode(event->detail, sibling);

      CwmWindowGroup window_group(window);

      window_group.restack();
    }
  }
  else {
    if (event->value_mask & CWX)
      CwmMachineInst->debugf("X = %d\n", event->x);
    if (event->value_mask & CWY)
      CwmMachineInst->debugf("Y = %d\n", event->y);
    if (event->value_mask & CWWidth)
      CwmMachineInst->debugf("Width = %d\n", event->width);
    if (event->value_mask & CWHeight)
      CwmMachineInst->debugf("Height = %d\n", event->height);
    if (event->value_mask & CWBorderWidth)
      CwmMachineInst->debugf("Border = %d\n", event->border_width);

    CwmMachineInst->debugf("Mask %x\n", event->value_mask);

    mask = CWX | CWY | CWWidth | CWHeight | CWBorderWidth;

    mask &= event->value_mask;

    CwmMachineInst->debugf("Mask %x\n", event->value_mask);

    xwc.x            = event->x;
    xwc.y            = event->y;
    xwc.width        = event->width;
    xwc.height       = event->height;
    xwc.border_width = event->border_width;

    if (mask != 0)
      CwmMachineInst->configureWindow(event->window, mask, &xwc);
  }

  return false;
}

bool
CwmEventMgr::
processConfigureNotify(XConfigureEvent *)
{
  return false;
}

bool
CwmEventMgr::
processReparentNotify(XReparentEvent *)
{
  return false;
}

bool
CwmEventMgr::
processEnterNotify(XEnterWindowEvent *event)
{
  last_event_time_ = event->time;

  Window xwin = event->window;

  XEvent event1;

  while (CwmMachineInst->checkWindowTypedEvent(xwin, EnterNotify, &event1))
    ;

  if (CwmMachineInst->checkWindowTypedEvent(xwin, LeaveNotify, &event1)) {
    while (CwmMachineInst->checkWindowTypedEvent(xwin, LeaveNotify, &event1))
      ;

    return false;
  }

  if (CwmResourceDataInst->getWindowPressRaise()) {
    CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

    if (window != 0) {
      CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

      if (window->isUser(xwindow))
        CwmMachineInst->focusEnter(window);
    }
  }

  return true;
}

bool
CwmEventMgr::
processLeaveNotify(XLeaveWindowEvent *event)
{
  last_event_time_ = event->time;

  Window xwin = event->window;

  XEvent event1;

  while (CwmMachineInst->checkWindowTypedEvent(xwin, LeaveNotify, &event1))
    ;

  if (CwmMachineInst->checkWindowTypedEvent(xwin, EnterNotify, &event1)) {
    while (CwmMachineInst->checkWindowTypedEvent(xwin, EnterNotify, &event1))
      ;

    return false;
  }

  if (CwmResourceDataInst->getWindowPressRaise()) {
    CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

    if (window != 0) {
      CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

      if (window->isUser(xwindow))
        CwmMachineInst->focusLeave(window);
    }
  }

  return true;
}

bool
CwmEventMgr::
processButtonPress(XButtonPressedEvent *event)
{
  last_event_time_ = event->time;

  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

  if (xwindow == 0)
    return false;

  xwindow->callCallbacks(CWM_CALLBACK_BUTTON_PRESS, event);

  if (event->window == multiclick_window_ &&
      event->button == (uint) multiclick_button_ &&
      (event->time - multiclick_time_) <=
      (uint) CwmResourceDataInst->getDoubleClickTime()) {
    multiclick_time_ = event->time;

    multiclick_count_++;
  }
  else {
    multiclick_window_ = event->window;
    multiclick_button_ = event->button;
    multiclick_time_   = event->time;
    multiclick_count_  = 1;
  }

  return true;
}

bool
CwmEventMgr::
processButtonRelease(XButtonReleasedEvent *event)
{
  last_event_time_ = event->time;

  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(multiclick_window_);

  if (xwindow == 0)
    return false;

  if      (multiclick_count_ == 1) {
    if      (multiclick_button_ == 1)
      xwindow->callCallbacks(CWM_CALLBACK_SINGLE_CLICK_1, 0);
    else if (multiclick_button_ == 2)
      xwindow->callCallbacks(CWM_CALLBACK_SINGLE_CLICK_2, 0);
    else if (multiclick_button_ == 3)
      xwindow->callCallbacks(CWM_CALLBACK_SINGLE_CLICK_3, 0);
    else
      CwmMachineInst->logf("Single Click of Button %d not supported\n", multiclick_button_);
  }
  else if (multiclick_count_ == 2) {
    if      (multiclick_button_ == 1)
      xwindow->callCallbacks(CWM_CALLBACK_DOUBLE_CLICK_1, 0);
    else if (multiclick_button_ == 2)
      xwindow->callCallbacks(CWM_CALLBACK_DOUBLE_CLICK_2, 0);
    else if (multiclick_button_ == 3)
      xwindow->callCallbacks(CWM_CALLBACK_DOUBLE_CLICK_3, 0);
    else
      CwmMachineInst->logf("Double Click of Button %d not supported\n", multiclick_button_);
  }

  xwindow->callCallbacks(CWM_CALLBACK_BUTTON_RELEASE, event);

  return true;
}

bool
CwmEventMgr::
processKeyPress(XKeyPressedEvent *event)
{
  last_event_time_ = event->time;

  return true;
}

bool
CwmEventMgr::
processKeyRelease(XKeyReleasedEvent *event)
{
  last_event_time_ = event->time;

  return true;
}

bool
CwmEventMgr::
processMotionNotify(XMotionEvent *event)
{
  last_event_time_ = event->time;

  if (CwmResourceDataInst->getWindowPressRaise()) {
    CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

    if (window != 0) {
      CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

      if (window->isUser(xwindow))
        CwmMachineInst->focusEnter(window);
    }
  }

  return true;
}

bool
CwmEventMgr::
processExpose(XExposeEvent *event)
{
  if (event->count != 0)
    return false;

  CwmScreen &screen = CwmMachineInst->getWindowScreen(event->window);

  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

  if (xwindow == 0)
    return false;

  flushExposeEvents(xwindow);

  CwmToolBar *toolbar = screen.getCurrentDesk()->getToolBar();

  if (toolbar != 0) {
    if (toolbar->processExpose(xwindow))
      return false;
  }

  CwmCmdIcon *cmdicon = CwmCmdIconMgrInst->lookup(*xwindow);

  if (cmdicon != 0) {
    cmdicon->redraw();

    return false;
  }

  CwmDeskMgr *desk_mgr = screen.getDeskMgr();

  CwmDesk *desk = desk_mgr->getCurrentDesk();

  CwmDeskIconMgr *desk_icon_mgr = desk->getDeskIconMgr();

  if (desk_icon_mgr != 0) {
    CwmDeskIcon *desk_icon = desk_icon_mgr->lookup(xwindow);

    if (desk_icon != 0) {
      desk_icon->redraw();

      return false;
    }
  }

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(xwindow);

  if (window == 0)
    return false;

  CwmDecoration *decoration = window->getDecoration();

  if (decoration->processExpose(event))
    return false;

  if (window->isFrame(xwindow))
    window->getFrame()->draw();

  return false;
}

bool
CwmEventMgr::
processNoExpose(XNoExposeEvent *)
{
  return false;
}

bool
CwmEventMgr::
processFocusIn(XFocusChangeEvent *event)
{
  XEvent event1;

  if (CwmMachineInst->checkWindowTypedEvent(event->window, FocusOut, &event1))
    return false;

  return false;
}

bool
CwmEventMgr::
processFocusOut(XFocusChangeEvent *)
{
  return false;
}

bool
CwmEventMgr::
processPropertyNotify(XPropertyEvent *event)
{
  last_event_time_ = event->time;

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  if (window == 0)
    return false;

  const CXAtom &atom = CwmMachineInst->getAtom(event->atom);

  CwmMachineInst->debugf("Property %s\n", atom.getName().c_str());

  CwmHints *hints = window->getHints();

  if      (CwmMachineInst->isWMClassAtom(atom))
    hints->readClassHint();
  else if (CwmMachineInst->isWMClientMachineAtom(atom))
    hints->readSessionHints();
  else if (CwmMachineInst->isWMCommandAtom(atom))
    hints->readSessionHints();
  else if (CwmMachineInst->isWMHintsAtom(atom))
    hints->readWMHints();
  else if (CwmMachineInst->isWMIconNameAtom(atom))
    hints->readWMIconName();
  else if (CwmMachineInst->isWMNameAtom(atom))
    hints->readWMName();
  else if (CwmMachineInst->isWMNormalHintsAtom(atom))
    hints->readWMSizeHints();
  else if (CwmMachineInst->isWMSizeHintsAtom(atom))
    hints->readWMSizeHints();
  else if (CwmMachineInst->isWMTransientForAtom(atom))
    hints->readTransientHint();
  else if (CwmMachineInst->isWMZoomHintsAtom(atom))
    hints->readWMSizeHints();
  else if (CwmMachineInst->isWMProtocolsAtom(atom))
    hints->readWMProtocols();
  else if (CwmMachineInst->isWMStateAtom(atom))
    ;
  else
    CwmMachineInst->debugf("Unhandled property %s\n", atom.getName().c_str());

  window->redraw();

  CwmToolBar *toolbar = window->getDesk()->getToolBar();

  toolbar->redraw();

  return false;
}

bool
CwmEventMgr::
processVisibilityNotify(XVisibilityEvent *event)
{
#ifdef NEVER
  if      (event->state == VisibilityFullyObscured)
    CwmMachineInst->log("VisibilityFullyObscured\n");
  else if (event->state == VisibilityPartiallyObscured)
    CwmMachineInst->log("VisibilityPartiallyObscured\n");
  else if (event->state == VisibilityUnobscured)
    CwmMachineInst->log("VisibilityUnobscured\n");
#else
  assert(event);
#endif

  return false;
}

bool
CwmEventMgr::
processDestroyNotify(XDestroyWindowEvent *event)
{
  CwmWMWindow *window = CwmMachineInst->getUserWindowWMWindow(event->window);

  if (window == 0)
    return false;

  if (CwmMachineInst->getDebug())
    window->print();

  CwmGrabServer grab;

  window->remove();

  return false;
}

bool
CwmEventMgr::
processColormapNotify(XColormapEvent *event)
{
  CwmWMWindow *window = CwmMachineInst->getUserWindowWMWindow(event->window);

  if (window == 0)
    return false;

  window->setColormap(event->colormap);

  return false;
}

bool
CwmEventMgr::
processClientMessage(XClientMessageEvent *event)
{
  if (event->window == CwmMachineInst->getRoot())
    CwmGnomeInst->processRootClientMessage(event);

  if (CwmMessageInst->processClientMessage(event))
    return true;

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  if (window == 0)
    return false;

  const CXAtom &atom = CwmMachineInst->getAtom(event->message_type);

  if (CwmMachineInst->isWMChangeStateAtom(atom)) {
    long state = event->data.l[0];

    if (state == NormalState) {
      if (window->isIconised())
        window->restore();
    }
    else {
      if (! window->isIconised())
        window->iconise();
    }
  }
  else
    CwmMachineInst->logf("Unhandled Client Message - Type %s\n", atom.getName().c_str());

  return false;
}

bool
CwmEventMgr::
processMappingNotify(XMappingEvent *event)
{
  XRefreshKeyboardMapping(event);

  return false;
}

Window
CwmEventMgr::
waitForButtonClick(CwmWindow *xwindow, int buttons)
{
  XEvent event;

  if (buttons == 0)
    buttons = CWM_LEFT_BUTTON | CWM_MIDDLE_BUTTON | CWM_RIGHT_BUTTON;

  while (true) {
    while (CwmMachineInst->checkTypedEvent(ButtonRelease, &event))
      ;

    CwmMachineInst->maskEvent(ButtonPressMask | KeyPress, &event);

    if (event.type == ButtonPress) {
      if ((event.xbutton.button == 1 && ! (buttons & CWM_LEFT_BUTTON  )) ||
          (event.xbutton.button == 2 && ! (buttons & CWM_MIDDLE_BUTTON)) ||
          (event.xbutton.button == 3 && ! (buttons & CWM_RIGHT_BUTTON )))
        continue;

      while (CwmMachineInst->checkTypedEvent(ButtonPress, &event))
        ;
    }
    else {
      if (CwmXEventInst->isEscapeKeyEvent(&event.xkey))
        return None;
    }

    break;
  }

  CwmScreen &screen = xwindow->getScreen();

  Window press_window =
    screen.getCoordWindow(event.xbutton.x_root, event.xbutton.y_root);

  while (true) {
    while (CwmMachineInst->checkTypedEvent(ButtonPress, &event))
      ;

    CwmMachineInst->maskEvent(ButtonReleaseMask | KeyPress, &event);

    if (event.type == ButtonPress) {
      if ((event.xbutton.button == 1 && ! (buttons & CWM_LEFT_BUTTON  )) ||
          (event.xbutton.button == 2 && ! (buttons & CWM_MIDDLE_BUTTON)) ||
          (event.xbutton.button == 3 && ! (buttons & CWM_RIGHT_BUTTON )))
        continue;

      while (CwmMachineInst->checkTypedEvent(ButtonRelease, &event))
        ;
    }
    else {
      if (CwmXEventInst->isEscapeKeyEvent(&event.xkey))
        return None;
    }

    break;
  }

  return press_window;
}

Window
CwmEventMgr::
waitForButtonPress(CwmWindow *xwindow, int buttons)
{
  XEvent event;

  if (buttons == 0)
    buttons = CWM_LEFT_BUTTON | CWM_MIDDLE_BUTTON | CWM_RIGHT_BUTTON;

  while (true) {
    while (CwmMachineInst->checkTypedEvent(ButtonRelease, &event))
      ;

    CwmMachineInst->maskEvent(ButtonPressMask | KeyPress, &event);

    if (event.type == ButtonPress) {
      if ((event.xbutton.button == 1 && ! (buttons & CWM_LEFT_BUTTON  )) ||
          (event.xbutton.button == 2 && ! (buttons & CWM_MIDDLE_BUTTON)) ||
          (event.xbutton.button == 3 && ! (buttons & CWM_RIGHT_BUTTON )))
        continue;

      while (CwmMachineInst->checkTypedEvent(ButtonPress, &event))
        ;
    }
    else {
      if (CwmXEventInst->isEscapeKeyEvent(&event.xkey))
        return None;
    }

    break;
  }

  CwmScreen &screen = xwindow->getScreen();

  Window press_window =
    screen.getCoordWindow(event.xbutton.x_root, event.xbutton.y_root);

  return press_window;
}

Window
CwmEventMgr::
waitForButtonRelease(CwmWindow *xwindow, int buttons)
{
  XEvent event;

  if (buttons == 0)
    buttons = CWM_LEFT_BUTTON | CWM_MIDDLE_BUTTON | CWM_RIGHT_BUTTON;

  while (true) {
    while (CwmMachineInst->checkTypedEvent(ButtonPress, &event))
      ;

    CwmMachineInst->maskEvent(ButtonReleaseMask, &event);

    if ((event.xbutton.button == 1 && ! (buttons & CWM_LEFT_BUTTON  )) ||
        (event.xbutton.button == 2 && ! (buttons & CWM_MIDDLE_BUTTON)) ||
        (event.xbutton.button == 3 && ! (buttons & CWM_RIGHT_BUTTON )))
      continue;

    while (CwmMachineInst->checkTypedEvent(ButtonRelease, &event))
      ;

    break;
  }

  CwmScreen &screen = xwindow->getScreen();

  Window release_window =
    screen.getCoordWindow(event.xbutton.x_root, event.xbutton.y_root);

  return release_window;
}

Window
CwmEventMgr::
waitForKeyRelease(CwmWindow *xwindow)
{
  CwmScreen &screen = xwindow->getScreen();

  return waitForKeyRelease(screen);
}

Window
CwmEventMgr::
waitForKeyRelease(CwmScreen &screen)
{
  XEvent event;

  while (true) {
    while (CwmMachineInst->checkTypedEvent(KeyPress, &event))
      ;

    CwmMachineInst->maskEvent(KeyReleaseMask, &event);

    while (CwmMachineInst->checkTypedEvent(KeyRelease, &event))
      ;

    break;
  }

  Window release_window =
    screen.getCoordWindow(event.xkey.x_root, event.xkey.y_root);

  return release_window;
}

void
CwmEventMgr::
flushExposeEvents(CwmWindow *xwindow)
{
  Window xwin = xwindow->getXWin();

  CwmMachineInst->flushWindowEvents(xwin, Expose);
}

void
CwmEventMgr::
flushEnterLeaveEvents(CwmWindow *xwindow)
{
  Window xwin = xwindow->getXWin();

  int count = 0;

  do {
    count = CwmMachineInst->flushWindowEvents(xwin, EnterNotify) +
            CwmMachineInst->flushWindowEvents(xwin, LeaveNotify);
  }
  while (count > 0);
}

bool
CwmEventMgr::
isDestroyPending(Window xwin)
{
  if (CwmMachineInst->flushWindowEvents(xwin, DestroyNotify))
    return true;

  return false;
}

CwmWMWindow *
CwmEventMgr::
selectWindow(CwmScreen &screen)
{
  uint event_mask = ButtonPressMask | ButtonReleaseMask;

  if (! screen.getRoot()->grab(event_mask, CWM_CURSOR_QUERY))
    return 0;

  Window selected_window =
    waitForButtonClick(screen.getRoot(), CWM_LEFT_BUTTON);

  screen.getRoot()->ungrab();

  Window parent = CwmMachineInst->getWindowParent(selected_window);

  while (parent != None) {
    selected_window = parent;

    parent = CwmMachineInst->getWindowParent(selected_window);
  }

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(selected_window);

  return window;
}
##concat##CwmFocusMgr.cpp
#include <CwmI.h>
#include <CXtTimer.h>

class CwmFocusMgrTimer : CXtTimer {
 private:
  CwmFocusMgr *mgr_;
  CwmWMWindow *window_;

 public:
  CwmFocusMgrTimer(CwmFocusMgr *mgr, CwmWMWindow *window);

  void timeOut();
};

CwmFocusMgr::
CwmFocusMgr()
{
  focus_window_        = 0;
  auto_raise_timer_    = 0;
  user_window_         = 0;
  top_window_          = 0;
  grab_buttons_window_ = 0;
}

CwmFocusMgr::
~CwmFocusMgr()
{
  delete auto_raise_timer_;
}

void
CwmFocusMgr::
focusNext(CwmScreen &screen)
{
  if (! CwmResourceDataInst->getClickToFocus())
    return;

  Window *windows;
  int     num_windows;

  if (! screen.getWindows(&windows, &num_windows))
    return;

  int i;

  CwmWMWindow *window = 0;

  for (i = 0; i < num_windows; ++i) {
    window = CwmMachineInst->getWindowWMWindow(windows[i]);

    if (window == 0)
      continue;

    if (isFocusWindow(window))
      break;
  }

  ++i;

  for ( ; i < num_windows; ++i) {
    window = CwmMachineInst->getWindowWMWindow(windows[i]);

    if (isValidWindow(window, windows[i]))
      break;
  }

  if (i >= num_windows) {
    for (i = 0; i < num_windows; ++i) {
      window = CwmMachineInst->getWindowWMWindow(windows[i]);

      if (isValidWindow(window, windows[i]))
        break;
    }

    if (i >= num_windows)
      return;
  }

  if (windows != 0)
    XFree((char *) windows);

  setFocusWindow(window);
}

void
CwmFocusMgr::
focusPrev(CwmScreen &screen)
{
  if (! CwmResourceDataInst->getClickToFocus())
    return;

  Window *windows;
  int     num_windows;

  if (! screen.getWindows(&windows, &num_windows))
    return;

  int i;

  CwmWMWindow *window = 0;

  for (i = num_windows - 1; i >= 0; i--) {
    window = CwmMachineInst->getWindowWMWindow(windows[i]);

    if (window == 0)
      continue;

    if (! isFocusWindow(window))
      break;
  }

  i--;

  for ( ; i >= 0; i--) {
    window = CwmMachineInst->getWindowWMWindow(windows[i]);

    if (isValidWindow(window, windows[i]))
      break;
  }

  if (i < 0) {
    for (i = num_windows - 1; i >= 0; i--) {
      window = CwmMachineInst->getWindowWMWindow(windows[i]);

      if (isValidWindow(window, windows[i]))
        break;
    }

    if (i < 0)
      return;
  }

  if (windows != 0)
    XFree((char *) windows);

  setFocusWindow(window);
}

void
CwmFocusMgr::
setFocusWindow(CwmWMWindow *window)
{
  if (isFocusWindow(window))
    return;

  resetFocusWindow();

  if (window == 0)
    return;

  focus_window_ = window;

  if (! window->isIconised()) {
    if (CwmResourceDataInst->getClickToFocus())
      ungrabButtons(window);

    if (CwmResourceDataInst->getFocusGrabKeys())
      CwmWindowEventFunctionMgrInst->grabEventKeys(window);

    CwmWindow *xwindow = window->getUserWindow();

    if (xwindow != 0) {
      setInputFocus(xwindow);

      CwmScreen &screen = window->getScreen();

      screen.installColormap(window);

      if (window->getFocusAutoRaise())
        auto_raise_timer_ = new CwmFocusMgrTimer(this, window);
    }
  }

  window->focusIn();
}

bool
CwmFocusMgr::
isFocusWindow(CwmWMWindow *window)
{
  return (window == focus_window_);
}

void
CwmFocusMgr::
resetFocusWindow()
{
  delete auto_raise_timer_;

  auto_raise_timer_ = 0;

  CwmWMWindow *window = focus_window_;

  focus_window_ = 0;

  if (window == 0) {
    resetInputFocus();
    return;
  }

  CwmScreen &screen = window->getScreen();

  if (! window->isIconised()) {
    window->focusOut();

    if (CwmResourceDataInst->getClickToFocus())
      grabButtons(window);

    if (CwmResourceDataInst->getFocusGrabKeys())
      CwmWindowEventFunctionMgrInst->ungrabEventKeys(window);

    screen.uninstallColormap();
  }

  CwmWindow *xwindow = screen.getRoot();

  setInputFocus(xwindow);
}

void
CwmFocusMgr::
grabButtons(CwmWMWindow *window)
{
  if (window == grab_buttons_window_) {
    CwmMachineInst->log("grabButtons on window with grab\n");
    return;
  }

  if (grab_buttons_window_ != 0)
    grab_buttons_window_->getFrameWindow()->ungrabButtonPress();

  grab_buttons_window_ = window;

  if (grab_buttons_window_ != 0)
    grab_buttons_window_->getFrameWindow()->grabButtonPress();
}

void
CwmFocusMgr::
ungrabButtons(CwmWMWindow *window)
{
  if (window != grab_buttons_window_) {
    CwmMachineInst->log("ungrabButtons on window without grab\n");
    return;
  }

  if (grab_buttons_window_ != 0)
    grab_buttons_window_->getFrameWindow()->ungrabButtonPress();

  grab_buttons_window_ = 0;
}

void
CwmFocusMgr::
ungrabButtonsIfWindow(CwmWMWindow *window)
{
  if (window == grab_buttons_window_)
    ungrabButtons(window);
}

void
CwmFocusMgr::
grabButton1(CwmWMWindow *window)
{
  window->getFrameWindow()->grabButton1Press();
}

void
CwmFocusMgr::
ungrabButton1(CwmWMWindow *window)
{
  window->getFrameWindow()->ungrabButton1Press();
}

bool
CwmFocusMgr::
isValidWindow(CwmWMWindow *window, Window xwin)
{
  if (window == 0)
    return false;

  if (! window->isIconised()) {
    if (xwin != window->getFrameWindow()->getXWin())
      return false;
  }
  else {
    if (CwmResourceDataInst->getNoIconFocus())
      return false;

    CwmScreen &screen = window->getScreen();

    CwmDeskMgr *desk_mgr = screen.getDeskMgr();

    CwmDesk *desk = desk_mgr->getCurrentDesk();

    CwmDeskIconMgr *desk_icon_mgr = desk->getDeskIconMgr();

    if (desk_icon_mgr == 0)
      return false;

    CwmDeskIcon *desk_icon = desk_icon_mgr->lookup(xwin);

    if (desk_icon == 0)
      return false;
  }

  return true;
}

void
CwmFocusMgr::
setInputFocus(CwmWindow *xwindow)
{
  if (! xwindow->getMapped()) {
    resetInputFocus();

    return;
  }

  CwmMachineInst->setInputFocus(xwindow->getXWin());
}

void
CwmFocusMgr::
resetInputFocus()
{
  CwmMachineInst->resetInputFocus();
}

void
CwmFocusMgr::
enterUserWindow(CwmWMWindow *window)
{
  if (window == user_window_)
    return;

  leaveUserWindow(window);

  if (window->getScreen().isTop(window)) {
    top_window_ = 0;
    return;
  }

  user_window_ = window;

  grabButtons(user_window_);

  top_window_ = 0;
}

void
CwmFocusMgr::
leaveUserWindow(CwmWMWindow *)
{
  if (user_window_ == 0)
    return;

  ungrabButtons(user_window_);

  user_window_ = 0;
}

bool
CwmFocusMgr::
isUserWindow(CwmWMWindow *window)
{
  return (window == user_window_);
}

CwmFocusMgrTimer::
CwmFocusMgrTimer(CwmFocusMgr *mgr, CwmWMWindow *window) :
 CXtTimer(CwmResourceDataInst->getAutoRaiseDelay(), CTIMER_FLAGS_NO_DELETE),
 mgr_(mgr), window_(window)
{
}

void
CwmFocusMgrTimer::
timeOut()
{
  window_->raise();
}
##concat##CwmFontMgr.cpp
#include <CwmI.h>
#include <CXFont.h>
#include <CXrtFont.h>
#include <CFontMgr.h>

CwmFontMgr::
CwmFontMgr(CwmScreen &screen) :
 screen_(screen)
{
}

CwmFontMgr::
~CwmFontMgr()
{
  std::for_each(fonts_.begin(), fonts_.end(), CDeletePointer());
}

CwmFont *
CwmFontMgr::
getFont(const std::string &name)
{
  FontList::const_iterator pfont1 = fonts_.begin();
  FontList::const_iterator pfont2 = fonts_.end  ();

  for ( ; pfont1 != pfont2; ++pfont1)
    if (CStrUtil::casecmp((*pfont1)->getName(), name) == 0)
      return *pfont1;

  //------

  CwmFont *font = new CwmFont(screen_, name);

  fonts_.push_back(font);

  //------

  return font;
}

CwmFont::
CwmFont(CwmScreen &, const std::string &name)
{
  int        size;
  std::string     name1;
  CFontStyle style;
  int        angle;

  parseName(name, &name1, &style, &size, &angle);

  cxfont_ = CFontMgrInst->lookupFont(name1, style, size, angle);
}

CwmFont::
~CwmFont()
{
}

string
CwmFont::
getName() const
{
  return cxfont_->getFamily();
}

int
CwmFont::
getHeight() const
{
  return cxfont_->getICharHeight();
}

int
CwmFont::
getAscent() const
{
  return cxfont_->getICharAscent();
}

int
CwmFont::
getDescent() const
{
  return cxfont_->getICharDescent();
}

void
CwmFont::
getTextSize(const std::string &text, int *width, int *height)
{
  *width  = cxfont_->getIStringWidth(text);
  *height = cxfont_->getICharHeight();
}

void
CwmFont::
drawString(CwmWindow *xwindow, CwmGraphics *graphics, int x, int y, const std::string &text)
{
  CXFont *xfont = cxfont_.cast<CXFont>();

  CXrtFont *xrt_font = xfont->getXrtFont();

  xrt_font->draw(xwindow->getXWin(), graphics->getGC(), x, y, text);
}

void
CwmFont::
drawString(CwmXPixmap *xpixmap, CwmGraphics *graphics, int x, int y, const std::string &text)
{
  CXFont *xfont = cxfont_.cast<CXFont>();

  CXrtFont *xrt_font = xfont->getXrtFont();

  xrt_font->draw(xpixmap->getXPixmap(), graphics->getGC(), x, y, text);
}

void
CwmFont::
parseName(const std::string &name, std::string *name1, CFontStyle *style, int *size, int *angle)
{
  vector<string> words;

  CStrUtil::addFields(name, words, "-");

  *name1 = "courier";
  *size  = 14;
  *angle = 0;

  if (words.size() > 0)
    *name1 = words[0];

  std::string style1 = "normal";

  if (words.size() > 1)
    style1 = words[1];

  *style = parseStyle(style1);

  if (words.size() > 2)
    if (CStrUtil::isInteger(words[2]))
      *size = CStrUtil::toInteger(words[2]);

  if (words.size() > 3) {
    if (CStrUtil::isInteger(words[3]))
      *angle = CStrUtil::toInteger(words[3]);
  }
}

CFontStyle
CwmFont::
parseStyle(const std::string &style)
{
  return CFont::stringToFontStyle(style);
}
##concat##CwmFrameWindow.cpp
#include <CwmI.h>

static const uint event_mask =
  ButtonPressMask | ButtonReleaseMask |
  EnterWindowMask | LeaveWindowMask   |
  KeyPressMask    | ExposureMask      |
  SubstructureRedirectMask;

static const int border = 2;

CwmFrameWindow::
CwmFrameWindow(CwmWMWindow *window1) :
 window(window1), xwindow(None), positioned(false)
{
  CwmScreen &screen = window->getScreen();

  xwindow = new CwmWindow(screen, screen.getRoot(), 0, 0, 1, 1,
                          event_mask, CWM_CURSOR_TITLE);

  graphics = window->getGraphics();

  xwindow->setBackground(graphics);
}

CwmFrameWindow::
~CwmFrameWindow()
{
  delete xwindow;
}

void
CwmFrameWindow::
map()
{
  xwindow->map();
}

void
CwmFrameWindow::
unmap()
{
  xwindow->unmap();
}

void
CwmFrameWindow::
position()
{
  CwmUserWindow *user = window->getUser();

  if (user == 0)
    return;

  CwmDecoration *decoration = window->getDecoration();

  if (! window->getRolledUp()) {
    int x      = user->getX() -
                 decoration->getLeftBorder();
    int y      = user->getY() -
                 decoration->getTopBorder() -
                 decoration->getTitleHeight();
    int width  = user->getWidth () +
                 decoration->getLeftBorder() +
                 decoration->getRightBorder();
    int height = user->getHeight() +
                 decoration->getTopBorder   () +
                 decoration->getBottomBorder() +
                 decoration->getTitleHeight ();

    CwmScreen &screen = window->getScreen();

    if (! positioned) {
      if (CwmResourceDataInst->getClientAutoPlace() &&
          user->getX() == -1 && user->getY() == -1)
        screen.getDefaultPos(width, height, &x, &y);

      positioned = true;
    }

    //------

    if (width > screen.getWidth())
      width = screen.getWidth();

    if (height > screen.getHeight())
      height = screen.getHeight();

    if (x + width > screen.getWidth())
      x = screen.getWidth() - width;

    if (y + height > screen.getHeight())
      y = screen.getHeight() - height;

    if (x < 0)
      x = 0;

    if (y < 0)
      y = 0;

    //------

    xwindow->moveResize(x, y, width, height);

    //------

    int user_x = x + decoration->getLeftBorder ();
    int user_y = y + decoration->getTopBorder  () +
                     decoration->getTitleHeight();

    int save_width  = user->getWidth ();
    int save_height = user->getHeight();

    int user_width  = width  -
                      decoration->getLeftBorder () -
                      decoration->getRightBorder();
    int user_height = height -
                      decoration->getTopBorder   () -
                      decoration->getBottomBorder() -
                      decoration->getTitleHeight ();

    user->fixSize(&user_width, &user_height);

    if (width != save_width || height != save_height)
      user->moveResize(user_x, user_y, user_width, user_height);
  }
  else {
    int x      = user->getX();
    int y      = user->getY() -
                 decoration->getTitleHeight();
    int width  = user->getWidth();
    int height = decoration->getTitleHeight();

    xwindow->moveResize(x, y, width, height);
  }
}

void
CwmFrameWindow::
draw()
{
  xwindow->setBackground(graphics);

  CwmEventMgrInst->flushExposeEvents(xwindow);

  xwindow->clear();

  graphics->drawButtonOut(xwindow,
                          0, 0,
                          getWidth(), getHeight(),
                          2);

  graphics->drawButtonIn(xwindow,
                         border - 1, border - 1,
                         getWidth () - 2*border + 2,
                         getHeight() - 2*border + 2,
                         1);
}

void
CwmFrameWindow::
move(int x, int y)
{
  xwindow->move(x, y);

  CwmUserWindow *user = window->getUser();

  if (user == 0)
    return;

  CwmDecoration *decoration = window->getDecoration();

  int user_x      = x + decoration->getLeftBorder ();
  int user_y      = y + decoration->getTopBorder  () +
                        decoration->getTitleHeight();
  int user_width  = user->getWidth();
  int user_height = user->getHeight();

  user->moveResize(user_x, user_y, user_width, user_height);
}

void
CwmFrameWindow::
moveResize(int x, int y, int width, int height)
{
  xwindow->moveResize(x, y, width, height);

  CwmUserWindow *user = window->getUser();

  if (user == 0)
    return;

  CwmDecoration *decoration = window->getDecoration();

  int user_x      = x + decoration->getLeftBorder();
  int user_y      = y + decoration->getTopBorder () +
                        decoration->getTitleHeight();
  int user_width  = width  -
                    decoration->getLeftBorder () -
                    decoration->getRightBorder();
  int user_height = height -
                    decoration->getTopBorder   () -
                    decoration->getBottomBorder() -
                    decoration->getTitleHeight ();

  user->fixSize(&user_width, &user_height);

  user->moveResize(user_x, user_y, user_width, user_height);

  window->redecorate();
}

void
CwmFrameWindow::
minimize()
{
  CwmUserWindow *user = window->getUser();

  if (user == 0)
    return;

  CwmDecoration *decoration = window->getDecoration();

  int user_x      = user->getX();
  int user_y      = user->getY();
  int user_width  = window->getMinWidthHint();
  int user_height = window->getMinHeightHint();

  user->fixSize(&user_width, &user_height);

  int frame_x      = user_x -
                     decoration->getLeftBorder ();
  int frame_y      = user_y -
                     decoration->getTopBorder  () -
                     decoration->getTitleHeight();
  int frame_width  = user_width +
                     decoration->getLeftBorder () +
                     decoration->getRightBorder();
  int frame_height = user_height +
                     decoration->getTopBorder   () +
                     decoration->getBottomBorder() +
                     decoration->getTitleHeight ();

  window->moveResize(frame_x, frame_y, frame_width, frame_height);

  window->redecorate();
/*
  xwindow->moveResize(frame_x, frame_y, frame_width, frame_height);

  user->moveResize(user_x, user_y, user_width, user_height);

  window->redecorate();
*/
}

void
CwmFrameWindow::
maximize()
{
  CwmUserWindow *user = window->getUser();

  if (user == 0)
    return;

  CwmDecoration *decoration = window->getDecoration();

  CwmScreen &screen = window->getScreen();

  int user_x      = decoration->getLeftBorder ();
  int user_y      = decoration->getTopBorder  () +
                    decoration->getTitleHeight();
  int user_width  = screen.getWidth() -
                    decoration->getLeftBorder () -
                    decoration->getRightBorder();
  int user_height = screen.getHeight() -
                    decoration->getTopBorder   () -
                    decoration->getBottomBorder() -
                    decoration->getTitleHeight ();

  if (user_width > window->getMaxWidthHint())
    user_width = window->getMaxWidthHint();

  if (user_height > window->getMaxHeightHint())
    user_height = window->getMaxHeightHint();

  user->fixSize(&user_width, &user_height);

  int frame_x      = user_x -
                     decoration->getLeftBorder ();
  int frame_y      = user_y -
                     decoration->getTopBorder  () -
                     decoration->getTitleHeight();
  int frame_width  = user_width +
                     decoration->getLeftBorder () +
                     decoration->getRightBorder();
  int frame_height = user_height +
                     decoration->getTopBorder   () +
                     decoration->getBottomBorder() +
                     decoration->getTitleHeight ();

  window->moveResize(frame_x, frame_y, frame_width, frame_height);

  window->redecorate();
/*
  xwindow->moveResize(frame_x, frame_y, frame_width, frame_height);

  user->moveResize(user_x, user_y, user_width, user_height);

  window->redecorate();
*/
}

int
CwmFrameWindow::
getX() const
{
  return xwindow->getX();
}

int
CwmFrameWindow::
getY() const
{
  return xwindow->getY();
}

int
CwmFrameWindow::
getWidth() const
{
  return xwindow->getWidth();
}

int
CwmFrameWindow::
getHeight() const
{
  return xwindow->getHeight();
}
##concat##CwmFunctionDef.cpp
#include <CwmI.h>

CwmFunctionDef::
CwmFunctionDef(const std::string &name)
{
  screen_      = 0;
  window_      = 0;
  icon_        = 0;
  root_proc_   = 0;
  window_proc_ = 0;
  icon_proc_   = 0;

  if (name[0] != 'f' || name[1] != '.') {
    CwmMachineInst->logf("Unrecognised function def %s must start with 'f.'\n", name.c_str());
    return;
  }

  std::string name1 = name.substr(2);

  if      (CStrUtil::casecmp(name1, "move") == 0) {
    root_proc_   = &CwmScreenMenu::moveProc;
    window_proc_ = &CwmWindowMenu::moveProc;
    icon_proc_   = &CwmDeskIcon::moveProc;
  }
  else if (CStrUtil::casecmp(name1, "resize") == 0) {
    root_proc_   = &CwmScreenMenu::resizeProc;
    window_proc_ = &CwmWindowMenu::resizeProc;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "resize_to") == 0) {
    root_proc_   = 0;
    window_proc_ = &CwmWindowMenu::resizeToSizeProc;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "iconise") == 0 ||
           CStrUtil::casecmp(name1, "iconize") == 0) {
    root_proc_   = &CwmScreenMenu::iconiseProc;
    window_proc_ = &CwmWindowMenu::iconiseProc;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "minimize") == 0) {
    root_proc_   = &CwmScreenMenu::minimizeProc;
    window_proc_ = &CwmWindowMenu::minimizeProc;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "maximize") == 0) {
    root_proc_   = &CwmScreenMenu::maximizeProc;
    window_proc_ = &CwmWindowMenu::minimizeProc;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "restore") == 0) {
    root_proc_   = &CwmScreenMenu::restoreProc;
    window_proc_ = 0;
    icon_proc_   = &CwmDeskIcon::restoreProc;
  }
  else if (CStrUtil::casecmp(name1, "raise") == 0) {
    root_proc_   = &CwmScreenMenu::raiseProc;
    window_proc_ = &CwmWindowMenu::raiseProc;
    icon_proc_   = &CwmDeskIcon::raiseProc;
  }
  else if (CStrUtil::casecmp(name1, "lower") == 0) {
    root_proc_   = &CwmScreenMenu::lowerProc;
    window_proc_ = &CwmWindowMenu::lowerProc;
    icon_proc_   = &CwmDeskIcon::lowerProc;
  }
  else if (CStrUtil::casecmp(name1, "circle_up") == 0) {
    root_proc_   = &CwmScreenMenu::circulateUpProc;
    window_proc_ = &CwmWindowMenu::circulateUpProc;
    icon_proc_   = &CwmDeskIcon::circulateUpProc;
  }
  else if (CStrUtil::casecmp(name1, "circle_down") == 0) {
    root_proc_   = &CwmScreenMenu::circulateDownProc;
    window_proc_ = &CwmWindowMenu::circulateDownProc;
    icon_proc_   = &CwmDeskIcon::circulateDownProc;
  }
  else if (CStrUtil::casecmp(name1, "focus_next") == 0) {
    root_proc_   = &CwmScreenMenu::focusNextProc;
    window_proc_ = &CwmWindowMenu::focusNextProc;
    icon_proc_   = &CwmDeskIcon::focusNextProc;
  }
  else if (CStrUtil::casecmp(name1, "focus_prev") == 0) {
    root_proc_   = &CwmScreenMenu::focusPrevProc;
    window_proc_ = &CwmWindowMenu::focusPrevProc;
    icon_proc_   = &CwmDeskIcon::focusPrevProc;
  }
  else if (CStrUtil::casecmp(name1, "select_next") == 0) {
    root_proc_   = &CwmScreenMenu::selectNextProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "select_prev") == 0) {
    root_proc_   = &CwmScreenMenu::selectPrevProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "roll_up") == 0) {
    root_proc_   = &CwmScreenMenu::rollUpProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "roll_down") == 0) {
    root_proc_   = &CwmScreenMenu::rollDownProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "close") == 0) {
    root_proc_   = &CwmScreenMenu::closeProc;
    window_proc_ = &CwmWindowMenu::closeProc;
    icon_proc_   = &CwmDeskIcon::closeProc;
  }
  else if (CStrUtil::casecmp(name1, "menu") == 0) {
    root_proc_   = &CwmScreenMenu::processNamedMenuProc;
    window_proc_ = &CwmWindowMenu::processNamedMenuProc;
    icon_proc_   = &CwmDeskIcon::namedMenuProc;
  }
  else if (CStrUtil::casecmp(name1, "window_menu") == 0) {
    root_proc_   = 0;
    window_proc_ = &CwmWMWindow::processWindowMenu;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "paste") == 0) {
    root_proc_   = 0;
    window_proc_ = &CwmWindowMenu::pasteProc;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "exec") == 0) {
    root_proc_   = &CwmScreenMenu::runCommandProc;
    window_proc_ = &CwmWindowMenu::runCommandProc;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "execx") == 0) {
    root_proc_   = &CwmScreenMenu::runXCommandProc;
    window_proc_ = &CwmWindowMenu::runXCommandProc;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "setroot") == 0) {
    root_proc_   = &CwmScreenMenu::setRootImageProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "toolbar") == 0) {
    root_proc_   = &CwmScreenMenu::toggleDisplayedProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "refresh") == 0) {
    root_proc_   = &CwmScreenMenu::refreshCwmProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "restart") == 0) {
    root_proc_   = &CwmScreenMenu::restartCwmProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "quit") == 0) {
    root_proc_   = &CwmScreenMenu::quitCwmProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "change_desk") == 0) {
    root_proc_   = &CwmScreenMenu::changeDeskProc;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else if (CStrUtil::casecmp(name1, "null") == 0) {
    root_proc_   = 0;
    window_proc_ = 0;
    icon_proc_   = 0;
  }
  else {
    CwmMachineInst->logf("Unrecognised function def %s\n", name1.c_str());
  }
}

CwmFunctionDef::
~CwmFunctionDef()
{
}

void
CwmFunctionDef::
process()
{
  if     (window_ != 0) {
    if (window_proc_ != 0)
      (*window_proc_)(window_, data_);
    else
      CwmMachineInst->log("Invalid Function for Window\n");
  }
  else if (icon_ != 0) {
    if (icon_proc_ != 0)
      (*icon_proc_)(icon_, data_);
    else
      CwmMachineInst->log("Invalid Function for Icon\n");
  }
  else if (screen_ != 0) {
    if (root_proc_ != 0)
      (*root_proc_)(*screen_, data_);
    else
      CwmMachineInst->log("Invalid Function for Root\n");
  }
}

void
CwmFunctionDef::
processWindow(CwmWMWindow *window, CwmData data)
{
  if (window_proc_ != 0)
    (*window_proc_)(window, data);
  else
    CwmMachineInst->log("Invalid Function for Window\n");
}

void
CwmFunctionDef::
processRoot(CwmScreen &screen, CwmData data)
{
  if (root_proc_ != 0)
    (*root_proc_)(screen, data);
  else
    CwmMachineInst->log("Invalid Function for Root\n");
}

void
CwmFunctionDef::
processProc(CwmData data)
{
  CwmFunctionDef *function_def = (CwmFunctionDef *) data;

  function_def->process();
}

void
CwmFunctionDef::
setData(CwmData data)
{
  data_ = data;
}

void
CwmFunctionDef::
setObjects(CwmScreen *screen, CwmWMWindow *window, CwmDeskIcon *icon)
{
  screen_ = screen; window_ = window; icon_ = icon;
}
##concat##CwmGnome.cpp
#include <CwmI.h>
#include <CXAtom.h>

CwmGnome *
CwmGnome::
getInstance()
{
  static CwmGnome *instance;

  if (! instance)
    instance = new CwmGnome();

  return instance;
}

void
CwmGnome::
init(CwmScreen &screen)
{
  createGnomeWindow(screen);

  createSupportedProperties(screen);

  setNumDesktops(screen);
  setCurrentDesktop(screen);
  setDesktopNames(screen);

  setListOfManagedClients(screen);
}

void
CwmGnome::
createGnomeWindow(CwmScreen &screen)
{
  Window root_xwin = screen.getRoot()->getXWin();

  const CXAtom &atom = CwmMachineInst->getAtom("_WIN_SUPPORTING_WM_CHECK");

  Window xwin =
    CwmMachineInst->createWindow(None, -200, -200, 5, 5, 0, 0, 0);

  CwmMachineInst->setWindowProperty(root_xwin, atom, xwin);
  CwmMachineInst->setWindowProperty(xwin     , atom, xwin);
}

void
CwmGnome::
createSupportedProperties(CwmScreen &screen)
{
  Window root_xwin = screen.getRoot()->getXWin();

  const CXAtom &atom = CwmMachineInst->getAtom("_WIN_PROTOCOLS");

  const CXAtom *atoms[10];

  atoms[0] = &CwmMachineInst->getAtom("_WIN_WORKSPACE"      );
  atoms[1] = &CwmMachineInst->getAtom("_WIN_WORKSPACE_COUNT");
  atoms[2] = &CwmMachineInst->getAtom("_WIN_WORKSPACE_NAMES");
  atoms[3] = &CwmMachineInst->getAtom("_WIN_CLIENT_LIST"    );
  atoms[4] = &CwmMachineInst->getAtom("_WIN_LAYER"          );
  atoms[5] = &CwmMachineInst->getAtom("_WIN_STATE"          );

  CwmMachineInst->setAtomArrayProperty(root_xwin, atom, atoms, 6);
}

void
CwmGnome::
setListOfManagedClients(CwmScreen &screen)
{
  Window root_xwin = screen.getRoot()->getXWin();

  const CXAtom &atom = CwmMachineInst->getAtom("_WIN_CLIENT_LIST");

  CwmDesk *desk = screen.getCurrentDesk();

  CwmDesk::WMWindowList windows = desk->getWindows();

  Window *xwins = new Window [windows.size()];

  CwmDesk::WMWindowList::const_iterator pwindow1 = windows.begin();
  CwmDesk::WMWindowList::const_iterator pwindow2 = windows.end  ();

  int num_xwins = 0;

  for ( ; pwindow1 != pwindow2; ++pwindow1)
    xwins[num_xwins++] = (*pwindow1)->getXWin();

  CwmMachineInst->setWindowArrayProperty(root_xwin, atom, xwins, num_xwins);

  delete [] xwins;
}

void
CwmGnome::
setNumDesktops(CwmScreen &screen)
{
  Window root_xwin = screen.getRoot()->getXWin();

  const CXAtom &atom = CwmMachineInst->getAtom("_WIN_WORKSPACE_COUNT");

  int num_desks = screen.getNumDesks();

  CwmMachineInst->setIntegerProperty(root_xwin, atom, num_desks);
}

void
CwmGnome::
setCurrentDesktop(CwmScreen &screen)
{
  Window root_xwin = screen.getRoot()->getXWin();

  CwmDesk *desk = screen.getCurrentDesk();

  const CXAtom &atom = CwmMachineInst->getAtom("_WIN_WORKSPACE");

  int desk_num = desk->getNum();

  CwmMachineInst->setIntegerProperty(root_xwin, atom, desk_num);
}

void
CwmGnome::
setDesktopNames(CwmScreen &screen)
{
  Window root_xwin = screen.getRoot()->getXWin();

  const CXAtom &atom = CwmMachineInst->getAtom("_WIN_WORKSPACE_NAMES");

  int num_names = screen.getNumDesks();

  char **names = new char * [num_names];

  for (int i = 0; i < num_names; i++) {
    std::string name = screen.getDesk(i)->getName();

    names[i] = strdup(name.c_str());
  }

  CwmMachineInst->setStringListProperty(root_xwin, atom, names, num_names);

  int num_desks = screen.getNumDesks();

  for (int i = 0; i < num_desks; i++)
    free(names[i]);

  delete [] names;
}

void
CwmGnome::
processRootClientMessage(XClientMessageEvent *event)
{
/*
  const CXAtom &win_layer_atom = CwmMachineInst->getAtom("_WIN_LAYER");
  const CXAtom &win_state_atom = CwmMachineInst->getAtom("_WIN_STATE");
*/

  const CXAtom &atom = CwmMachineInst->getAtom(event->message_type);

  CwmMachineInst->logf("processRootClientMessage %\n",
                       atom.getName().c_str());
}

void
CwmGnome::
setState(CwmWMWindow &window)
{
  const CXAtom &atom = CwmMachineInst->getAtom("_WIN_STATE");

  CwmMachineInst->setIntegerProperty(window.getXWin(), atom, 0);
}

void
CwmGnome::
setDesktop(CwmWMWindow &window)
{
  int desk_num = window.getDeskNum();

  const CXAtom &atom = CwmMachineInst->getAtom("_WIN_WORKSPACE");

  CwmMachineInst->setIntegerProperty(window.getXWin(), atom, desk_num);
}
##concat##CwmGrab.cpp
#include <CwmI.h>

CwmGrabServer::
CwmGrabServer()
{
  CwmMachineInst->grabServer();
}

CwmGrabServer::
~CwmGrabServer()
{
  CwmMachineInst->ungrabServer();
}
##concat##CwmGraphics.cpp
#include <CwmI.h>

CwmGraphics::
CwmGraphics(CwmScreen &screen, CwmFont *font, CwmColor *color, bool is_xor) :
 screen_(screen), font_(font), color_(color)
{
  if (! is_xor)
    gc_ = screen_.createGC(color_);
  else
    gc_ = screen_.createXorGC(color_);

  init();
}

CwmGraphics::
CwmGraphics(CwmWMWindow &window, CwmFont *font, CwmColor *color, bool is_xor) :
 screen_(window.getScreen()), font_(font), color_(color)
{
  if (! is_xor)
    gc_ = screen_.createGC(color_);
  else
    gc_ = screen_.createXorGC(color_);

  init();
}

CwmGraphics::
CwmGraphics(CwmXPixmap &pixmap, CwmFont *font, CwmColor *color, bool /*is_xor*/) :
 screen_(pixmap.getScreen()), font_(font), color_(color)
{
  gc_ = pixmap.createGC();

  init();
}

CwmGraphics::
~CwmGraphics()
{
  CwmMachineInst->freeGC(gc_);

  delete stipple_bitmap_;
}

void
CwmGraphics::
init()
{
  stipple_bitmap_ = 0;
}

void
CwmGraphics::
drawText(CwmWindow *xwindow, int x, int y, const std::string &text)
{
  setForeground();

  font_->drawString(xwindow, this, x, y, text);
}

void
CwmGraphics::
drawTextAligned(CwmWindow *xwindow, int x, int y, int width, int height,
                CHAlignType h_align, CVAlignType /*v_align*/, const std::string &text)
{
  if      (h_align == CHALIGN_TYPE_LEFT)
    drawTextLeft(xwindow, x, y, width, height, text);
  else if (h_align == CHALIGN_TYPE_RIGHT)
    drawTextRight(xwindow, x, y, width, height, text);
  else
    drawTextCentered(xwindow, x, y, width, height, text);
}

void
CwmGraphics::
drawTextLeft(CwmWindow *xwindow, int x, int y, int width, int height, const std::string &text)
{
  setTextSize(text);

  drawTextI(xwindow, x, y, width, height, CVALIGN_TYPE_CENTER, text);
}

void
CwmGraphics::
drawTextRight(CwmWindow *xwindow, int x, int y, int width, int height, const std::string &text)
{
  setTextSize(text);

  int dx = width - text_width_;

  dx = std::max(dx, 0);

  drawTextI(xwindow, x + dx, y, width, height, CVALIGN_TYPE_CENTER, text);
}

void
CwmGraphics::
drawTextCentered(CwmWindow *xwindow, int x, int y, int width, int height, const std::string &text)
{
  setTextSize(text);

  int dx = (width - text_width_)/2;

  dx = std::max(dx, 0);

  drawTextI(xwindow, x + dx, y, width, height, CVALIGN_TYPE_CENTER, text);
}

void
CwmGraphics::
setTextSize(const std::string &text)
{
  getTextSize(text, &text_width_, &text_height_);
}

int
CwmGraphics::
getFontHeight()
{
  return font_->getHeight();
}

int
CwmGraphics::
getFontAscent()
{
  return font_->getAscent();
}

int
CwmGraphics::
getFontDescent()
{
  return font_->getDescent();
}

void
CwmGraphics::
getTextSize(const std::string &text, int *width, int *height)
{
  font_->getTextSize(text, width, height);
}

void
CwmGraphics::
drawTextI(CwmWindow *xwindow, int x, int y, int width, int height,
          CVAlignType v_align, const std::string &text)
{
  int dy = 0;

  if (v_align == CVALIGN_TYPE_TOP)
    dy += height - text_height_;
  else if (v_align == CVALIGN_TYPE_BOTTOM)
    ;
  else {
    dy += (height - text_height_)/2;
  }

  dy = std::max(dy, 0);

  startClip(x, y, width, height);

  setForeground();

  font_->drawString(xwindow, this, x, y + dy, text);

  endClip();
}

void
CwmGraphics::
startClip(int x, int y, int width, int height)
{
  CwmMachineInst->startRectClip(gc_, x, y, width, height);
}

void
CwmGraphics::
startClip(CwmXPixmap *xpixmap, int dx, int dy)
{
  CwmMachineInst->startPixmapClip(gc_, xpixmap->getXPixmap(), dx, dy);
}

void
CwmGraphics::
endClip()
{
  CwmMachineInst->endPixmapClip(gc_);
}

void
CwmGraphics::
drawButtonOut(CwmWindow *xwindow, int x, int y, int width, int height, int thick)
{
  int x1 = x;
  int y1 = y;
  int x2 = x + width  - 1;
  int y2 = y + height - 1;

  setDarkForeground();

  int i;

  for (i = 0; i < thick; i++) {
    drawLineI(xwindow, x2 - i, y2 - i, x1 + i, y2 - i);
    drawLineI(xwindow, x2 - i, y2 - i, x2 - i, y1 + i);
  }

  setLightForeground();

  for (i = 0; i < thick; i++) {
    drawLineI(xwindow, x1 + i, y1 + i, x2 - i, y1 + i);
    drawLineI(xwindow, x1 + i, y1 + i, x1 + i, y2 - i);
  }
}

void
CwmGraphics::
drawButtonIn(CwmWindow *xwindow, int x, int y, int width, int height, int thick)
{
  int x1 = x;
  int y1 = y;
  int x2 = x + width  - 1;
  int y2 = y + height - 1;

  setLightForeground();

  int i;

  for (i = 0; i < thick; i++) {
    drawLineI(xwindow, x2 - i, y2 - i, x1 + i, y2 - i);
    drawLineI(xwindow, x2 - i, y2 - i, x2 - i, y1 + i);
  }

  setDarkForeground();

  for (i = 0; i < thick; i++) {
    drawLineI(xwindow, x1 + i, y1 + i, x2 - i, y1 + i);
    drawLineI(xwindow, x1 + i, y1 + i, x1 + i, y2 - i);
  }
}

void
CwmGraphics::
drawSidesOut(CwmWindow *xwindow, int sides, int x, int y, int width, int height, int thick)
{
  int x1 = x;
  int y1 = y;
  int x2 = x + width  - 1;
  int y2 = y + height - 1;

  setDarkForeground();

  int i;

  for (i = 0; i < thick; i++) {
    if (sides & CSIDE_TYPE_BOTTOM)
      drawLineI(xwindow, x2 - i, y2 - i, x1 + i, y2 - i);

    if (sides & CSIDE_TYPE_RIGHT)
      drawLineI(xwindow, x2 - i, y2 - i, x2 - i, y1 + i);
  }

  setLightForeground();

  for (i = 0; i < thick; i++) {
    if (sides & CSIDE_TYPE_TOP)
      drawLineI(xwindow, x1 + i, y1 + i, x2 - i, y1 + i);

    if (sides & CSIDE_TYPE_LEFT)
      drawLineI(xwindow, x1 + i, y1 + i, x1 + i, y2 - i);
  }
}

void
CwmGraphics::
drawSidesIn(CwmWindow *xwindow, int sides, int x, int y, int width, int height, int thick)
{
  int x1 = x;
  int y1 = y;
  int x2 = x + width  - 1;
  int y2 = y + height - 1;

  setLightForeground();

  int i;

  for (i = 0; i < thick; i++) {
    if (sides & CSIDE_TYPE_BOTTOM)
      drawLineI(xwindow, x2 - i, y2 - i, x1 + i, y2 - i);

    if (sides & CSIDE_TYPE_RIGHT)
      drawLineI(xwindow, x2 - i, y2 - i, x2 - i, y1 + i);
  }

  setDarkForeground();

  for (i = 0; i < thick; i++) {
    if (sides & CSIDE_TYPE_TOP)
      drawLineI(xwindow, x1 + i, y1 + i, x2 - i, y1 + i);

    if (sides & CSIDE_TYPE_LEFT)
      drawLineI(xwindow, x1 + i, y1 + i, x1 + i, y2 - i);
  }
}

void
CwmGraphics::
drawEtchedLine(CwmWindow *xwindow, int x1, int y1, int x2, int y2)
{
  setDarkForeground();

  drawLineI(xwindow, x1, y1    , x2, y2    );

  setLightForeground();

  drawLineI(xwindow, x1, y1 + 1, x2, y2 + 1);
}

void
CwmGraphics::
drawRightArrowOut(CwmWindow *xwindow, int x1, int y1, int x2, int y2)
{
  setDarkForeground();

  drawLineI(xwindow, x1, y2    , x2, y2 - 3);
  drawLineI(xwindow, x1, y2 - 1, x2, y2 - 4);

  setLightForeground();

  drawLineI(xwindow, x1, y1    , x1, y2    );
  drawLineI(xwindow, x1, y1    , x1, y2 - 2);
  drawLineI(xwindow, x1, y1    , x2, y1 + 3);
  drawLineI(xwindow, x1, y1 + 1, x2, y1 + 4);
}

void
CwmGraphics::
drawLine(CwmWindow *xwindow, int x1, int y1, int x2, int y2)
{
  setForeground();

  drawLineI(xwindow, x1, y1, x2, y2);
}

void
CwmGraphics::
drawHLine(CwmWindow *xwindow, int x1, int x2, int y)
{
  drawLine(xwindow, x1, y, x2, y);
}

void
CwmGraphics::
drawHLine(CwmWindow *xwindow, int x1, int x2, int y, const CRGBA &rgba)
{
  setForeground(rgba);

  drawLineI(xwindow, x1, y, x2, y);
}

void
CwmGraphics::
drawVLine(CwmWindow *xwindow, int x, int y1, int y2)
{
  drawLine(xwindow, x, y1, x, y2);
}

void
CwmGraphics::
drawVLine(CwmWindow *xwindow, int x, int y1, int y2, const CRGBA &rgba)
{
  setForeground(rgba);

  drawLineI(xwindow, x, y1, x, y2);
}

void
CwmGraphics::
drawDLine(CwmWindow *xwindow, int x1, int y1, int x2, int y2)
{
  if (x1 < 0 || x1 >= xwindow->getWidth () ||
      x2 < 0 || x2 >= xwindow->getWidth () ||
      y1 < 0 || y1 >= xwindow->getHeight() ||
      y2 < 0 || y2 >= xwindow->getHeight())
    return;

  int dx = (x2 > x1 ? 1 : -1);
  int dy = (y2 > y1 ? 1 : -1);

  int x = x1;
  int y = y1;

  while (true) {
    if      (dx ==  1 && x > x2) break;
    else if (dx == -1 && x < x2) break;
    if      (dy ==  1 && y > y2) break;
    else if (dy == -1 && y < y2) break;

    drawPoint(xwindow, x, y);

    x += dx;
    y += dy;
  }
}

void
CwmGraphics::
drawDarkLine(CwmWindow *xwindow, int x1, int y1, int x2, int y2)
{
  setDarkForeground();

  drawLineI(xwindow, x1, y1, x2, y2);
}

void
CwmGraphics::
drawVDarkLine(CwmWindow *xwindow, int x, int y1, int y2)
{
  drawDarkLine(xwindow, x, y1, x, y2);
}

void
CwmGraphics::
drawHDarkLine(CwmWindow *xwindow, int x1, int x2, int y)
{
  drawDarkLine(xwindow, x1, y, x2, y);
}

void
CwmGraphics::
drawLightLine(CwmWindow *xwindow, int x1, int y1, int x2, int y2)
{
  setLightForeground();

  drawLineI(xwindow, x1, y1, x2, y2);
}

void
CwmGraphics::
drawVLightLine(CwmWindow *xwindow, int x, int y1, int y2)
{
  drawLightLine(xwindow, x, y1, x, y2);
}

void
CwmGraphics::
drawHLightLine(CwmWindow *xwindow, int x1, int x2, int y)
{
  drawLightLine(xwindow, x1, y, x2, y);
}

void
CwmGraphics::
drawLineI(CwmWindow *xwindow, int x1, int y1, int x2, int y2)
{
  CwmMachineInst->drawLine(xwindow->getXWin(), gc_, x1, y1, x2, y2);
}

void
CwmGraphics::
drawRectangle(CwmWindow *xwindow, int x, int y, int width, int height)
{
  CwmMachineInst->drawRectangle(xwindow->getXWin(), gc_, x, y, width, height);
}

void
CwmGraphics::
drawRectangle(CwmXPixmap *xpixmap, int x, int y, int width, int height)
{
  CwmMachineInst->drawRectangle(xpixmap->getXPixmap(), gc_, x, y, width, height);
}

void
CwmGraphics::
fillRectangle(CwmWindow *xwindow, int x, int y, int width, int height)
{
  CwmMachineInst->fillRectangle(xwindow->getXWin(), gc_, x, y, width, height);
}

void
CwmGraphics::
fillRectangle(CwmXPixmap *xpixmap, int x, int y, int width, int height)
{
  CwmMachineInst->fillRectangle(xpixmap->getXPixmap(), gc_, x, y, width, height);
}

void
CwmGraphics::
drawPoint(CwmWindow *xwindow, int x, int y)
{
  CwmMachineInst->drawPoint(xwindow->getXWin(), gc_, x, y);
}

void
CwmGraphics::
setForeground()
{
  CwmMachineInst->setForeground(gc_, color_->getFg());
}

void
CwmGraphics::
setForeground(const CRGBA &rgba)
{
  CwmMachineInst->setForeground(gc_, screen_.getPixel(rgba));
}

void
CwmGraphics::
setForeground(int ind)
{
  CwmMachineInst->setForeground(gc_, ind);
}

void
CwmGraphics::
setBackground()
{
  CwmMachineInst->setBackground(gc_, color_->getBg());
}

void
CwmGraphics::
setDarkForeground()
{
  CwmMachineInst->setForeground(gc_, color_->getDark());
}

void
CwmGraphics::
setLightForeground()
{
  CwmMachineInst->setForeground(gc_, color_->getLight());
}

void
CwmGraphics::
copyArea(CwmWindow *src, CwmWindow *dest, int src_x, int src_y,
         int src_width, int src_height, int desy_x, int desy_y)
{
  CwmMachineInst->copyArea(src->getXWin(), dest->getXWin(), gc_,
                           src_x, src_y, src_width, src_height, desy_x, desy_y);
}

void
CwmGraphics::
copyArea(CwmXPixmap *src, CwmWindow *dest, int src_x, int src_y,
         int src_width, int src_height, int desy_x, int desy_y)
{
  if (src->getDepth() == screen_.getDepth())
    CwmMachineInst->copyArea(src->getXPixmap(), dest->getXWin(), gc_,
                             src_x, src_y, src_width, src_height, desy_x, desy_y);
  else
    CwmMachineInst->copyPlanes(src->getXPixmap(), src->getDepth(),
                               dest->getXWin(), screen_.getDepth(),
                               gc_, src_x, src_y, src_width, src_height, desy_x, desy_y);
}

void
CwmGraphics::
copyArea(CwmWindow *src, CwmXPixmap *dest, int src_x, int src_y,
         int src_width, int src_height, int desy_x, int desy_y)
{
  if (dest->getDepth() == screen_.getDepth())
    CwmMachineInst->copyArea(src->getXWin(), dest->getXPixmap(), gc_,
                             src_x, src_y, src_width, src_height, desy_x, desy_y);
  else
    CwmMachineInst->copyPlanes(src->getXWin(), screen_.getDepth(),
                               dest->getXPixmap(), dest->getDepth(),
                               gc_, src_x, src_y, src_width, src_height, desy_x, desy_y);
}

void
CwmGraphics::
copyArea(CwmXPixmap *src, CwmXPixmap *dest, int src_x, int src_y,
         int src_width, int src_height, int desy_x, int desy_y)
{
  if (dest->getDepth() == src->getDepth())
    CwmMachineInst->copyArea(src->getXPixmap(), dest->getXPixmap(), gc_,
                             src_x, src_y, src_width, src_height, desy_x, desy_y);
  else
    CwmMachineInst->copyPlanes(src->getXPixmap(), src->getDepth(),
                               dest->getXPixmap(), dest->getDepth(),
                               gc_, src_x, src_y, src_width, src_height, desy_x, desy_y);
}

void
CwmGraphics::
setStippled()
{
  if (stipple_bitmap_ == 0)
    stipple_bitmap_ = CwmMachineInst->createStippleCwmXPixmap(screen_);

  CwmMachineInst->setFillStipple(gc_, stipple_bitmap_->getXPixmap());
}

void
CwmGraphics::
gradientFillRectangle(CwmWindow *xwindow, int x, int y, int width, int height,
                      const CRGBA &start, const CRGBA &end, CwmGradientDir direction)
{
  CRGBA rgba(start);

  if      (direction == CWM_GRADIENT_DIR_VERTICAL) {
    CRGBA drgba = (end - start)/(height - 1.0);

    for (int i = 0; i < height; i++) {
      setForeground(rgba);

      drawHLine(xwindow, 0, width - 1, i);

      rgba += drgba;
    }
  }
  else if (direction == CWM_GRADIENT_DIR_HORIZONTAL) {
    CRGBA drgba = (end - start)/(width - 1.0);

    for (int i = 0; i < width; i++) {
      setForeground(rgba);

      drawVLine(xwindow, i, 0, height - 1);

      rgba += drgba;
    }
  }
  else if (direction == CWM_GRADIENT_DIR_LDIAGONAL) {
    CRGBA drgba1 = (end - start)/(2*( width - 1.0));
    CRGBA drgba2 = (end - start)/(2*(height - 1.0));

    for (int yy = 0; yy < height; yy++) {
      CRGBA rgba1 = rgba;

      for (int xx = 0; xx < width; xx++) {
        setForeground(rgba);

        drawPoint(xwindow, x + xx, y + yy);

        rgba += drgba1;
      }

      rgba = rgba1 + drgba2;
    }
  }
  else if (direction == CWM_GRADIENT_DIR_RDIAGONAL) {
    CRGBA drgba1 = (end - start)/(2*( width - 1.0));
    CRGBA drgba2 = (end - start)/(2*(height - 1.0));

    for (int yy = 0; yy < height; yy++) {
      CRGBA rgba1 = rgba;

      for (int xx = width - 1; xx >= 0; xx--) {
        setForeground(rgba);

        drawPoint(xwindow, x + xx, y + yy);

        rgba += drgba1;
      }

      rgba = rgba1 + drgba2;
    }
  }
}
##concat##CwmGrid.cpp
#include <CwmI.h>

struct CwmCell {
  int   x;
  int   y;
  bool  used;
  void *id;
};

CwmGrid::
CwmGrid(CwmScreen &screen1, int cell_width1, int cell_height1) :
 screen(screen1), cell_width(cell_width1), cell_height(cell_height1)
{
  num_cols = screen.getWidth() /cell_width;
  num_rows = screen.getHeight()/cell_height;

  cells = new CwmCell * [num_rows];

  for (int col = 0; col < num_rows; col++)
    cells[col] = new CwmCell [num_cols];

  int y = 0;

  for (int row = 0; row < num_rows; row++) {
    int x = 0;

    for (int col = 0; col < num_cols; col++) {
      CwmCell *cell = &cells[row][col];

      cell->x    = x;
      cell->y    = y;
      cell->used = false;
      cell->id   = 0;

      x += cell_width;
    }

    y += cell_height;
  }
}

CwmGrid::
~CwmGrid()
{
  for (int row = 0; row < num_rows; row++)
    delete [] cells[row];

  delete [] cells;
}

void
CwmGrid::
add(void *id, int *x1, int *y1, int *x2, int *y2,
    CwmGridInsertType insert_major, CwmGridInsertType insert_minor)
{
  if (*x1 < 0) {
    *x2 += -(*x1);
    *x1  = 0;
  }

  if (*y1 < 0) {
    *y2 += -(*y1);
    *y1  = 0;
  }

  if (*x2 >= screen.getWidth()) {
    *x1 -= *x2 - (screen.getWidth() - 1);
    *x2  = screen.getWidth() - 1;
  }

  if (*y2 >= screen.getHeight()) {
    *y1 -= *y2 - (screen.getHeight() - 1);
    *y2  = screen.getHeight() - 1;
  }

  int width  = *x2 - *x1;
  int height = *y2 - *y1;

  int num_rows1 = height/cell_height;
  int num_cols1 = width /cell_width;

  if (height % cell_height != 0)
    num_rows1++;

  if (width  % cell_width  != 0)
    num_cols1++;

  int row, col;

  for (row = 0; row <= num_rows - num_rows1; row++) {
    CwmCell *cell = &cells[row][0];

    if (*y1 >= cell->y && *y1 < cell->y + cell_height)
      break;
  }

  for (col = 0; col <= num_cols - num_cols1; col++) {
    CwmCell *cell = &cells[0][col];

    if (*x1 >= cell->x && *x1 < cell->x + cell_width)
      break;
  }

  if (row <= num_rows - num_rows1 && col <= num_cols - num_cols1) {
    if (checkCells(row, col, num_rows1, num_cols1)) {
      placeInCells(id, row, col, num_rows1, num_cols1);

      setPosition(row, col, num_rows1, num_cols1, x1, y1, x2, y2);

      return;
    }
  }

  if (insert_major == CWM_INSERT_LEFT ||
      insert_major == CWM_INSERT_RIGHT) {
    int i1 = 0;
    int i2 = 0;
    int j1 = 0;
    int j2 = 0;
    int di = 1;
    int dj = 1;

    if (insert_major == CWM_INSERT_LEFT)
      j2 = num_cols - num_cols1 - 1;
    else {
      j1 = num_cols - num_cols1 - 1;
      dj = -1;
    }

    if (insert_minor == CWM_INSERT_TOP)
      i2 = num_rows - num_rows1 - 1;
    else {
      i1 = num_rows - num_rows1 - 1;
      di = -1;
    }

    for (row = i1; di > 0 ? row <= i2 : row >= i2; row += di) {
      int col;

      for (col = j1; dj > 0 ? col <= j2 : col >= j2; col += dj) {
        if (checkCells(row, col, num_rows1, num_cols1)) {
          placeInCells(id, row, col, num_rows1, num_cols1);
          setPosition(row, col, num_rows1, num_cols1, x1, y1, x2, y2);
          return;
        }
      }
    }
  }
  else {
    int i1 = 0;
    int i2 = 0;
    int j1 = 0;
    int j2 = 0;
    int di = 1;
    int dj = 1;

    if (insert_major == CWM_INSERT_TOP)
      i2 = num_rows - num_rows1 - 1;
    else {
      i1 = num_rows - num_rows1 - 1;
      di = -1;
    }

    if (insert_minor == CWM_INSERT_LEFT)
      j2 = num_cols - num_cols1 - 1;
    else {
      j1 = num_cols - num_cols1 - 1;
      dj = -1;
    }

    for (col = j1; dj > 0 ? col <= j2 : col >= j2; col += dj) {
      for (row = i1; di > 0 ? row <= i2 : row >= i2; row += di) {
        if (checkCells(row, col, num_rows1, num_cols1)) {
          placeInCells(id, row, col, num_rows1, num_cols1);
          setPosition(row, col, num_rows1, num_cols1, x1, y1, x2, y2);
          return;
        }
      }
    }
  }

  if (row < 0 || row >= num_rows - num_rows1)
    row = 0;

  if (col < 0 || col >= num_cols - num_cols1)
    col = 0;

  setPosition(row, col, num_rows1, num_cols1, x1, y1, x2, y2);
}

void
CwmGrid::
remove(void *id)
{
  bool found = false;

  for (int row = 0; row < num_rows; row++)
    for (int col = 0; col < num_cols; col++)
      if (cells[row][col].id == id) {
        cells[row][col].used = false;
        cells[row][col].id   = 0;

        found = true;
      }
}

bool
CwmGrid::
checkCells(int row, int col, int num_rows1, int num_cols1)
{
  for (int i = 0; i < num_rows1; i++)
    for (int j = 0; j < num_cols1; j++)
      if (cells[row + i][col + j].used)
        return false;

  return true;
}

void
CwmGrid::
placeInCells(void *id, int row, int col, int num_rows1, int num_cols1)
{
  for (int i = 0; i < num_rows1; i++)
    for (int j = 0; j < num_cols1; j++) {
      cells[row + i][col + j].used = true;
      cells[row + i][col + j].id   = id;
    }
}

void
CwmGrid::
setPosition(int row, int col, int num_rows1, int num_cols1,
            int *x1, int *y1, int *x2, int *y2)
{
  CwmCell *cell = &cells[row][col];

  int width  = *x2 - *x1;
  int height = *y2 - *y1;

  int dx = (num_cols1*cell_width  - width )/2;
  int dy = (num_rows1*cell_height - height)/2;

  *x1 = cell->x + dx;
  *y1 = cell->y + dy;
  *x2 = *x1 + width;
  *y2 = *y1 + height;
}

void
CwmGrid::
printMap()
{
  for (int row = 0; row < num_rows; row++) {
    for (int col = 0; col < num_cols; col++)
      if (cells[row][col].used)
        fputc('X', stdout);
      else
        fputc('.', stdout);

    fputc('\n', stdout);
  }
}
##concat##CwmHints.cpp
#include <CwmI.h>

class CwmCustomHintValue {
 private:
  std::string  name_;
  std::string  type_;
  CwmData value_;

 public:
  CwmCustomHintValue(const std::string &name, const std::string &type, CwmData value);
 ~CwmCustomHintValue();

  bool isType(const std::string &type);

  CwmData getValue() const { return value_; }

  bool isName(const std::string &name);
};

class CwmCustomHint {
 private:
  typedef vector<CwmCustomHintValue *> CustomHintValueList;

  std::string               pattern_;
  CGlob               *compile_;
  CustomHintValueList  values_;

 public:
  CwmCustomHint(const std::string &pattern);
 ~CwmCustomHint();

  void addValue(const std::string &name, const char *type, CwmData value);

  bool compare(const std::string &name);

  bool isPattern(const std::string &pattern);

  CwmCustomHintValue *lookup(const std::string &name);
};

CwmHints::
CwmHints(CwmWMWindow *window) :
 window_(window)
{
  user_xwin_ = window->getXWin();

  name_      = "";
  icon_name_ = "";

  x_           = 0;
  y_           = 0;
  width_inc_   = 1;
  height_inc_  = 1;
  min_width_   = 1;
  min_height_  = 1;
  max_width_   = 9999;
  max_height_  = 9999;
  base_width_  = 1;
  base_height_ = 1;
  min_aspect_  = 1;
  max_aspect_  = 1;
  win_gravity_ = 0;

  input_         = true;
  initial_state_ = NormalState;
  icon_window_   = None;
  icon_pixmap_   = None;
  icon_mask_     = None;
  icon_depth_    = 0;
  icon_x_        = -1;
  icon_y_        = -1;
  window_group_  = None;

  transient_for_ = None;

  res_name_  = "";
  res_class_ = "";

  client_machine_ = "";

  cmap_windows_     = 0;
  num_cmap_windows_ = 0;

  take_focus_    = false;
  save_yourself_ = false;
  delete_window_ = false;

  mwm_functions_   = 0;
  mwm_decorations_ = 0;
  mwm_input_mode_  = 0;
  mwm_status_      = 0;

  init();
}

CwmHints::
~CwmHints()
{
}

void
CwmHints::
init()
{
  readWMName       ();
  readWMIconName   ();
  readWMSizeHints  ();
  readWMHints      ();
  readTransientHint();
  readClassHint    ();
  readSessionHints ();
  readWMCMapWindows();
  readWMProtocols  ();
  readMwmHints     ();

  //------

  if (transient_for_ != None) {
    mwm_functions_ &= ~MWM_FUNC_MINIMIZE;
    mwm_functions_ &= ~MWM_FUNC_MAXIMIZE;
    mwm_functions_ &= ~MWM_FUNC_RESTORE;
  }

  //------

  if (! CwmCustomHintMgrInst->getCustomHintValue
         (res_name_, CwmNdecorations, (CwmData) &mwm_decorations_))
    CwmCustomHintMgrInst->getCustomHintValue
     (res_class_, CwmNdecorations, (CwmData) &mwm_decorations_);

  if (! CwmCustomHintMgrInst->getCustomHintValue
         (res_name_, CwmNfunctions, (CwmData) &mwm_functions_))
    CwmCustomHintMgrInst->getCustomHintValue
     (res_class_, CwmNfunctions, (CwmData) &mwm_functions_);

  //------

  if (mwm_functions_ == MWM_FUNC_ALL)
    mwm_functions_ = MWM_FUNC_RESIZE   | MWM_FUNC_MOVE     |
                     MWM_FUNC_MINIMIZE | MWM_FUNC_MAXIMIZE |
                     MWM_FUNC_CLOSE    | MWM_FUNC_RESTORE;

  if (mwm_decorations_ == MWM_DECOR_ALL)
    mwm_decorations_ = MWM_DECOR_BORDER   | MWM_DECOR_RESIZEH |
                       MWM_DECOR_TITLE    | MWM_DECOR_MENU    |
                       MWM_DECOR_MINIMIZE | MWM_DECOR_MAXIMIZE;

  if (! (mwm_functions_ & MWM_FUNC_RESIZE))
    mwm_decorations_ &= ~MWM_DECOR_RESIZEH;

  if (! (mwm_functions_ & MWM_FUNC_MINIMIZE))
    mwm_decorations_ &= ~MWM_DECOR_MINIMIZE;

  if (! (mwm_functions_ & MWM_FUNC_MAXIMIZE))
    mwm_decorations_ &= ~MWM_DECOR_MAXIMIZE;

  if (mwm_decorations_ & MWM_DECOR_MENU     ||
      mwm_decorations_ & MWM_DECOR_MINIMIZE ||
      mwm_decorations_ & MWM_DECOR_MAXIMIZE)
    mwm_decorations_ |= MWM_DECOR_TITLE;

  if (mwm_decorations_ & MWM_DECOR_RESIZEH)
    mwm_decorations_ |= MWM_DECOR_BORDER;

  //------

  if (CwmInst->getPrintHints())
    print();
}

void
CwmHints::
readWMName()
{
  CwmMachineInst->getWMName(user_xwin_, name_);
}

void
CwmHints::
readWMIconName()
{
  CwmMachineInst->getWMIconName(user_xwin_, icon_name_);
}

void
CwmHints::
readWMSizeHints()
{
  int         supplied;
  XSizeHints *size_hints;

  CwmMachineInst->getWMNormalHints(user_xwin_, &size_hints, &supplied);

  if      (size_hints->flags & USPosition) {
    x_ = size_hints->x;
    y_ = size_hints->y;
  }
  else if (size_hints->flags & PPosition) {
    x_ = size_hints->x;
    y_ = size_hints->y;

    if (x_ == 0 && y_ == 0) {
      x_ = -1;
      y_ = -1;
    }
  }
  else {
    x_ = -1;
    y_ = -1;
  }

  if (size_hints->flags & PResizeInc) {
    width_inc_  = size_hints->width_inc;
    height_inc_ = size_hints->height_inc;
  }

  if (width_inc_  <= 0)
    width_inc_  = 1;

  if (height_inc_ <= 0)
    height_inc_ = 1;

  if (! (size_hints->flags & PMinSize ) &&
      ! (size_hints->flags & PBaseSize)) {
    size_hints->min_width   = 0;
    size_hints->min_height  = 0;
    size_hints->base_width  = 0;
    size_hints->base_height = 0;
  }

  if (size_hints->flags & PMinSize) {
    min_width_  = size_hints->min_width;
    min_height_ = size_hints->min_height;
  }
  else {
    min_width_  = size_hints->base_width;
    min_height_ = size_hints->base_height;
  }

  if (size_hints->flags & PBaseSize) {
    base_width_  = size_hints->base_width;
    base_height_ = size_hints->base_height;
  }
  else {
    base_width_  = size_hints->min_width;
    base_height_ = size_hints->min_height;
  }

  if (min_width_ <= 0)
    min_width_  = 1;

  if (min_height_ <= 0)
    min_height_ = 1;

  if (size_hints->flags & PMaxSize) {
    max_width_  = size_hints->max_width;
    max_height_ = size_hints->max_height;
  }
  else {
    CwmScreen &screen = window_->getScreen();

    max_width_  = screen.getWidth();
    max_height_ = screen.getHeight();
  }

  if (max_width_  < min_width_)
    max_width_ = min_width_;

  if (max_height_ < min_height_)
    max_height_ = min_height_;

  if (size_hints->flags & PAspect) {
    min_aspect_ = ((double) size_hints->min_aspect.x)/size_hints->min_aspect.y;
    max_aspect_ = ((double) size_hints->max_aspect.x)/size_hints->max_aspect.y;
  }
  else {
    min_aspect_ = 0.0;
    max_aspect_ = 0.0;
  }

  if (size_hints->flags & PWinGravity)
    win_gravity_ = size_hints->win_gravity;
  else
    win_gravity_ = NorthWestGravity;
}

void
CwmHints::
readWMHints()
{
  XWMHints *wm_hints;

  CwmMachineInst->getWMHints(user_xwin_, &wm_hints);

  if (wm_hints == 0)
    return;

  if (wm_hints->flags & InputHint)
    input_ = wm_hints->input;

  if (wm_hints->flags & StateHint)
    initial_state_ = wm_hints->initial_state;

  if (wm_hints->flags & IconWindowHint &&
      CwmMachineInst->isValidWindow(wm_hints->icon_window))
    icon_window_ = wm_hints->icon_window;

  if (wm_hints->flags & IconPixmapHint && icon_window_ == None)
    icon_pixmap_ = wm_hints->icon_pixmap;

  if (wm_hints->flags & IconMaskHint)
    icon_mask_ = wm_hints->icon_mask;

  if (wm_hints->flags & IconPositionHint) {
    icon_x_ = wm_hints->icon_x;
    icon_y_ = wm_hints->icon_y;
  }

  if (wm_hints->flags & WindowGroupHint)
    window_group_ = wm_hints->window_group;
}

void
CwmHints::
readTransientHint()
{
  CwmMachineInst->getWMTransientFor(user_xwin_, &transient_for_);
}

void
CwmHints::
readClassHint()
{
  XClassHint *class_hint;

  CwmMachineInst->getWMClassHint(user_xwin_, &class_hint);

  char *res_name  = class_hint->res_name;
  char *res_class = class_hint->res_class;

  res_name_  = "";
  res_class_ = "";

  if (res_name != 0)
    res_name_ = res_name;

  if (res_name_ == "")
    res_name_ = name_;

  if (res_class != 0)
    res_class_ = res_class;

  if (res_class_ == "" && res_name_ != "") {
    res_class_ = res_name_;

    res_class_[0] = toupper(res_class_[0]);
  }
}

void
CwmHints::
readSessionHints()
{
  CwmMachineInst->getWMClientMachine(user_xwin_, client_machine_);

  int    argc;
  char **argv;

  command_argv_.clear();

  CwmMachineInst->getWMCommand(user_xwin_, &argc, &argv);

  for (int i = 0; i < argc; i++)
    command_argv_.push_back(string(argv[i]));
}

void
CwmHints::
readWMCMapWindows()
{
  if (cmap_windows_ != 0)
    XFree((char *) cmap_windows_);

  CwmMachineInst->getWMColormapWindows(user_xwin_,
                                        &cmap_windows_,
                                        &num_cmap_windows_);
}

void
CwmHints::
readWMProtocols()
{
  take_focus_    = false;
  save_yourself_ = false;
  delete_window_ = false;

  const CXAtom **protocols     = 0;
  int            num_protocols = 0;

  CwmMachineInst->getWMProtocols(user_xwin_, &protocols, &num_protocols);

  for (int i = 0; i < num_protocols; i++) {
    if (CwmMachineInst->isWMTakeFocusAtom(*protocols[i]))
      take_focus_ = true;

    if (CwmMachineInst->isWMSaveYourselfAtom(*protocols[i]))
      save_yourself_ = true;

    if (CwmMachineInst->isWMDeleteWindowAtom(*protocols[i]))
      delete_window_ = true;
  }

  if (protocols != 0)
    delete [] protocols;
}

void
CwmHints::
readMwmHints()
{
  mwm_functions_   = MWM_FUNC_RESIZE   | MWM_FUNC_MOVE     |
                     MWM_FUNC_MINIMIZE | MWM_FUNC_MAXIMIZE |
                     MWM_FUNC_CLOSE    | MWM_FUNC_RESTORE;
  mwm_decorations_ = MWM_DECOR_BORDER   | MWM_DECOR_RESIZEH |
                     MWM_DECOR_TITLE    | MWM_DECOR_MENU    |
                     MWM_DECOR_MINIMIZE | MWM_DECOR_MAXIMIZE;
  mwm_input_mode_  = MWM_INPUT_MODELESS;
  mwm_status_      = 0;

  MotifWmHints *mwm_hints;

  if (! CwmMachineInst->getWMMwmHints(user_xwin_, &mwm_hints))
    return;

  if (mwm_hints->flags & MWM_HINTS_FUNCTIONS)
    mwm_functions_ = mwm_hints->functions;

  if (mwm_hints->flags & MWM_HINTS_DECORATIONS)
    mwm_decorations_ = mwm_hints->decorations;

  if (mwm_hints->flags & MWM_HINTS_INPUT_MODE)
    mwm_input_mode_ = mwm_hints->input_mode;

  if (mwm_hints->flags & MWM_HINTS_STATUS)
    mwm_status_ = mwm_hints->status;
}

void
CwmHints::
print()
{
  if (name_ != "")
    CwmMachineInst->logf("name = %s\n", name_.c_str());

  if (icon_name_ != "")
    CwmMachineInst->logf("icon_name = %s\n", icon_name_.c_str());

  CwmMachineInst->logf("width_inc        = %d\n", width_inc_);
  CwmMachineInst->logf("height_inc       = %d\n", height_inc_);
  CwmMachineInst->logf("min_width        = %d\n", min_width_);
  CwmMachineInst->logf("min_height       = %d\n", min_height_);
  CwmMachineInst->logf("max_width        = %d\n", max_width_);
  CwmMachineInst->logf("max_height       = %d\n", max_height_);
  CwmMachineInst->logf("base_width       = %d\n", base_width_);
  CwmMachineInst->logf("base_height      = %d\n", base_height_);
  CwmMachineInst->logf("min_aspect       = %d\n", min_aspect_);
  CwmMachineInst->logf("max_aspect       = %d\n", max_aspect_);
  CwmMachineInst->logf("win_gravity      = %d\n", win_gravity_);
  CwmMachineInst->logf("input            = %d\n", input_);
  CwmMachineInst->logf("initial_state    = %d\n", initial_state_);
  CwmMachineInst->logf("icon_window      = %x\n", (uint) icon_window_);
  CwmMachineInst->logf("icon_pixmap      = %x\n", (uint) icon_pixmap_);
  CwmMachineInst->logf("icon_mask        = %x\n", (uint) icon_mask_);
  CwmMachineInst->logf("icon_depth       = %d\n", icon_depth_);
  CwmMachineInst->logf("icon_x           = %d\n", icon_x_);
  CwmMachineInst->logf("icon_y           = %d\n", icon_y_);
  CwmMachineInst->logf("window_group     = %x\n", (uint) window_group_);
  CwmMachineInst->logf("transient        = %x\n", (uint) transient_for_);
  CwmMachineInst->logf("res_name         = %s\n", res_name_.c_str());
  CwmMachineInst->logf("res_class        = %s\n", res_class_.c_str());
  CwmMachineInst->logf("client_machine   = %s\n", client_machine_.c_str());

  for (int i = 0; command_argv_.size(); i++)
    CwmMachineInst->logf("command_argv[%d] = %s\n",
                         i, command_argv_[i].c_str());

  CwmMachineInst->logf("num_cmap_windows = %d\n", num_cmap_windows_);
  CwmMachineInst->logf("take_focus       = %d\n", take_focus_);
  CwmMachineInst->logf("save_yourself    = %d\n", save_yourself_);
  CwmMachineInst->logf("delete_window    = %d\n", delete_window_);
  CwmMachineInst->logf("mwm_functions    = %d\n", mwm_functions_);
  CwmMachineInst->logf("mwm_decorations  = %d\n", mwm_decorations_);
  CwmMachineInst->logf("mwm_input_mode   = %d\n", mwm_input_mode_);
  CwmMachineInst->logf("mwm_status       = %d\n", mwm_status_);
}

CwmCustomHintMgr *
CwmCustomHintMgr::
getInstance()
{
  static CwmCustomHintMgr *instance;

  if (! instance)
    instance = new CwmCustomHintMgr();

  return instance;
}

CwmCustomHintMgr::
CwmCustomHintMgr()
{
}

CwmCustomHintMgr::
~CwmCustomHintMgr()
{
  std::for_each(custom_hints_.begin(), custom_hints_.end(), CDeletePointer());
}

void
CwmCustomHintMgr::
addCustomHintValue(const std::string &pattern, const std::string &name,
                   const char *type, CwmData value)
{
  CwmCustomHint *custom_hint = getCustomHint(pattern);

  custom_hint->addValue(name, type, value);
}

bool
CwmCustomHintMgr::
getCustomHintValue(const std::string &window, const std::string &name, CwmData value)
{
  if (window == "")
    return false;

  CustomHintList::iterator phint1 = custom_hints_.begin();
  CustomHintList::iterator phint2 = custom_hints_.end  ();

  for ( ; phint1 != phint2; ++phint1)
    if ((*phint1)->compare(window))
      break;

  if (phint1 == phint2)
    return false;

  CwmCustomHint *custom_hint = *phint1;

  CwmCustomHintValue *custom_value = custom_hint->lookup(name);

  if (custom_value == 0)
    return false;

  if (custom_value->isType(CwmTint)) {
    int *pvalue = (int *) value;

    *pvalue = (long) custom_value->getValue();
  }
  else
    return false;

  return true;
}

CwmCustomHint *
CwmCustomHintMgr::
getCustomHint(const std::string &pattern)
{
  CustomHintList::iterator phint1 = custom_hints_.begin();
  CustomHintList::iterator phint2 = custom_hints_.end  ();

  for ( ; phint1 != phint2; ++phint1)
    if ((*phint1)->isPattern(pattern))
      return *phint1;

  CwmCustomHint *custom_hint = addCustomHint(pattern);

  return custom_hint;
}

CwmCustomHint *
CwmCustomHintMgr::
addCustomHint(const std::string &pattern)
{
  CwmCustomHint *custom_hint = new CwmCustomHint(pattern);

  custom_hints_.push_back(custom_hint);

  return custom_hint;
}

CwmCustomHintValue::
CwmCustomHintValue(const std::string &name, const std::string &type, CwmData value) :
 name_(name), type_(type), value_(value)
{
}

CwmCustomHintValue::
~CwmCustomHintValue()
{
}

bool
CwmCustomHintValue::
isType(const std::string &type)
{
  return (strcmp(type_.c_str(), type.c_str()) == 0);
}

bool
CwmCustomHintValue::
isName(const std::string &name)
{
  return (name == name_);
}

CwmCustomHint::
CwmCustomHint(const std::string &pattern) :
 pattern_(pattern)
{
  compile_ = new CGlob(pattern);
}

CwmCustomHint::
~CwmCustomHint()
{
  delete compile_;

  std::for_each(values_.begin(), values_.end(), CDeletePointer());
}

void
CwmCustomHint::
addValue(const std::string &name, const char *type, CwmData value)
{
  CwmCustomHintValue *custom_value = new CwmCustomHintValue(name, type, value);

  values_.push_back(custom_value);
}

bool
CwmCustomHint::
compare(const std::string &name)
{
  return compile_->compare(name);
}

CwmCustomHintValue *
CwmCustomHint::
lookup(const std::string &name)
{
  CustomHintValueList::const_iterator pvalue1 = values_.begin();
  CustomHintValueList::const_iterator pvalue2 = values_.end  ();

  for ( ; pvalue1 != pvalue2; ++pvalue1)
    if ((*pvalue1)->isName(name))
      return *pvalue1;

  return 0;
}

bool
CwmCustomHint::
isPattern(const std::string &pattern)
{
  return (pattern == pattern_);
}
##concat##CwmIdle.cpp
#include <CwmI.h>
#include <CXtTimer.h>

class CwmIdleTimer : public CXtTimer {
 private:
  CwmIdle *idle_;

 public:
  CwmIdleTimer(CwmIdle *idle);

  void timeOut();
};

static const int CWM_IDLE_TIMEOUT = 1000;

CwmIdle::
CwmIdle()
{
  enabled_   = true;
  timer_     = 0;
  idle_xwin_ = None;
}

CwmIdle::
~CwmIdle()
{
  delete timer_;
}

CwmIdle *
CwmIdle::
getInstance()
{
  static CwmIdle *instance;

  if (! instance)
    instance = new CwmIdle();

  return instance;
}

void
CwmIdle::
enable()
{
  enabled_ = true;
}

void
CwmIdle::
disable()
{
  enabled_ = false;
}

void
CwmIdle::
start()
{
  if (enabled_ && idle_xwin_ != None) {
    CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(idle_xwin_);

    if (xwindow != 0) {
      CwmIdleState idle_state(false);

      xwindow->callCallbacks(CWM_CALLBACK_IDLE, &idle_state);
    }
  }

  idle_xwin_ = None;

  delete timer_;

  timer_ = new CwmIdleTimer(this);
}

void
CwmIdle::
timeOut()
{
  if (! enabled_)
    return;

  CwmScreen *pointer_screen = 0;

  int num_screens = CwmMachineInst->getNumScreens();

  for (int i = 0; i < num_screens; ++i) {
    CwmScreen &screen = CwmMachineInst->getScreen(i);

    if (screen.hasPointer()) {
      pointer_screen = &screen;

      break;
    }
  }

  if (pointer_screen != 0) {
    CwmWindow *xwindow = pointer_screen->getPointerWindow();

    if (xwindow != 0) {
      if (xwindow->getXWin() != idle_xwin_) {
        idle_xwin_ = xwindow->getXWin();

        CwmIdleState idle_state(true);

        xwindow->callCallbacks(CWM_CALLBACK_IDLE, &idle_state);

        CwmMachineInst->flushEvents(true);
      }
    }
    else
      idle_xwin_ = None;
  }
}

CwmIdleTimer::
CwmIdleTimer(CwmIdle *idle) :
 CXtTimer(CWM_IDLE_TIMEOUT, CTIMER_FLAGS_REPEAT), idle_(idle)
{
}

void
CwmIdleTimer::
timeOut()
{
  idle_->timeOut();
}
##concat##CwmImageMgr.cpp
#include <CwmI.h>
#include <CXScreen.h>

unsigned char
CwmNamedImage::image_data_[] = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x81, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa1, 0xa5, 0xfc, 0xff, 0xff,
  0xff, 0x7f, 0x48, 0xad, 0xb5, 0xe0, 0xff, 0xff, 0x7f, 0x00, 0x28, 0xad,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa1, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x85, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0x85, 0xfc, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xa0,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x85, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0x85, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xfd, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xdd, 0xfc, 0xff, 0xff, 0xff, 0x01, 0x00, 0xa0,
  0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xdd, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xed, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa1,
  0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xed, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xdd, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0x00, 0xa0,
  0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xdd, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xed, 0x0c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xdd, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0xed, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xdd, 0x0c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xed, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xdd, 0xfc, 0xff, 0xf1, 0x3f, 0xfc, 0x07, 0xa0,
  0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xdd, 0xfc, 0xff, 0xf1,
  0x3f, 0xfc, 0x07, 0xa0, 0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0xdd, 0xfc, 0xff, 0xf1, 0x3f, 0xfc, 0x07, 0xa0, 0xed, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xdd, 0xfc, 0xff, 0xf1, 0x3f, 0xfc, 0x07, 0xa0,
  0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xdd, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0xdd, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xfd, 0x30, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0x85, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0x85, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x85, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x85, 0xfc, 0xff, 0xff,
  0xff, 0x3f, 0x00, 0xa0, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x85, 0xfc, 0xff, 0x03,
  0x00, 0x00, 0x00, 0xa0, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x85, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xa0, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
  0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xfd, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xbf, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

CwmImageMgr *
CwmImageMgr::
getInstance()
{
  static CwmImageMgr *instance;

  if (! instance)
    instance = new CwmImageMgr();

  return instance;
}

CwmImageMgr::
CwmImageMgr()
{
}

CwmImageMgr::
~CwmImageMgr()
{
  std::for_each(images_.begin(), images_.end(), CDeletePointer());
}

CwmImage *
CwmImageMgr::
getImage(CwmScreen &screen, const std::string &name, int width, int height)
{
  CwmNamedImage *named_image = lookup(name);

  if (named_image == 0) {
    if (name != "") {
      if (name[0] == ' ')
        return 0;

      std::string pathname = getPathName(name);

      if (pathname == "") {
        CwmMachineInst->logf("File %s not found on Path\n", name.c_str());
        return 0;
      }

      named_image = new CwmNamedImage(name, pathname);
    }
    else
      named_image = new CwmNamedImage("", "");

    images_.push_back(named_image);
  }

  return named_image->getImage(screen, width, height);
}

CwmImage *
CwmImageMgr::
getTiledImage(CwmScreen &screen, const std::string &name, int width, int height, int halign, int valign)
{
  CwmNamedImage *named_image = lookup(name);

  if (named_image == 0) {
    if (name != "") {
      if (name[0] == ' ')
        return 0;

      std::string pathname = getPathName(name);

      if (pathname == "") {
        CwmMachineInst->logf("File %s not found on Path\n", name.c_str());
        return 0;
      }

      named_image = new CwmNamedImage(name, pathname);
    }
    else
      named_image = new CwmNamedImage("", "");

    images_.push_back(named_image);
  }

  return named_image->getTiledImage(screen, width, height, halign, valign);
}

CwmNamedImage *
CwmImageMgr::
addImage(const std::string &name, const CImagePtr &image)
{
  CwmNamedImage *named_image = new CwmNamedImage(name, image);

  images_.push_back(named_image);

  return named_image;
}

CwmNamedImage *
CwmImageMgr::
lookup(const std::string &name)
{
  NamedImageList::const_iterator pimage1 = images_.begin();
  NamedImageList::const_iterator pimage2 = images_.end  ();

  for ( ; pimage1 != pimage2; ++pimage1)
    if ((*pimage1)->getName() == name)
      return *pimage1;

  return 0;
}

string
CwmImageMgr::
getPathName(const std::string &name)
{
  if (name == "")
    return "";

  std::string image_path_list = getenv("CWM_IMAGE_PATH");

  std::string image_path = "";

  if (image_path_list != "") {
    image_path = searchPathList(image_path_list, name);

    if (image_path == "")
      CwmMachineInst->logf("Failed to find file %s in path %s\n",
                           name.c_str(), image_path_list.c_str());
  }

  if (image_path == "") {
    image_path_list = "/usr/include/X11/pixmaps:/usr/include/X11/bitmaps";

    image_path = searchPathList(image_path_list, name);

    if (image_path == "")
      CwmMachineInst->logf("Failed to find file %s in path %s\n",
                           name.c_str(), image_path_list.c_str());
  }

  return image_path;
}

string
CwmImageMgr::
searchPathList(const std::string &path_list, const std::string &name)
{
  CStrWords paths = CStrUtil::toFields(path_list, ":");

  int num_paths = paths.size();

  for (int i = 0; i < num_paths; i++) {
    std::string filename = paths[i].getWord() + "/" + name;

    CFile file(filename);

    if (file.exists() && file.isRegular())
      return filename;
  }

  return "";
}

CwmNamedImage::
CwmNamedImage(const std::string &name, const std::string &pathname) :
 name_(name)
{
  if (name_ != "") {
    CFile file(pathname);

    CImageFileSrc src(pathname);

    image_ = CImageMgrInst->createImage(src);

    image_->read(&file);

    if (! image_)
      CwmMachineInst->logf("Failed to read image file %s\n", pathname.c_str());
  }
  else {
    CImageNameSrc src("Cwm/default_image");

    image_ = CImageMgrInst->createImage(src);

    image_->readXBM(image_data_, 64, 64);

    if (! image_)
      CwmMachineInst->log("Failed to read image data\n");
  }
}

CwmNamedImage::
CwmNamedImage(const std::string &name, const CImagePtr &image) :
 name_(name), image_(image)
{
}

CwmNamedImage::
~CwmNamedImage()
{
  std::for_each(images_.begin(), images_.end(), CDeletePointer());
}

CwmImage *
CwmNamedImage::
getImage(CwmScreen &screen, int width, int height)
{
  CwmScreenImage *screen_image = lookup(screen);

  if (screen_image == 0) {
    screen_image = new CwmScreenImage(screen, image_);

    images_.push_back(screen_image);
  }

  return screen_image->getImage(width, height);
}

CwmImage *
CwmNamedImage::
getTiledImage(CwmScreen &screen, int width, int height, int halign, int valign)
{
  CwmScreenImage *screen_image = lookup(screen);

  if (screen_image == 0) {
    screen_image = new CwmScreenImage(screen, image_);

    images_.push_back(screen_image);
  }

  return screen_image->getTiledImage(width, height, halign, valign);
}

CwmScreenImage *
CwmNamedImage::
lookup(CwmScreen &screen)
{
  ScreenImageList::const_iterator pimage1 = images_.begin();
  ScreenImageList::const_iterator pimage2 = images_.end  ();

  for ( ; pimage1 != pimage2; ++pimage1)
    if (&(*pimage1)->getScreen() == &screen)
      return *pimage1;

  return 0;
}

CwmScreenImage::
CwmScreenImage(CwmScreen &screen, const CImagePtr &image) :
 screen_(screen), image_(image)
{
  CwmImage *image2 = new CwmImage(screen_, image_);

  images_.push_back(image2);
}

CwmScreenImage::
~CwmScreenImage()
{
  std::for_each(images_.begin(), images_.end(), CDeletePointer());
}

CwmImage *
CwmScreenImage::
getImage(int width, int height)
{
  if (width <= 0 || height <= 0)
    return images_[0];

  CwmImage *image1 = lookup(width, height);

  if (image1 == 0) {
    image1 = lookupBest(width, height);

    image1 = new CwmImage(screen_, image1->getImage(), width, height);

    images_.push_back(image1);
  }

  return image1;
}

CwmImage *
CwmScreenImage::
getTiledImage(int width, int height, int halign, int valign)
{
  CwmTiledImage *timage = lookupTiled(width, height, halign, valign);

  if (timage == 0) {
    timage = new CwmTiledImage(screen_, images_[0], width, height, halign, valign);

    tiled_images_.push_back(timage);
  }

  return timage->getImage();
}

CwmImage *
CwmScreenImage::
lookup(int width, int height)
{
  ImageList::const_iterator pimage1 = images_.begin();
  ImageList::const_iterator pimage2 = images_.end  ();

  for ( ; pimage1 != pimage2; ++pimage1)
    if ((*pimage1)->getWidth () == width &&
        (*pimage1)->getHeight() == height)
      return *pimage1;

  return 0;
}

CwmImage *
CwmScreenImage::
lookupBest(int width, int height)
{
  ImageList::const_iterator pimage1 = images_.begin();
  ImageList::const_iterator pimage2 = images_.end  ();

  if (pimage1 == pimage2)
    return 0;

  int dx = abs((*pimage1)->getWidth () - width );
  int dy = abs((*pimage1)->getHeight() - height);

  int       best_dxy   = dx*dx + dy*dy;
  CwmImage *best_image = *pimage1;

  while (pimage1 != pimage2) {
    dx = abs((*pimage1)->getWidth () - width );
    dy = abs((*pimage1)->getHeight() - height);

    int dxy = dx*dx + dy*dy;

    if (dxy < best_dxy) {
      best_dxy   = dxy;
      best_image = *pimage1;
    }

    ++pimage1;
  }

  return best_image;
}

CwmTiledImage *
CwmScreenImage::
lookupTiled(int width, int height, int halign, int valign)
{
  TiledImageList::const_iterator ptimage1 = tiled_images_.begin();
  TiledImageList::const_iterator ptimage2 = tiled_images_.end  ();

  for ( ; ptimage1 != ptimage2; ++ptimage1)
    if ((*ptimage1)->getWidth () == width  &&
        (*ptimage1)->getHeight() == height &&
        (*ptimage1)->getHAlign() == halign &&
        (*ptimage1)->getVAlign() == valign)
      return *ptimage1;

  return 0;
}

CwmTiledImage::
CwmTiledImage(CwmScreen &screen, CwmImage *image, int width, int height, int halign, int valign) :
 image_(image), width_(width), height_(height), halign_(halign), valign_(valign)
{
  CImagePtr cimage = image_->getImage();

  CHAlignType halign2;
  CVAlignType valign2;

  switch (halign) {
    case CHALIGN_TYPE_LEFT:
      halign2 = CHALIGN_TYPE_LEFT;
      break;
    case CHALIGN_TYPE_CENTER:
      halign2 = CHALIGN_TYPE_CENTER;
      break;
    default:
      halign2 = CHALIGN_TYPE_RIGHT;
      break;
  }

  switch (halign) {
    case CVALIGN_TYPE_TOP:
      valign2 = CVALIGN_TYPE_TOP;
      break;
    case CVALIGN_TYPE_CENTER:
      valign2 = CVALIGN_TYPE_CENTER;
      break;
    default:
      valign2 = CVALIGN_TYPE_BOTTOM;
      break;
  }

  CImageTile tile(halign2, valign2);

  CImagePtr cimage1 = cimage->tile(width, height, tile);

  image_ = new CwmImage(screen, cimage1);
}

CwmTiledImage::
~CwmTiledImage()
{
  delete image_;
}

//-----------------

CwmImage::
CwmImage(CwmScreen &screen, const CImagePtr &image) :
 screen_(screen), image_(image)
{
  width_  = image_->getWidth ();
  height_ = image_->getHeight();

  init();
}

CwmImage::
CwmImage(CwmScreen &screen, const CImagePtr &image, int width, int height) :
 screen_(screen), width_(width), height_(height)
{
  image_ = image->resize(width_, height_);

  init();
}

void
CwmImage::
init()
{
  pixmap_      = 0;
  pixmap_mask_ = 0;
}

CwmImage::
~CwmImage()
{
  delete pixmap_;
  delete pixmap_mask_;
}

void
CwmImage::
draw(CwmWindow *xwindow, CwmGraphics *graphics, int x, int y)
{
  if (pixmap_ == 0)
    createPixmap(graphics);

  if (pixmap_mask_ != 0)
    graphics->startClip(pixmap_mask_, x, y);

  graphics->copyArea(pixmap_, xwindow, 0, 0, width_, height_, x, y);

  if (pixmap_mask_ != 0)
    graphics->endClip();
}

void
CwmImage::
draw(CwmXPixmap *xpixmap, CwmGraphics *graphics, int x, int y)
{
  if (pixmap_ == 0)
    createPixmap(graphics);

  if (pixmap_mask_ != 0)
    graphics->startClip(pixmap_mask_, x, y);

  graphics->copyArea(pixmap_, xpixmap, 0, 0, width_, height_, x, y);

  if (pixmap_mask_ != 0)
    graphics->endClip();
}

bool
CwmImage::
isTransparent()
{
  return image_->isTransparent();
}

void
CwmImage::
createPixmap(CwmGraphics *graphics)
{
  pixmap_ = new CwmXPixmap(screen_, width_, height_);

  graphics->fillRectangle(pixmap_, 0, 0, width_, height_);

  CXScreen *cxscreen = screen_.getCXScreen();

  CXImage *ximage = image_.cast<CXImage>();

  if (ximage)
    ximage->draw(cxscreen, pixmap_->getXPixmap(), graphics->getGC(), 0, 0);

  pixmap_mask_ = createMask();
}

CwmXPixmap *
CwmImage::
createMask()
{
  CXScreen *cxscreen = screen_.getCXScreen();

  Pixmap mask_pixmap = cxscreen->createMask(image_);

  CwmXPixmap *xpixmap =
    new CwmXPixmap(screen_, mask_pixmap, width_, height_, 1);

  return xpixmap;
}
##concat##CwmInfo.cpp
#include <CwmI.h>
#include <CXtTimer.h>

class CwmInfoTimer : public CXtTimer {
 private:
  CwmInfo *info_;

 public:
  CwmInfoTimer(CwmInfo *info);

  void timeOut();
};

static const int CWM_INFO_TIMEOUT = 2000;

CwmInfo::
CwmInfo(CwmScreen &screen1) :
 screen(screen1), xwindow(None), graphics(0)
{
  init();
}

CwmInfo::
~CwmInfo()
{
  delete graphics;

  if (xwindow != None)
    delete xwindow;

  delete timer;
}

void
CwmInfo::
show(const std::string &str)
{
  hide();

  int x, y;

  screen.getRoot()->getPointerPosition(&x, &y);

  int width, height;

  graphics->getTextSize(str, &width, &height);

  width  += 8;
  height += 4;

  if (x + width > screen.getWidth())
    x = screen.getWidth() - width;

  if (y + height > screen.getHeight())
    y = screen.getHeight() - height;

  xwindow =
    new CwmWindow(screen, screen.getRoot(),
                  x, y - height, width, height,
                  0, CWM_CURSOR_TITLE);

  xwindow->setBackground(graphics);

  xwindow->mapRaised();

  graphics->drawTextCentered(xwindow,
                             2, 2, width - 4, height - 4,
                             str);

  graphics->drawButtonOut(xwindow,
                          0, 0, width, height,
                          1);

  timer = new CwmInfoTimer(this);
}

void
CwmInfo::
hide()
{
  delete timer;

  timer = 0;

  delete xwindow;

  xwindow = 0;
}

void
CwmInfo::
init()
{
  CwmColor *color = CwmResourceDataInst->getInfoColor(screen);
  CwmFont  *font  = CwmResourceDataInst->getInfoFont (screen);

  graphics = new CwmGraphics(screen, font, color);

  timer = 0;
}

void
CwmInfo::
timeOut()
{
  hide();
}

CwmInfoTimer::
CwmInfoTimer(CwmInfo *info) :
 CXtTimer(CWM_INFO_TIMEOUT, CTIMER_FLAGS_NO_DELETE), info_(info)
{
}

void
CwmInfoTimer::
timeOut()
{
  info_->timeOut();
}
##concat##CwmLog.cpp
#include <CwmI.h>
#include <COSTime.h>

CwmLog::
CwmLog() :
 fileName_("/usr/tmp/Cwm.log")
{
  setDir();

  fileName_ = dir_ + "/Cwm.log";

  if (! open()) {
    fileName_  = dir_ + "/Cwm_";
    fileName_ += COSTime::getTimeString("%Y_%m_%d_%H_%M_%S");
    fileName_ += ".log";

    open();
  }
}

CwmLog::
~CwmLog()
{
  delete file_;
}

bool
CwmLog::
open()
{
  if (! CFile::exists(fileName_) || CFile::isRegular(fileName_)) {
    file_ = new CFile(fileName_);

    file_->remove();

    return file_->open(CFile::APPEND);
  }
  else {
    file_ = 0;

    return false;
  }
}

void
CwmLog::
print(const std::string &msg)
{
  if (file_ != 0) {
    file_->write(COSTime::getTimeString() + ": " + msg);

    file_->flush();
  }
}

void
CwmLog::
setDir()
{
  dir_ = "/usr/tmp";

  if (! CFile::isDirectory(dir_)) {
    dir_ = "/tmp";

    if (! CFile::isDirectory(dir_))
      dir_ = ".";
  }
}
##concat##CwmMachine.cpp
#include <CwmI.h>
#include <CXMachine.h>
#include <CXtTimer.h>
#include <X11/XKBlib.h>

CwmMachine *
CwmMachine::
getInstance()
{
  static CwmMachine *instance;

  if (! instance)
    instance = new CwmMachine();

  return instance;
}

CwmMachine::
CwmMachine()
{
  init();
}

CwmMachine::
~CwmMachine()
{
  delete focus_mgr_;
  delete window_mgr_;
  delete screen_mgr_;

  delete debug_;
  delete log_;
}

void
CwmMachine::
init()
{
  grab_server_count_  = 0;
  grab_pointer_xwin_  = None;
  grab_keyboard_xwin_ = None;

  log_   = new CwmLog();
  debug_ = new CwmDebug();

  screen_mgr_ = new CwmScreenMgr();
  window_mgr_ = new CwmWMWindowMgr();

  CXMachineInst->setXErrorProc(&CwmMachine::logXError);

  focus_mgr_ = new CwmFocusMgr();
}

bool
CwmMachine::
init(const std::string &display_name)
{
  Display *display;

#ifdef CWM_USE_XT
  display = openXtDisplay(display_name);
#else
  display = CXMachineInst->openDisplay(display_name);
#endif

  if (display == 0)
    return false;

  return true;
}

Display *
CwmMachine::
openXtDisplay(const std::string &display_name)
{
  int    i;
  int    argc;
  char **argv;

  CwmInst->getArgs(&argc, &argv);

  char **argv1 = new char * [argc + 1];

  for (i = 0; i < argc; ++i)
    argv1[i] = strdup(argv[i]);
  argv1[i] = 0;

  Display *display =
    CXMachineInst->openXtDisplay(display_name, "Cwm", &argc, argv1);

  for (i = 0; i < argc; ++i)
    free((char *) argv1[i]);

  delete [] argv1;

  return display;
}

void
CwmMachine::
term()
{
  CwmGrabServer grab;

  window_mgr_->term();
  screen_mgr_->term();
}

string
CwmMachine::
getDisplayName() const
{
  return CXMachineInst->getDisplayName();
}

int
CwmMachine::
getNumScreens() const
{
  return CXMachineInst->getNumScreens();
}

CwmScreen &
CwmMachine::
getScreen(int screen_num)
{
  return screen_mgr_->getScreenByNum(screen_num);
}

CwmScreen &
CwmMachine::
getWindowScreen(Window xwin)
{
  return screen_mgr_->getScreenByWindow(xwin);
}

CwmWMWindow *
CwmMachine::
addWMWindow(CwmScreen &screen, Window xwin)
{
  return window_mgr_->addWindow(screen, xwin);
}

void
CwmMachine::
removeWMWindow(CwmWMWindow *window)
{
  window_mgr_->removeWindow(window);
}

CwmWMWindow *
CwmMachine::
getWindowWMWindow(CwmWindow *xwindow)
{
  Window xwin = xwindow->getXWin();

  return getWindowWMWindow(xwin);
}

CwmWMWindow *
CwmMachine::
getWindowWMWindow(Window xwin)
{
  return window_mgr_->lookupFromWindow(xwin);
}

CwmWMWindow *
CwmMachine::
getUserWindowWMWindow(CwmWindow *xwindow)
{
  Window xwin = xwindow->getXWin();

  return getUserWindowWMWindow(xwin);
}

CwmWMWindow *
CwmMachine::
getUserWindowWMWindow(Window xwin)
{
  return window_mgr_->lookupFromUserWindow(xwin);
}

void
CwmMachine::
addXWindow(CwmWindow *xwindow)
{
  cwm_xwindows_.push_back(xwindow);
}

void
CwmMachine::
removeXWindow(CwmWindow *xwindow)
{
  cwm_xwindows_.remove(xwindow);
}

CwmWindow *
CwmMachine::
getWindowCwmXWindow(Window xwin)
{
  XWindowList::const_iterator p1 = cwm_xwindows_.begin();
  XWindowList::const_iterator p2 = cwm_xwindows_.end  ();

  for ( ; p1 != p2; ++p1)
    if ((*p1)->getXWin() == xwin)
      return *p1;

  return 0;
}

bool
CwmMachine::
controlScreens()
{
  int num_screens = getNumScreens();

  for (int i = 0; i < num_screens; ++i) {
    CwmScreen &screen = getScreen(i);

    if (! screen.selectWMInput()) {
      log("Another WM is already running\n");
      return false;
    }
  }

  return true;
}

bool
CwmMachine::
isValidWindow(Window xwin)
{
  return CXMachineInst->isValidWindow(xwin);
}

Colormap
CwmMachine::
getColormap(int screen_num)
{
  return CXMachineInst->getColormap(screen_num);
}

int
CwmMachine::
getWidth(int screen_num)
{
  return CXMachineInst->getWidth(screen_num);
}

int
CwmMachine::
getHeight(int screen_num)
{
  return CXMachineInst->getHeight(screen_num);
}

int
CwmMachine::
getDepth(int screen_num)
{
  return CXMachineInst->getDepth(screen_num);
}

Pixel
CwmMachine::
getBlackPixel(int screen_num)
{
  return CXMachineInst->getBlackPixel(screen_num);
}

Pixel
CwmMachine::
getWhitePixel(int screen_num)
{
  return CXMachineInst->getWhitePixel(screen_num);
}

Window
CwmMachine::
getRoot()
{
  return CXMachineInst->getRoot();
}

Window
CwmMachine::
getRoot(int screen_num)
{
  return CXMachineInst->getRoot(screen_num);
}

Window
CwmMachine::
getWindowRoot(Window xwin)
{
  return CXMachineInst->getWindowRoot(xwin);
}

Window
CwmMachine::
getWindowTop(Window xwin)
{
  return CXMachineInst->getWindowTop(xwin);
}

Window
CwmMachine::
getWindowParent(Window xwin)
{
  return CXMachineInst->getWindowParent(xwin);
}

bool
CwmMachine::
getWindowChildren(Window xwin, Window **children, int *num_children)
{
  return CXMachineInst->getWindowChildren(xwin, children, num_children);
}

void
CwmMachine::
synchronize()
{
  CXMachineInst->synchronize();
}

void
CwmMachine::
grabServer()
{
  if (grab_server_count_ == 0) {
    screen_mgr_->disableScreens();

    CXMachineInst->grabServer();
  }

  ++grab_server_count_;
}

void
CwmMachine::
ungrabServer()
{
  --grab_server_count_;

  if (grab_server_count_ == 0) {
    CXMachineInst->ungrabServer();

    screen_mgr_->enableScreens();
  }
}

bool
CwmMachine::
eventPending()
{
  return CXMachineInst->eventPending();
}

void
CwmMachine::
nextEvent(XEvent *event)
{
  CXMachineInst->nextEvent();

  memcpy(event, CXMachineInst->getEvent(), sizeof(XEvent));
}

bool
CwmMachine::
flushEvents(bool sync)
{
  return CXMachineInst->flushEvents(sync);
}

bool
CwmMachine::
flushWindowEvent(Window xwin, int mask)
{
  return CXMachineInst->flushWindowEvent(xwin, mask);
}

int
CwmMachine::
flushWindowEvents(Window xwin, int mask)
{
  return CXMachineInst->flushWindowEvents(xwin, mask);
}

bool
CwmMachine::
checkWindowEvent(Window xwin, int mask, XEvent *event)
{
  return CXMachineInst->checkWindowEvent(xwin, mask, event);
}

bool
CwmMachine::
checkTypedEvent(int type, XEvent *event)
{
  return CXMachineInst->checkTypedEvent(type, event);
}

bool
CwmMachine::
checkWindowTypedEvent(Window xwin, int type, XEvent *event)
{
  return CXMachineInst->checkWindowTypedEvent(xwin, type, event);
}

void
CwmMachine::
maskEvent(uint mask, XEvent *event)
{
  CXMachineInst->maskEvent(mask, event);
}

void
CwmMachine::
allowEvents(int mode)
{
  CXMachineInst->allowEvents(mode);
}

Colormap
CwmMachine::
getWindowColormap(Window xwin)
{
  trapStart();

  Colormap cmap = CXMachineInst->getWindowColormap(xwin);

  if (! trapEnd())
    cmap = 0;

  return cmap;
}

int
CwmMachine::
getWindowEventMask(Window xwin)
{
  trapStart();

  int event_mask = CXMachineInst->getWindowEventMask(xwin);

  if (! trapEnd())
    event_mask = 0;

  return event_mask;
}

bool
CwmMachine::
getWindowViewable(Window xwin)
{
  return CXMachineInst->getWindowViewable(xwin);
}

void
CwmMachine::
getWindowGeometry(Window xwin, int *x, int *y,
                  int *width, int *height, int *border)
{
  trapStart();

  CXMachineInst->getWindowGeometry(xwin, x, y, width, height, border);

  if (! trapEnd()) {
    *x      = 0;
    *y      = 0;
    *width  = 1;
    *height = 1;
    *border = 1;
  }
}

int
CwmMachine::
getMulticlickTime()
{
  return CXMachineInst->getMulticlickTime();
}

void
CwmMachine::
setFocusWindow(CwmWMWindow *window)
{
  focus_mgr_->setFocusWindow(window);
}

void
CwmMachine::
resetFocusWindow()
{
  focus_mgr_->resetFocusWindow();
}

bool
CwmMachine::
isFocusWindow(CwmWMWindow *window)
{
  return focus_mgr_->isFocusWindow(window);
}

bool
CwmMachine::
isFocus(CwmWMWindow *window)
{
  return focus_mgr_->isUserWindow(window);
}

void
CwmMachine::
focusNext(CwmScreen &screen)
{
  focus_mgr_->focusNext(screen);
}

void
CwmMachine::
focusPrev(CwmScreen &screen)
{
  focus_mgr_->focusPrev(screen);
}

void
CwmMachine::
focusEnter(CwmWMWindow *window)
{
  focus_mgr_->enterUserWindow(window);
}

void
CwmMachine::
focusLeave(CwmWMWindow *window)
{
  focus_mgr_->leaveUserWindow(window);
}

void
CwmMachine::
setInputFocus(Window xwin)
{
  CXMachineInst->setInputFocus(xwin);

  if (xwin != 0) {
    int event_mask = EnterWindowMask | LeaveWindowMask |
                     ExposureMask    | FocusChangeMask;

    flushWindowEvents(xwin, event_mask);
  }
  else
    flushEvents();
}

void
CwmMachine::
resetInputFocus()
{
  setInputFocus(None);
}

bool
CwmMachine::
translateCoords(Window src_w, Window dest_w, int src_x, int src_y,
                int *dest_x, int *dest_y, Window *child)
{
  return CXMachineInst->translateCoords(src_w, dest_w, src_x, src_y,
                                        dest_x, dest_y, child);
}

bool
CwmMachine::
queryPointer(Window xwin, int *x, int *y)
{
  return CXMachineInst->queryPointer(xwin, x, y);
}

void
CwmMachine::
destroyWindow(Window xwin)
{
  CXMachineInst->destroyWindow(xwin);
}

void
CwmMachine::
mapWindow(Window xwin)
{
  CXMachineInst->mapWindow(xwin);
}

void
CwmMachine::
mapWindowRaised(Window xwin)
{
  CXMachineInst->mapWindowRaised(xwin);
}

void
CwmMachine::
mapWindowChildren(Window xwin)
{
  CXMachineInst->mapWindowChildren(xwin);
}

void
CwmMachine::
unmapWindow(Window xwin)
{
  CXMachineInst->unmapWindow(xwin);
}

void
CwmMachine::
reparentWindow(Window xwin, Window parent_xwin, int x, int y)
{
  CXMachineInst->reparentWindow(xwin, parent_xwin, x, y);
}

void
CwmMachine::
lowerWindow(Window xwin)
{
  CXMachineInst->lowerWindow(xwin);
}

void
CwmMachine::
raiseWindow(Window xwin)
{
  CXMachineInst->raiseWindow(xwin);
}

void
CwmMachine::
moveWindow(Window xwin, int x, int y)
{
  CXMachineInst->moveWindow(xwin, x, y);
}

void
CwmMachine::
resizeWindow(Window xwin, int width, int height)
{
  CXMachineInst->resizeWindow(xwin, width, height);
}

void
CwmMachine::
moveResizeWindow(Window xwin, int x, int y, int width, int height)
{
  CXMachineInst->moveResizeWindow(xwin, x, y, width, height);
}

void
CwmMachine::
clearWindow(Window xwin)
{
  CXMachineInst->clearWindow(xwin);
}

void
CwmMachine::
configureWindow(Window xwin, uint mask, XWindowChanges *xwc)
{
  CXMachineInst->configureWindow(xwin, mask, xwc);
}

void
CwmMachine::
restackWindows(Window *windows, int num_windows)
{
  CXMachineInst->restackWindows(windows, num_windows);
}

void
CwmMachine::
shapeCombineMask(Window xwin, Window mask, int x, int y, int op)
{
  CXMachineInst->shapeCombineMask(xwin, mask, x, y, op);
}

bool
CwmMachine::
grabPointer(Window xwin, uint event_mask, Cursor cursor)
{
  resetPointerGrabs();

  if (! CXMachineInst->grabPointer(xwin, event_mask, cursor)) {
    log("Grab Pointer Failed\n");
    return false;
  }

  grab_pointer_xwin_ = xwin;

  return true;
}

void
CwmMachine::
ungrabPointer()
{
  if (grab_pointer_xwin_ == None)
    log("No pointer grab in progress\n");

  CXMachineInst->ungrabPointer();

  grab_pointer_xwin_ = None;
}

bool
CwmMachine::
grabKeyboard(Window xwin)
{
  resetKeyboardGrabs();

  if (! CXMachineInst->grabKeyboard(xwin)) {
    log("Grab Keyboard Failed\n");
    return false;
  }

  grab_keyboard_xwin_ = xwin;

  return true;
}

void
CwmMachine::
ungrabKeyboard()
{
  if (grab_keyboard_xwin_ == None)
    log("No keyboard grab in progress\n");

  CXMachineInst->ungrabKeyboard();

  grab_keyboard_xwin_ = None;
}

void
CwmMachine::
grabKey(Window xwin, int keycode, int state)
{
  WindowKeyCodeStateTriplet triplet(xwin, keycode, state);

  if (grab_key_map_.find(triplet) != grab_key_map_.end()) {
    log("Key grab already in progress\n");
    ungrabKey(xwin, keycode, state);
  }

  CXMachineInst->grabKey(xwin, keycode, state);

  grab_key_map_[triplet] = 1;
}

void
CwmMachine::
ungrabKey(Window xwin, int keycode, int state)
{
  WindowKeyCodeStateTriplet triplet(xwin, keycode, state);

  if (grab_key_map_.find(triplet) == grab_key_map_.end()) {
    log("No key grab in progress\n");
    return;
  }

  CXMachineInst->ungrabKey(xwin, keycode, state);

  grab_key_map_.erase(grab_key_map_.find(triplet));
}

void
CwmMachine::
grabButton(Window xwin, int button, int modifiers,
           int event_mask, Cursor cursor)
{
  WindowButtonModifiersTriplet triplet(xwin, button, modifiers);

  if (grab_button_map_.find(triplet) != grab_button_map_.end()) {
    log("Button grab already in progress\n");
    ungrabButton(xwin, button, modifiers);
  }

  CXMachineInst->grabButton(xwin, button, modifiers, event_mask, cursor);

  grab_button_map_[triplet] = 1;
}

void
CwmMachine::
ungrabButton(Window xwin, int button, int modifiers)
{
  WindowButtonModifiersTriplet triplet(xwin, button, modifiers);

  if (grab_button_map_.find(triplet) == grab_button_map_.end()) {
    log("No button grab in progress\n");
    return;
  }

  CXMachineInst->ungrabButton(xwin, button, modifiers);

  grab_button_map_.erase(grab_button_map_.find(triplet));
}

Window
CwmMachine::
createWindow(int x, int y, int width, int height, int border,
             uint attr_mask, XSetWindowAttributes *attr)
{
  return CXMachineInst->createWindow(x, y, width, height, border,
                                     attr_mask, attr);
}

Window
CwmMachine::
createWindow(Window parent_xwin, int x, int y, int width, int height,
             int border, uint attr_mask, XSetWindowAttributes *attr)
{
  return CXMachineInst->createWindow(parent_xwin, x, y, width, height,
                                     border, attr_mask, attr);
}

Pixmap
CwmMachine::
createPixmap(uint width, uint height, uint depth)
{
  return CXMachineInst->createXPixmap(width, height, depth);
}

Pixmap
CwmMachine::
createPixmap(Window parent_xwin, uint width, uint height, uint depth)
{
  return CXMachineInst->createXPixmap(parent_xwin, width, height, depth);
}

void
CwmMachine::
freePixmap(Pixmap xpixmap)
{
  CXMachineInst->freeXPixmap(xpixmap);
}

void
CwmMachine::
setKeyAutoRepeatRate(uint timeout, uint interval)
{
  CXMachineInst->setKeyAutoRepeatRate(timeout, interval);
}

void
CwmMachine::
getKeyAutoRepeatRate(uint *timeout, uint *interval)
{
  CXMachineInst->getKeyAutoRepeatRate(timeout, interval);
}

void
CwmMachine::
installColormap(Colormap cmap)
{
  CXMachineInst->installColormap(cmap);
}

void
CwmMachine::
changeWindowAtributes(Window xwin, uint attr_mask,
                      XSetWindowAttributes *attr)
{
  CXMachineInst->changeWindowAtributes(xwin, attr_mask, attr);
}

void
CwmMachine::
killClient(Window xwin)
{
  CXMachineInst->killClient(xwin);
}

void
CwmMachine::
setIntegerProperty(Window xwin, const CXAtom &name, int value)
{
  CXMachineInst->setIntegerProperty(xwin, name, value);
}

void
CwmMachine::
setStringProperty(Window xwin, const CXAtom &name, const std::string &value)
{
  CXMachineInst->setStringProperty(xwin, name, value);
}

void
CwmMachine::
setWindowProperty(const CXAtom &name, Window value)
{
  CXMachineInst->setWindowProperty(getRoot(), name, value);
}

void
CwmMachine::
setWindowProperty(Window xwin, const CXAtom &name, Window value)
{
  CXMachineInst->setWindowProperty(xwin, name, value);
}

void
CwmMachine::
setWindowArrayProperty(Window xwin, const CXAtom &name,
                       Window *xwins, int num_xwins)
{
  CXMachineInst->setWindowArrayProperty(xwin, name, xwins, num_xwins);
}

void
CwmMachine::
setAtomArrayProperty(Window xwin, const CXAtom &name,
                     const CXAtom **atoms, int num_atoms)
{
  CXMachineInst->setAtomArrayProperty(xwin, name, atoms, num_atoms);
}

void
CwmMachine::
setStringListProperty(Window xwin, const CXAtom &name,
                      char **strs, int num_strs)
{
  CXMachineInst->setStringListProperty(xwin, name, strs, num_strs);
}

bool
CwmMachine::
getIntegerProperty(const CXAtom &name, int *value)
{
  return CXMachineInst->getIntegerProperty(name, value);
}

bool
CwmMachine::
getIntegerProperty(Window xwin, const CXAtom &name, int *value)
{
  return CXMachineInst->getIntegerProperty(xwin, name, value);
}

bool
CwmMachine::
getStringProperty(const CXAtom &name, std::string &value)
{
  return CXMachineInst->getStringProperty(name, value);
}

bool
CwmMachine::
getStringProperty(Window xwin, const CXAtom &name, std::string &value)
{
  return CXMachineInst->getStringProperty(xwin, name, value);
}

bool
CwmMachine::
getPixmapProperty(Window xwin, const CXAtom &name, Pixmap *value)
{
  return CXMachineInst->getPixmapProperty(xwin, name, value);
}

void
CwmMachine::
deleteProperty(Window xwin, const CXAtom &name)
{
  CXMachineInst->deleteProperty(xwin, name);
}

bool
CwmMachine::
isWMWindow(Window xwin)
{
  return CXMachineInst->isWMWindow(xwin);
}

void
CwmMachine::
setWMStateNormal(Window xwin)
{
  CXMachineInst->setWMStateNormal(xwin);
}

void
CwmMachine::
setWMStateIconic(Window xwin, Window icon_xwin)
{
  CXMachineInst->setWMStateIconic(xwin, icon_xwin);
}

bool
CwmMachine::
isWMStateNormal(Window xwin)
{
  return CXMachineInst->isWMStateNormal(xwin);
}

bool
CwmMachine::
isWMStateIconic(Window xwin)
{
  return CXMachineInst->isWMStateIconic(xwin);
}

void
CwmMachine::
getWMName(Window xwin, std::string &name)
{
  CXMachineInst->getWMName(xwin, name);
}

void
CwmMachine::
getWMIconName(Window xwin, std::string &name)
{
  CXMachineInst->getWMIconName(xwin, name);
}

void
CwmMachine::
getWMNormalHints(Window xwin, XSizeHints **size_hints, int *supplied)
{
  CXMachineInst->getWMNormalHints(xwin, size_hints, supplied);
}

void
CwmMachine::
getWMHints(Window xwin, XWMHints **wm_hints)
{
  CXMachineInst->getWMHints(xwin, wm_hints);
}

void
CwmMachine::
getWMTransientFor(Window xwin, Window *transient_xwin)
{
  CXMachineInst->getWMTransientFor(xwin, transient_xwin);
}

void
CwmMachine::
getWMClassHint(Window xwin, XClassHint **class_hint)
{
  CXMachineInst->getWMClassHint(xwin, class_hint);
}

void
CwmMachine::
getWMClientMachine(Window xwin, std::string &client_machine)
{
  CXMachineInst->getWMClientMachine(xwin, client_machine);
}

void
CwmMachine::
getWMCommand(Window xwin, int *argc, char ***argv)
{
  CXMachineInst->getWMCommand(xwin, argc, argv);
}

void
CwmMachine::
getWMColormapWindows(Window xwin, Window **cmap_windows,
                     int *num_cmap_windows)
{
  CXMachineInst->getWMColormapWindows(xwin, cmap_windows, num_cmap_windows);
}

void
CwmMachine::
getWMProtocols(Window xwin, const CXAtom ***protocols, int *num_protocols)
{
  CXMachineInst->getWMProtocols(xwin, protocols, num_protocols);
}

Window
CwmMachine::
getWMIconWindowHint(Window xwin)
{
  return CXMachineInst->getWMIconWindowHint(xwin);
}

bool
CwmMachine::
getWMMwmHints(Window xwin, MotifWmHints **mwm_hints)
{
  return CXMachineInst->getWMMwmHints(xwin, mwm_hints);
}

const CXAtom &
CwmMachine::
getWMProtocolsAtom()
{
  return CXMachineInst->getWMProtocolsAtom();
}

const CXAtom &
CwmMachine::
getWMDeleteWindowAtom()
{
  return CXMachineInst->getWMDeleteWindowAtom();
}

const CXAtom &
CwmMachine::
getXSetRootIdAtom()
{
  return CXMachineInst->getXSetRootIdAtom();
}

const CXAtom &
CwmMachine::
getCwmDesktopAtom()
{
  return CXMachineInst->getCwmDesktopAtom();
}

bool
CwmMachine::
isWMChangeStateAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMChangeStateAtom(atom);
}

bool
CwmMachine::
isWMClassAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMClassAtom(atom);
}

bool
CwmMachine::
isWMClientMachineAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMClientMachineAtom(atom);
}

bool
CwmMachine::
isWMCommandAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMCommandAtom(atom);
}

bool
CwmMachine::
isWMDeleteWindowAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMDeleteWindowAtom(atom);
}

bool
CwmMachine::
isWMHintsAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMHintsAtom(atom);
}

bool
CwmMachine::
isWMIconNameAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMIconNameAtom(atom);
}

bool
CwmMachine::
isWMNameAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMNameAtom(atom);
}

bool
CwmMachine::
isWMNormalHintsAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMNormalHintsAtom(atom);
}

bool
CwmMachine::
isWMProtocolsAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMProtocolsAtom(atom);
}

bool
CwmMachine::
isWMSaveYourselfAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMSaveYourselfAtom(atom);
}

bool
CwmMachine::
isWMSizeHintsAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMSizeHintsAtom(atom);
}

bool
CwmMachine::
isWMStateAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMStateAtom(atom);
}

bool
CwmMachine::
isWMTakeFocusAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMTakeFocusAtom(atom);
}

bool
CwmMachine::
isWMTransientForAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMTransientForAtom(atom);
}

bool
CwmMachine::
isWMZoomHintsAtom(const CXAtom &atom)
{
  return CXMachineInst->isWMZoomHintsAtom(atom);
}

bool
CwmMachine::
sendKeyPressedEvent(Window xwin, int x, int y, int keycode)
{
  return CXMachineInst->sendKeyPressedEvent(xwin, x, y, keycode);
}

bool
CwmMachine::
sendKeyReleasedEvent(Window xwin, int x, int y, int keycode)
{
  return CXMachineInst->sendKeyReleasedEvent(xwin, x, y, keycode);
}

bool
CwmMachine::
sendEvent(Window xwin, int propagate, XEvent *event, int event_mask)
{
  if (! CXMachineInst->sendEvent(xwin, propagate, event, event_mask)) {
    log("Send Event Failed\n");
    return false;
  }

  return true;
}

bool
CwmMachine::
sendConfigureNotifyEvent(Window xwin, int x, int y, int width, int height,
                         int border, Window above_xwin)
{
  return CXMachineInst->sendConfigureNotifyEvent(xwin, x, y, width, height,
                                                 border, above_xwin);
}

void
CwmMachine::
selectInput(Window xwin, int event_mask)
{
  CXMachineInst->selectInput(xwin, event_mask);
}

void
CwmMachine::
setWindowBackgroundColor(Window xwin, Pixel bg)
{
  CXMachineInst->setWindowBackgroundColor(xwin, bg);
}

void
CwmMachine::
setWindowBackgroundPixmap(Window xwin, Pixmap pixmap)
{
  CXMachineInst->setWindowBackgroundPixmap(xwin, pixmap);
}

void
CwmMachine::
setWindowBorderWidth(Window xwin, int width)
{
  CXMachineInst->setWindowBorderWidth(xwin, width);
}

void
CwmMachine::
warpPointer(Window xwin, int x, int y)
{
  CXMachineInst->warpPointer(xwin, x, y);
}

void
CwmMachine::
addToSaveSet(Window xwin)
{
  CXMachineInst->addToSaveSet(xwin);
}

void
CwmMachine::
removeFromSaveSet(Window xwin)
{
  CXMachineInst->removeFromSaveSet(xwin);
}

GC
CwmMachine::
createGC(Pixel fg, Pixel bg)
{
  return CXMachineInst->createGC(fg, bg);
}

GC
CwmMachine::
createGC(Window xwin, Pixel fg, Pixel bg)
{
  return CXMachineInst->createGC(xwin, fg, bg);
}

GC
CwmMachine::
createXorGC()
{
  return CXMachineInst->createXorGC();
}

GC
CwmMachine::
createXorGC(Window xwin)
{
  return CXMachineInst->createXorGC(xwin);
}

void
CwmMachine::
freeGC(GC gc)
{
  return CXMachineInst->freeGC(gc);
}

void
CwmMachine::
setFillStipple(GC gc, Pixmap pixmap)
{
  return CXMachineInst->setFillStipple(gc, pixmap);
}

void
CwmMachine::
setForeground(GC gc, Pixel pixel)
{
  CXMachineInst->setForeground(gc, pixel);
}

void
CwmMachine::
setBackground(GC gc, Pixel pixel)
{
  CXMachineInst->setBackground(gc, pixel);
}

void
CwmMachine::
startRectClip(GC gc, int x, int y, int width, int height)
{
  CXMachineInst->startRectClip(gc, x, y, width, height);
}

void
CwmMachine::
startPixmapClip(GC gc, Pixmap xpixmap, int dx, int dy)
{
  CXMachineInst->startPixmapClip(gc, xpixmap, dx, dy);
}

void
CwmMachine::
endPixmapClip(GC gc)
{
  CXMachineInst->endPixmapClip(gc);
}

void
CwmMachine::
drawLine(Window xwin, GC gc, int x1, int y1, int x2, int y2)
{
  CXMachineInst->drawLine(xwin, gc, x1, y1, x2, y2);
}

void
CwmMachine::
drawRectangle(Window xwin, GC gc, int x, int y, int width, int height)
{
  CXMachineInst->drawRectangle(xwin, gc, x, y, width, height);
}

void
CwmMachine::
fillRectangle(Window xwin, GC gc, int x, int y, int width, int height)
{
  CXMachineInst->fillRectangle(xwin, gc, x, y, width, height);
}

void
CwmMachine::
drawPoint(Window xwin, GC gc, int x, int y)
{
  CXMachineInst->drawPoint(xwin, gc, x, y);
}

void
CwmMachine::
copyArea(Window src_xwin, Window dest_xwin, GC gc, int src_x, int src_y,
         int src_width, int src_height, int desy_x, int desy_y)
{
  CXMachineInst->copyArea(src_xwin, dest_xwin, gc, src_x, src_y,
                          src_width, src_height, desy_x, desy_y);
}

void
CwmMachine::
copyPlanes(Window src_xwin, int src_depth, Window dest_xwin, int dest_depth,
           GC gc, int src_x, int src_y, int src_width, int src_height,
           int desy_x, int desy_y)
{
  CXMachineInst->copyPlanes(src_xwin, src_depth, dest_xwin, dest_depth,
                            gc, src_x, src_y, src_width, src_height,
                            desy_x, desy_y);
}

Pixmap
CwmMachine::
createStipplePixmap()
{
  return CXMachineInst->createStipplePixmap();
}

CwmXPixmap *
CwmMachine::
createStippleCwmXPixmap(CwmScreen &screen)
{
  Pixmap bitmap = createStipplePixmap();

  CwmXPixmap *xpixmap = new CwmXPixmap(screen, bitmap, 2, 2);

  return xpixmap;
}

const CXAtom &
CwmMachine::
getAtom(const std::string &name)
{
  return CXMachineInst->getAtom(name);
}

const CXAtom &
CwmMachine::
getAtom(Atom atom)
{
  return CXMachineInst->getAtom(atom);
}

uint
CwmMachine::
keysymToKeycode(KeySym keysym)
{
  return CXMachineInst->keysymToKeycode(keysym);
}

Window
CwmMachine::
getEventWindow(XEvent *event)
{
  return CXMachineInst->getEventWindow(event);
}

string
CwmMachine::
getEventName(XEvent *event)
{
  return CXMachineInst->getEventName(event);
}

Time
CwmMachine::
getEventTime(XEvent *event)
{
  return CXMachineInst->getEventTime(event);
}

bool
CwmMachine::
sendIntegerServerMessage(Window client_xwin, Window server_xwin,
                         int value)
{
  return sendStringServerMessage(client_xwin, server_xwin,
                                 CStrUtil::toString(value));
}

bool
CwmMachine::
sendStringServerMessage(Window client_xwin, Window server_xwin,
                        const std::string &value)
{
  return CXMachineInst->sendStringServerMessage
          (client_xwin, server_xwin, value);
}

bool
CwmMachine::
readStringClientMessage(Window server_xwin, Window *client_xwin,
                        std::string &value)
{
  return CXMachineInst->readStringClientMessage
          (server_xwin, client_xwin, value);
}

void
CwmMachine::
trapStart()
{
  CXMachineInst->trapStart();
}

bool
CwmMachine::
trapEnd()
{
  return CXMachineInst->trapEnd();
}

void
CwmMachine::
logXError(const std::string &msg)
{
  CwmMachineInst->logf("%s\n", msg.c_str());
}

void
CwmMachine::
log(const std::string &str)
{
  log_->print(str);
}

void
CwmMachine::
logf(const char *format, ...)
{
  va_list vargs;

  va_start(vargs, format);

  log_->print(CStrUtil::vstrprintf(format, &vargs));

  va_end(vargs);
}

void
CwmMachine::
setDebug(bool flag)
{
  debug_->setDebug(flag);
}

bool
CwmMachine::
getDebug()
{
  return debug_->getDebug();
}

void
CwmMachine::
debug(const std::string &str)
{
  debug_->print(str);
}

void
CwmMachine::
debugf(const char *format, ...)
{
  va_list vargs;

  va_start(vargs, format);

  debug_->print(CStrUtil::vstrprintf(format, &vargs));

  va_end(vargs);
}

void
CwmMachine::
resetGrabs()
{
  resetPointerGrabs();

  resetKeyboardGrabs();
}

void
CwmMachine::
resetPointerGrabs()
{
  if (grab_pointer_xwin_ != None) {
    log("Pointer Grab already in progress\n");
    ungrabPointer();
  }
}

void
CwmMachine::
resetKeyboardGrabs()
{
  if (grab_keyboard_xwin_ != None) {
    log("Keyboard grab already in progress\n");
    ungrabKeyboard();
  }
}
##concat##CwmMailMgr.cpp
#include <CwmI.h>
#include <CXtTimer.h>
#include <sys/stat.h>

class CwmMailMgrTimer : public CXtTimer {
 private:
  enum { MAIL_TIMEOUT = 30000 };

  CwmMailMgr *mgr_;

 public:
  CwmMailMgrTimer(CwmMailMgr *mgr);

  void timeOut();
};

CwmMailMgr::
CwmMailMgr()
{
  initialized_ = false;
  last_error_  = 0;
  timer_       = 0;
}

CwmMailMgr::
~CwmMailMgr()
{
  delete timer_;
}

CwmMailMgr *
CwmMailMgr::
getInstance()
{
  static CwmMailMgr *instance;

  if (! instance)
    instance = new CwmMailMgr();

  return instance;
}

bool
CwmMailMgr::
isMailWindow(CwmWMWindow *window)
{
  init();

  std::string res_name = window->getResName();

  return (res_name != "" && res_name.find("mail") != string::npos);
}

void
CwmMailMgr::
addMailWindow(CwmWMWindow *window)
{
  init();

  mail_windows_.push_back(window);
}

void
CwmMailMgr::
deleteMailWindow(CwmWMWindow *window)
{
  init();

  mail_windows_.remove(window);
}

void
CwmMailMgr::
init()
{
  if (initialized_)
    return;

  std::string value = (getenv("MAIL") ? getenv("MAIL") : "");

  if (! value.empty()) {
    dir_ = value;

    last_error_ = stat(dir_.c_str(), &last_stat_);

    timer_ = new CwmMailMgrTimer(this);

    initialized_ = true;
  }
}

void
CwmMailMgr::
timeOut()
{
  struct stat this_stat;

  int this_error = stat(dir_.c_str(), &this_stat);

  if (this_error == 0 && last_error_ == 0 &&
      this_stat.st_ctime != last_stat_.st_ctime &&
      this_stat.st_size  >  last_stat_.st_size) {
    WMWindowList::const_iterator pwindow1 = mail_windows_.begin();
    WMWindowList::const_iterator pwindow2 = mail_windows_.end  ();

    for ( ; pwindow1 != pwindow2; ++pwindow1) {
      (*pwindow1)->restore();

      (*pwindow1)->raise();
    }
  }

  memcpy(&last_stat_, &this_stat, sizeof(struct stat));

  last_error_ = this_error;
}

CwmMailMgrTimer::
CwmMailMgrTimer(CwmMailMgr *mgr) :
 CXtTimer(MAIL_TIMEOUT, CTIMER_FLAGS_REPEAT), mgr_(mgr)
{
}

void
CwmMailMgrTimer::
timeOut()
{
  mgr_->timeOut();
}
##concat##CwmMain.cpp
#include <CwmI.h>

int
main(int argc, char **argv)
{
  CwmInst->init(argc, argv);

  exit(0);
}
##concat##CwmMask.cpp
#include <CwmI.h>

CwmMask::
CwmMask(CwmScreen &screen, CwmGraphics *graphics, int width, int height) :
 screen_(screen), width_(width), height_(height)
{
  xpixmap_ = new CwmXPixmap(screen_, width_, height_, 1);

  graphics_ = new CwmGraphics(*xpixmap_, graphics->getFont(), 0);

  graphics_->setForeground(0);

  graphics_->fillRectangle(xpixmap_, 0, 0, width_, height_);

  graphics_->setForeground(1);
}

CwmMask::
~CwmMask()
{
  delete xpixmap_;

  delete graphics_;
}

void
CwmMask::
drawString(int x, int y, const std::string &str)
{
  CwmFont *font = graphics_->getFont();

  font->drawString(xpixmap_, graphics_, x, y, str);
}

void
CwmMask::
combine(CwmWindow *xwindow, int x, int y, int op)
{
  CwmMachineInst->shapeCombineMask(xwindow->getXWin(), xpixmap_->getXPixmap(), x, y, op);
}
##concat##CwmMenu.cpp
#include <CwmI.h>

typedef void (*CwmMenuKeyProc) (CwmMenu *);

class CwmMenuKeyData {
 private:
  std::string          key_;
  CwmMenuKeyProc  proc_;
  CXNamedEvent   *event_;

  static CwmMenuKeyData menu_key_data_[];

 public:
  static CwmMenuKeyData *getKeyData(XKeyPressedEvent *event);

  CwmMenuKeyData(const std::string &key1, CwmMenuKeyProc proc1);
 ~CwmMenuKeyData();

  void init();

  void invoke(CwmMenu *menu);
};

CwmMenuKeyData
CwmMenuKeyData::menu_key_data_[] = {
  CwmMenuKeyData("<Key>Up"    , &CwmMenu::prevItemProc    ),
  CwmMenuKeyData("<Key>Down"  , &CwmMenu::nextItemProc    ),
  CwmMenuKeyData("<Key>Left"  , &CwmMenu::endCascadeProc  ),
  CwmMenuKeyData("<Key>Right" , &CwmMenu::startCascadeProc),
  CwmMenuKeyData("<Key>Return", &CwmMenu::acceptItemProc  ),
  CwmMenuKeyData("<Key>space" , &CwmMenu::acceptItemProc  ),
  CwmMenuKeyData("<Key>Escape", &CwmMenu::endMenuProc     ),
  CwmMenuKeyData(""           , 0                      ),
};

bool         CwmMenu::menu_stay_up_  = false;
bool         CwmMenu::button_down_   = false;
CwmMenuItem *CwmMenu::selected_item_ = 0;
CwmMenu     *CwmMenu::last_menu_     = 0;

CwmMenuKeyData::
CwmMenuKeyData(const std::string &key, CwmMenuKeyProc proc) :
 key_(key), proc_(proc), event_(0)
{
}

CwmMenuKeyData::
~CwmMenuKeyData()
{
  delete event_;
}

void
CwmMenuKeyData::
init()
{
  if (event_ == 0 && key_ != "")
    event_ = new CXNamedEvent(key_);
}

CwmMenuKeyData *
CwmMenuKeyData::
getKeyData(XKeyPressedEvent *event)
{
  XEvent *event1 = (XEvent *) event;

  for (int i = 0; menu_key_data_[i].key_ != ""; i++) {
    menu_key_data_[i].init();

    if (menu_key_data_[i].event_ == 0)
      continue;

    if (menu_key_data_[i].event_->matchEvent(event1))
      return &menu_key_data_[i];
  }

  return 0;
}

void
CwmMenuKeyData::
invoke(CwmMenu *menu)
{
  if (proc_ != 0)
    proc_(menu);
}

CwmMenuDef::
CwmMenuDef()
{
}

CwmMenuDef::
CwmMenuDef(const CwmMenuDef &menu_def)
{
  MenuEntryList::const_iterator pentry1 = menu_def.entries_.begin();
  MenuEntryList::const_iterator pentry2 = menu_def.entries_.end  ();

  for ( ; pentry1 != pentry2; ++pentry1) {
    CwmMenuEntry *entry = new CwmMenuEntry(**pentry1);

    addEntry(entry);
  }
}

CwmMenuDef::
~CwmMenuDef()
{
  std::for_each(entries_.begin(), entries_.end(), CDeletePointer());
}

void
CwmMenuDef::
addTitle(const std::string &text)
{
  CwmMenuTitleEntry *entry = new CwmMenuTitleEntry(text);

  addEntry(entry);
}

void
CwmMenuDef::
addButton(const std::string &image, const std::string &text, int mnemonic,
          const std::string &accelerator, CwmMenuProc proc, CwmData data1, CwmData data2,
          CwmData data3, CwmData data4, CwmData data5, CwmData data6)
{
  CwmMenuButtonEntry *entry =
    new CwmMenuButtonEntry(image, text, mnemonic, accelerator, proc,
                           data1, data2, data3, data4, data5, data6);

  addEntry(entry);
}

void
CwmMenuDef::
addToggle(const std::string &image, const std::string &text, int mnemonic,
          const std::string &accelerator, CwmMenuProc proc, CwmData data1, CwmData data2,
          CwmData data3, CwmData data4, CwmData data5, CwmData data6)
{
  CwmMenuToggleEntry *entry =
    new CwmMenuToggleEntry(image, text, mnemonic, accelerator, proc,
                           data1, data2, data3, data4, data5, data6);

  addEntry(entry);
}

void
CwmMenuDef::
addSplitter(const std::string &text)
{
  CwmMenuSplitterEntry *entry = new CwmMenuSplitterEntry(text);

  addEntry(entry);
}

void
CwmMenuDef::
addCascade(const std::string &text, CwmMenuDef *menu_def)
{
  CwmMenuCascadeEntry *entry = new CwmMenuCascadeEntry(text, menu_def);

  addEntry(entry);
}

void
CwmMenuDef::
addEntry(CwmMenuEntry *entry)
{
  entries_.push_back(entry);
}

void
CwmMenuDef::
setClientData(CwmScreen *screen, CwmWMWindow *window, CwmDeskIcon *icon)
{
  MenuEntryList::const_iterator pentry1 = entries_.begin();
  MenuEntryList::const_iterator pentry2 = entries_.end  ();

  for ( ; pentry1 != pentry2; ++pentry1)
    (*pentry1)->setClientData(screen, window, icon);
}

int
CwmMenuDef::
getSize()
{
  return entries_.size();
}

CwmMenuEntry *
CwmMenuDef::
getEntry(int i)
{
  if (i < 0 || i >= (int) entries_.size())
    throw "Invalid Menu Def Index";

  return entries_[i];
}

CwmMenuEntry::
CwmMenuEntry(CwmMenuItemType type, const std::string &image, const std::string &text,
             int mnemonic, const std::string &accelerator, CwmMenuProc proc, CwmData data1,
             CwmData data2, CwmData data3, CwmData data4, CwmData data5, CwmData data6) :
 type_(type), image_(image), text_(text), mnemonic_(mnemonic),
 accelerator_(accelerator), proc_(proc), data1_(data1), data2_(data2),
 data3_(data3), data4_(data4), data5_(data5), data6_(data6), selected_(false)
{
}

CwmMenuEntry::
CwmMenuEntry(const CwmMenuEntry &entry)
{
  type_        = entry.type_;
  image_       = entry.image_;
  text_        = entry.text_;
  mnemonic_    = entry.mnemonic_;
  accelerator_ = entry.accelerator_;
  proc_        = entry.proc_;
  data1_       = entry.data1_;
  data2_       = entry.data2_;
  data3_       = entry.data3_;
  data4_       = entry.data4_;
  data5_       = entry.data5_;
  data6_       = entry.data6_;
  selected_    = false;

  if (type_ == CWM_MENU_CASCADE_TYPE) {
    CwmMenuDef *menu_def = (CwmMenuDef *) entry.data1_;

    data1_ = (CwmData ) new CwmMenuDef(*menu_def);
  }
}

CwmMenuEntry::
~CwmMenuEntry()
{
  if (type_ == CWM_MENU_CASCADE_TYPE) {
    CwmMenuDef *menu_def = (CwmMenuDef *) data1_;

    delete menu_def;
  }
}

void
CwmMenuEntry::
setClientData(CwmScreen *screen, CwmWMWindow *window, CwmDeskIcon *icon)
{
  if      (type_ == CWM_MENU_BUTTON_TYPE) {
    if (proc_ == (CwmMenuProc) CwmFunctionDef::processProc) {
      CwmFunctionDef *function = (CwmFunctionDef *) data1_;

      function->setObjects(screen, window, icon);
    }
  }
  else if (type_ == CWM_MENU_TOGGLE_TYPE) {
    if (proc_ == (CwmMenuProc) CwmFunctionDef::processProc) {
      CwmFunctionDef *function = (CwmFunctionDef *) data1_;

      function->setObjects(screen, window, icon);
    }
  }
  else if (type_ == CWM_MENU_CASCADE_TYPE) {
    CwmMenuDef *menu_def = (CwmMenuDef *) data1_;

    menu_def->setClientData(screen, window, icon);
  }
}

void
CwmMenu::
processNamedMenu(CwmScreen &screen, const std::string &name)
{
  CwmMenuDef *menu_def = CwmNamedMenuMgrInst->lookupMenuDef(name);

  if (menu_def == 0) {
    CwmMachineInst->logf("Named Menu %s not found\n", name.c_str());
    return;
  }

  menu_def->setClientData(&screen, 0, 0);

  processWindowMenu(screen, screen.getRoot(), menu_def);
}

void
CwmMenu::
processNamedMenu(CwmWMWindow *window, const std::string &name)
{
  CwmMenuDef *menu_def = CwmNamedMenuMgrInst->lookupMenuDef(name);

  if (menu_def == 0) {
    CwmMachineInst->logf("Named Menu %s not found\n", name.c_str());
    return;
  }

  CwmScreen &screen = window->getScreen();

  screen.uninstallColormap();

  menu_def->setClientData(0, window, 0);

  processWindowMenu(screen, window->getFrameWindow(), menu_def);

  screen.installColormap(window);
}

void
CwmMenu::
processMenu(CwmDeskIcon *icon, CwmMenuDef *menu_def)
{
  menu_def->setClientData(0, 0, icon);

  processWindowMenu(icon->getScreen(), icon->getXWindow(), menu_def);
}

void
CwmMenu::
processWindowMenu(CwmScreen &screen, CwmWindow *xwindow, CwmMenuDef *menu_def,
                  CHAlignType halign, CVAlignType valign)
{
  int x, y;

  xwindow->getPointerPosition(&x, &y);

  processWindowMenu1(screen, xwindow, menu_def, x, y, halign, valign);
}

void
CwmMenu::
processWindowMenu(CwmScreen &screen, CwmWindow *xwindow, CwmMenuDef *menu_def,
                  int x, int y, CHAlignType halign, CVAlignType valign)
{
  int root_x, root_y;

  xwindow->coordsToRoot(x, y, &root_x, &root_y);

  processWindowMenu1(screen, xwindow, menu_def, root_x, root_y, halign, valign);
}

void
CwmMenu::
processWindowMenu1(CwmScreen &screen, CwmWindow *xwindow, CwmMenuDef *menu_def,
                   int x, int y, CHAlignType halign, CVAlignType valign)
{
//if (last_menu_ != 0) {
//  delete last_menu_;
//
//  last_menu_ = 0;
//}

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask;

  if (! xwindow->grab(event_mask, CWM_CURSOR_SELECT))
    return;

  CwmMenu *menu = new CwmMenu(screen, 0, menu_def, x, y, halign, valign);

  menu->map();

  menu->redraw();

  CwmMachineInst->flushEvents();

  selected_item_ = 0;

  int last_event_type = CwmEventMgrInst->getLastEventType();

  XEvent *event;

  if (last_event_type == ButtonPress) {
    menu_stay_up_ = false;

    Time start_time = CwmEventMgrInst->getLastEventTime();
    Time end_time   = start_time;

    while ((end_time - start_time) < 200000 &&
           CwmEventMgrInst->eventPending()) {
      event = CwmEventMgrInst->processNextEvent();

      if (event->type == ButtonRelease) {
        menu_stay_up_ = true;
        break;
      }

      CwmEventMgrInst->processEvent(event);

      end_time = CwmEventMgrInst->getLastEventTime();
    }
  }
  else
    menu_stay_up_ = true;

  int          i;
  CwmMenuItem *menu_item;

  if (menu_stay_up_) {
    menu->nextItem();

    button_down_ = false;

    while (menu->isActive()) {
      while (button_down_ && menu->isActive() &&
             menu->current_ != 0 && menu->current_->isCascadeMenu())
        menu->current_->processCascadeMenu(menu);

      if (! menu->isActive())
        break;

      event = CwmEventMgrInst->processNextEvent();

      if      (event->type == ButtonPress) {
        if (event->xbutton.button != 1 &&
            event->xbutton.button != 3)
          continue;

        Window event_window = CwmMachineInst->getEventWindow(event);

        menu_item = menu->getMenuItemForWindow(event_window);

        if (menu->current_ != 0)
          menu->current_->leave();

        if (menu_item != 0)
          menu_item->enter();

        selected_item_ = menu_item;

        button_down_ = true;
      }
      else if (event->type == ButtonRelease) {
        menu->complete();

        button_down_ = false;
      }
      else if (event->type == EnterNotify) {
        if (button_down_) {
          Window event_window = CwmMachineInst->getEventWindow(event);

          menu_item = menu->getMenuItemForWindow(event_window);

          if (menu_item != 0)
            menu_item->enter();

          if (menu_item != 0 && ! menu_item->isCascadeMenu())
            selected_item_ = menu_item;
        }
      }
      else if (event->type == LeaveNotify) {
        if (button_down_) {
          Window event_window = CwmMachineInst->getEventWindow(event);

          menu_item = menu->getMenuItemForWindow(event_window);

          if (menu_item != 0)
            menu_item->leave();

          selected_item_ = 0;
        }
      }
      else if (event->type == KeyPress) {
        XKeyPressedEvent *event1 = (XKeyPressedEvent *) event;

        if (CwmXEventInst->isEscapeKeyEvent(event1))
          menu->complete();

        CwmMenuKeyData *key_data = CwmMenuKeyData::getKeyData(event1);

        if (key_data != 0) {
          key_data->invoke(menu);
          continue;
        }

        for (i = 0; i < menu->num_items_; i++) {
          if (menu->items_[i]->isMnemonicEvent(event1))
            break;

          if (menu->items_[i]->isAcceleratorEvent(event1))
            break;
        }

        if (i < menu->num_items_) {
          selected_item_ = menu->items_[i];

          menu->complete();
        }
      }
      else if (event->type == KeyRelease) {
        XKeyReleasedEvent *event1 = (XKeyReleasedEvent *) event;

        if (CwmXEventInst->isEscapeKeyEvent(event1))
          menu->complete();
      }
      else {
        CwmMachineInst->logf("Unhandled event %d\n", event->type);
      }
    }
  }
  else {
    menu_stay_up_ = false;

    while (menu->isActive()) {
      event = CwmEventMgrInst->processNextEvent();

      if      (event->type == ButtonPress) {
        if (event->xbutton.button != 1 &&
            event->xbutton.button != 3)
          continue;

        Window event_window = CwmMachineInst->getEventWindow(event);

        menu_item = menu->getMenuItemForWindow(event_window);

        selected_item_ = menu_item;

        menu->complete();
      }
      else if (event->type == ButtonRelease) {
        menu->complete();
      }
      else if (event->type == EnterNotify) {
        Window event_window = CwmMachineInst->getEventWindow(event);

        menu_item = menu->getMenuItemForWindow(event_window);

        if (menu_item != 0)
          menu_item->enter();

        if (menu_item != 0 && ! menu_item->isCascadeMenu())
          selected_item_ = menu_item;
      }
      else if (event->type == LeaveNotify) {
        Window event_window = CwmMachineInst->getEventWindow(event);

        menu_item = menu->getMenuItemForWindow(event_window);

        if (menu_item != 0)
          menu_item->leave();

        selected_item_ = 0;
      }
      else if (event->type == KeyPress) {
        XKeyPressedEvent *event1 = (XKeyPressedEvent *) event;

        if (CwmXEventInst->isEscapeKeyEvent(event1))
          menu->complete();
      }
      else if (event->type == KeyRelease) {
        XKeyReleasedEvent *event1 = (XKeyReleasedEvent *) event;

        if (CwmXEventInst->isEscapeKeyEvent(event1))
          menu->complete();
      }
      else {
        CwmMachineInst->logf("Unhandled event %d\n", event->type);
      }

      if (menu->cascade_ != 0) {
        if      (menu->cascade_->isCompleted())
          menu->complete();
        else if (menu->cascade_->isInactive())
          menu->cascade_ = 0;
      }

      while (menu->isActive() &&
             menu->current_ != 0 && menu->current_->isCascadeMenu())
        menu->current_->processCascadeMenu(menu);
    }
  }

  xwindow->ungrab();

  CwmIdleInst->disable();

  menu->unmap();

  CwmMachineInst->flushEvents();

  if (selected_item_ != 0)
    selected_item_->select();

  CwmIdleInst->enable();

  delete selected_item_;

  selected_item_ = 0;

  last_menu_ = menu;
}

void
CwmMenu::
nextItemProc(CwmMenu *menu)
{
  menu->nextItem();
}

void
CwmMenu::
prevItemProc(CwmMenu *menu)
{
  menu->prevItem();
}

void
CwmMenu::
startCascadeProc(CwmMenu *menu)
{
  if (menu->current_ != 0 && menu->current_->isCascadeMenu())
    menu->current_->processCascadeMenu(menu);
  else
    menu->nextItem();
}

void
CwmMenu::
endCascadeProc(CwmMenu *menu)
{
  if (menu->parent_ != 0) {
    menu->setCurrent(0);

    selected_item_ = 0;

    menu->state_ = CWM_MENU_INACTIVE;
  }
  else
    menu->prevItem();
}

void
CwmMenu::
acceptItemProc(CwmMenu *menu)
{
  if (menu->current_ == 0)
    return;

  selected_item_ = menu->current_;

  menu->complete();
}

void
CwmMenu::
endMenuProc(CwmMenu *menu)
{
  menu->setCurrent(0);

  selected_item_ = 0;

  menu->complete();
}

CwmMenu::
CwmMenu(CwmScreen &screen, CwmMenu *parent, CwmMenuDef *menu_def1,
        int x1, int y1, CHAlignType halign, CVAlignType valign) :
 screen_(screen), parent_(parent)
{
  Pixel fg = CwmResourceDataInst->getMenuForeground(screen);
  Pixel bg = CwmResourceDataInst->getMenuBackground(screen);

  CwmColor *color = screen.getColor(fg, bg);

  CwmFont *font = CwmResourceDataInst->getMenuFont(screen);

  graphics_ = new CwmGraphics(screen, font, color);

  //------

  fg = CwmResourceDataInst->getMenuTitleForeground(screen);
  bg = CwmResourceDataInst->getMenuTitleBackground(screen);

  CwmColor *title_color = screen.getColor(fg, bg);

  CwmFont *title_font = CwmResourceDataInst->getMenuTitleFont(screen);

  title_graphics_ = new CwmGraphics(screen, title_font, title_color);

  //------

  stipple_graphics_ = new CwmGraphics(screen, font, color);

  stipple_graphics_->setStippled();

  //------

  num_items_ = menu_def1->getSize();

  items_ = new CwmMenuItem * [num_items_];

  current_ = 0;

  x_          = x1;
  y_          = y1;
  width_      = 0;
  height_     = 0;
  item_width_ = 0;

  for (int i = 0; i < num_items_; i++) {
    CwmMenuItemType type = menu_def1->getEntry(i)->getType();

    if (type == CWM_MENU_TITLE_TYPE)
      items_[i] = new CwmMenuItem(this, title_graphics_, stipple_graphics_,
                                  menu_def1->getEntry(i));
    else
      items_[i] = new CwmMenuItem(this, graphics_, stipple_graphics_,
                                  menu_def1->getEntry(i));

    width_      = std::max(     width_, items_[i]->getWidth    ());
    item_width_ = std::max(item_width_, items_[i]->getItemWidth());

    height_ += items_[i]->getHeight();
  }

  width_  += 12;
  height_ += 4;

  if      (halign == CHALIGN_TYPE_RIGHT)
    x_ -= width_;
  else if (halign == CHALIGN_TYPE_CENTER)
    x_ -= width_/2;

  if      (valign == CVALIGN_TYPE_BOTTOM)
    y_ -= height_;
  else if (valign == CVALIGN_TYPE_CENTER)
    y_ -= height_/2;

  x_ = std::min(std::max(x_, 0), screen.getWidth () - width_ );
  y_ = std::min(std::max(y_, 0), screen.getHeight() - height_);

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask   |
                    KeyPressMask    | ExposureMask;

  xwindow_ =
    new CwmWindow(screen, screen.getRoot(), x_, y_, width_, height_,
                  event_mask, CWM_CURSOR_MENU);

  xwindow_->setBackground(graphics_);

  xwindow_->setSaveUnder(true);

  //------

  int y2 = 2;

  for (int j = 0; j < num_items_; j++) {
    items_[j]->createWindow(screen, xwindow_, y2, width_);

    y2 += items_[j]->getHeight();
  }

  //------

  cascade_ = 0;
}

CwmMenu::
~CwmMenu()
{
  for (int i = 0; i < num_items_; i++)
    delete items_[i];

  delete [] items_;

  delete xwindow_;

  delete graphics_;
  delete stipple_graphics_;
}

void
CwmMenu::
map()
{
  xwindow_->mapSubwindows();

  xwindow_->map();

  state_ = CWM_MENU_ACTIVE;

  if (parent_ != 0)
    parent_->cascade_ = this;
}

void
CwmMenu::
unmap()
{
  xwindow_->unmap();

  state_ = CWM_MENU_INACTIVE;

  if (parent_ != 0)
    parent_->cascade_ = 0;
}

void
CwmMenu::
redraw()
{
  drawBackground();

  for (int i = 0; i < num_items_; i++)
    items_[i]->redraw();
}

void
CwmMenu::
drawBackground()
{
  graphics_->drawButtonOut(xwindow_, 0, 0, width_, height_, 2);
}

void
CwmMenu::
nextItem()
{
  int i;

  if (current_ != 0) {
    for (i = 0; i < num_items_; i++)
      if (items_[i] == current_)
        break;

    if (i >= num_items_)
      i = -1;
  }
  else
    i = -1;

  i++;

  for ( ; i < num_items_; i++)
    if (items_[i]->isActive())
      break;

  if (i >= num_items_)
    return;

  if (current_ != 0)
    current_->drawInactive();

  current_ = items_[i];

  current_->drawActive();
}

void
CwmMenu::
prevItem()
{
  int i;

  if (current_ != 0) {
    for (i = 0; i < num_items_; i++)
      if (items_[i] == current_)
        break;

    if (i >= num_items_)
      i = num_items_;
  }
  else
    i = num_items_;

  i--;

  for ( ; i >= 0; i--)
    if (items_[i]->isActive())
      break;

  if (i < 0)
    return;

  if (current_ != 0)
    current_->drawInactive();

  current_ = items_[i];

  current_->drawActive();
}

void
CwmMenu::
complete()
{
  CwmMenu *menu = this;

  while (menu != 0) {
    menu->state_ = CWM_MENU_COMPLETED;

    menu = menu->parent_;
  }
}

CwmMenuItem *
CwmMenu::
getAnyMenuItemForWindow(Window xwin)
{
  CwmMenu *menu1 = this;

  while (menu1 != 0) {
    CwmMenuItem *menu_item = menu1->getMenuItemForWindow(xwin);

    if (menu_item != 0)
      return menu_item;

    menu1 = menu1->parent_;
  }

  return 0;
}

CwmMenuItem *
CwmMenu::
getMenuItemForWindow(CwmWindow *xwindow)
{
  for (int i = 0; i < num_items_; i++) {
    CwmWindow *xwindow1 = items_[i]->getXWindow();

    if (xwindow1 == xwindow)
      return items_[i];
  }

  return 0;
}

CwmMenuItem *
CwmMenu::
getMenuItemForWindow(Window xwin)
{
  for (int i = 0; i < num_items_; i++) {
    CwmWindow *xwindow1 = items_[i]->getXWindow();

    if (xwindow1->getXWin() == xwin)
      return items_[i];
  }

  return 0;
}

CwmMenuItem::
CwmMenuItem(CwmMenu *menu, CwmGraphics *graphics, CwmGraphics *stipple_graphics,
            CwmMenuEntry *entry) :
 menu_(menu), graphics_(graphics), stipple_graphics_(stipple_graphics)
{
  image_name_ = entry->getImage();
  text_       = entry->getText ();

  mnemonic_ = entry->getMnemonic();

  if (entry->getAccelerator() != "")
    accelerator_event_ = new CXNamedEvent(entry->getAccelerator());
  else
    accelerator_event_ = 0;

  type_ = entry->getType();

  selected_ = entry->getSelected();

  proc_  = entry->getProc();
  data1_ = entry->getData1();
  data2_ = entry->getData2();
  data3_ = entry->getData3();
  data4_ = entry->getData4();
  data5_ = entry->getData5();
  data6_ = entry->getData6();

  //------

  if (image_name_ != "") {
    image_ = CwmImageMgrInst->getImage(menu->getScreen(), image_name_);

    if (image_ != 0 && (image_->getWidth() > 16 || image_->getHeight() > 16))
      image_ = CwmImageMgrInst->getImage(menu->getScreen(), image_name_, 16, 16);
  }
  else
    image_ = 0;

  //------

  setSize();

  //------

  xwindow_ = 0;
}

CwmMenuItem::
~CwmMenuItem()
{
  delete accelerator_event_;
}

void
CwmMenuItem::
setSize()
{
  width_  = 0;
  height_ = 0;

  if (image_ != 0) {
    width_ += image_->getWidth() + 4;

    height_ = image_->getHeight() + 4;
  }

  std::string accelerator_text;

  if (accelerator_event_ != 0)
    accelerator_text = accelerator_event_->getText();

  if      (type_ == CWM_MENU_BUTTON_TYPE) {
    int height1;

    graphics_->getTextSize(text_, &item_width_, &height1);

    height_ = std::max(height_, height1 + 6);

    width_ += item_width_;

    if (accelerator_text != "") {
      int width1;

      graphics_->getTextSize(accelerator_text, &width1, &height1);

      width_ += width1 + 8;

      height_ = std::max(height_, height1 + 6);
    }
  }
  else if (type_ == CWM_MENU_TOGGLE_TYPE) {
    int height1;

    width_ += 14;

    graphics_->getTextSize(text_, &item_width_, &height1);

    height_ = std::max(height_, height1 + 6);

    width_ += item_width_;

    if (accelerator_text != "") {
      int width1;

      graphics_->getTextSize(accelerator_text, &width1, &height1);

      width_ += width1 + 8;

      height_ = std::max(height_, height1 + 6);
    }
  }
  else if (type_ == CWM_MENU_CASCADE_TYPE) {
    int height1;

    graphics_->getTextSize(text_, &item_width_, &height1);

    width_ += item_width_ + 10;

    height_ = std::max(height_, height1 + 6);
  }
  else if (type_ == CWM_MENU_TITLE_TYPE) {
    int height1;

    graphics_->getTextSize(text_, &item_width_, &height1);

    width_ += item_width_;

    height_ = std::max(height_, height1 + 6);
  }
  else if (type_ == CWM_MENU_SPLITTER_TYPE) {
    item_width_ = 0;

    width_ = menu_->getWidth();

    height_ = std::max(height_, 4);
  }
}

void
CwmMenuItem::
createWindow(CwmScreen &screen, CwmWindow *menu_xwindow, int menu_y, int menu_width)
{
  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask   |
                    KeyPressMask    | ExposureMask;

  xwindow_ =
    new CwmWindow(screen, menu_xwindow, 2, menu_y, (menu_width - 4), height_,
                  event_mask, CWM_CURSOR_MENU);

  xwindow_->setBackground(graphics_);
}

bool
CwmMenuItem::
isCascadeMenu()
{
  return (type_ == CWM_MENU_CASCADE_TYPE && data1_ != 0);
}

void
CwmMenuItem::
processCascadeMenu(CwmMenu *parent)
{
  CwmMenuDef *menu_def = (CwmMenuDef *) data1_;

  int root_x, root_y;

  xwindow_->coordsToRoot(2*parent->getWidth()/3, height_/2, &root_x, &root_y);

  CwmMenu *menu =
    new CwmMenu(parent->getScreen(), parent, menu_def, root_x, root_y,
                CHALIGN_TYPE_LEFT, CVALIGN_TYPE_TOP);

  menu->map();

  menu->redraw();

  if (CwmMenu::isStayUp()) {
    int i;

    menu->nextItem();

    while (menu->isActive()) {
      while (CwmMenu::isButtonDown() && menu->isActive()) {
        CwmMenuItem *current = menu->getCurrent();

        if (current == 0 || ! current->isCascadeMenu())
          break;

        current->processCascadeMenu(menu);
      }

      if (! menu->isActive())
        break;

      XEvent *event = CwmEventMgrInst->processNextEvent();

      if      (event->type == ButtonPress) {
        if (event->xbutton.button != 1 &&
            event->xbutton.button != 3)
          continue;

        Window event_window = CwmMachineInst->getEventWindow(event);

        CwmMenuItem *menu_item =
          menu->getAnyMenuItemForWindow(event_window);

        CwmMenuItem *current = 0;

        if (menu_item != 0)
          current = menu_item->menu_->getCurrent();

        if (current != 0)
          current->leave();

        if (menu_item != 0)
          menu_item->enter();

        CwmMenu::setSelectedItem(menu_item);

        CwmMenu::buttonPress();
      }
      else if (event->type == ButtonRelease) {
        menu->complete();

        CwmMenu::buttonRelease();
      }
      else if (event->type == EnterNotify) {
        if (CwmMenu::isButtonDown()) {
          Window event_window = CwmMachineInst->getEventWindow(event);

          CwmMenuItem *menu_item =
            menu->getAnyMenuItemForWindow(event_window);

          if (menu_item != 0) {
            menu_item->enter();

            if      (menu_item->menu_ == menu) {
              if (menu_item != 0 &&
                  menu_item->type_ != CWM_MENU_CASCADE_TYPE)
                CwmMenu::setSelectedItem(menu_item);
            }
            else if (menu_item->menu_ != 0) {
              if (menu_item != this) {
                CwmMenu *menu1 = menu;

                while (menu1 != 0 && menu1 != menu_item->menu_) {
                  menu1->setInactive();

                  menu1->setCurrent(0);

                  menu1 = menu1->getParent();
                }
              }
            }
          }
        }
      }
      else if (event->type == LeaveNotify) {
        if (CwmMenu::isButtonDown()) {
          Window event_window = CwmMachineInst->getEventWindow(event);

          CwmMenuItem *menu_item =
            menu->getAnyMenuItemForWindow(event_window);

          if (menu_item != 0)
            menu_item->leave();

          CwmMenu::setSelectedItem(0);
        }
      }
      else if (event->type == KeyPress) {
        XKeyPressedEvent *event1 = (XKeyPressedEvent *) event;

        CwmMenuKeyData *key_data = CwmMenuKeyData::getKeyData(event1);

        if (key_data != 0) {
          key_data->invoke(menu);
          continue;
        }

        for (i = 0; i < menu->getNumItems(); i++) {
          CwmMenuItem *item = menu->getItem(i);

          if (item->isMnemonicEvent   (event1) ||
              item->isAcceleratorEvent(event1)) {
            CwmMenu::setSelectedItem(item);
            break;
          }
        }

        if (i < menu->getNumItems())
          menu->complete();
      }
    }
  }
  else {
    while (menu->isActive()) {
      XEvent *event = CwmEventMgrInst->processNextEvent();

      if      (event->type == ButtonPress) {
        if (event->xbutton.button != 1 &&
            event->xbutton.button != 3)
          continue;

        Window event_window = CwmMachineInst->getEventWindow(event);

        CwmMenuItem *menu_item =
          menu->getAnyMenuItemForWindow(event_window);

        CwmMenu::setSelectedItem(menu_item);

        menu->complete();
      }
      else if (event->type == ButtonRelease) {
        menu->complete();
      }
      else if (event->type == EnterNotify) {
        Window event_window = CwmMachineInst->getEventWindow(event);

        CwmMenuItem *menu_item =
          menu->getAnyMenuItemForWindow(event_window);

        if (menu_item != 0) {
          menu_item->enter();

          if      (menu_item->menu_ == menu) {
            if (menu_item != 0 && menu_item->type_ != CWM_MENU_CASCADE_TYPE)
              CwmMenu::setSelectedItem(menu_item);
          }
          else if (menu_item->menu_ != 0) {
            if (menu_item != this) {
              CwmMenu *menu1 = menu;

              while (menu1 != 0 && menu1 != menu_item->menu_) {
                menu1->setInactive();

                menu1->setCurrent(0);

                menu1 = menu1->getParent();
              }
            }
          }
        }
      }
      else if (event->type == LeaveNotify) {
        Window event_window = CwmMachineInst->getEventWindow(event);

        CwmMenuItem *menu_item =
          menu->getAnyMenuItemForWindow(event_window);

        if (menu_item != 0)
          menu_item->leave();

        CwmMenu::setSelectedItem(0);
      }

      CwmMenu *cascade = menu->getCascade();

      if (cascade != 0) {
        if      (cascade->isCompleted())
          menu->complete();
        else if (cascade->isInactive())
          menu->setCascade(0);
      }

      while (menu->isActive()) {
        CwmMenuItem *current =  menu->getCurrent();

        if (current == 0 || ! current->isCascadeMenu())
          break;

        current->processCascadeMenu(menu);
      }
    }
  }

  menu->unmap();

  CwmMachineInst->flushEvents();

  parent->redraw();

  if (menu->isCompleted())
    parent->setCompleted();

//delete menu;
}

void
CwmMenuItem::
redraw()
{
  xwindow_->clear();

  CwmMenuItem *current = menu_->getCurrent();

  drawImage();

  if      (type_ == CWM_MENU_TITLE_TYPE)
    drawText(graphics_);
  else if (type_ == CWM_MENU_BUTTON_TYPE) {
    if (current == this)
      graphics_->drawButtonOut(xwindow_, 0, 0, menu_->getWidth() - 4, height_, 2);

    if (proc_ != 0)
      drawText(graphics_);
    else
      drawText(stipple_graphics_);
  }
  else if (type_ == CWM_MENU_TOGGLE_TYPE) {
    if (current == this)
      graphics_->drawButtonOut(xwindow_, 0, 0, menu_->getWidth() - 4, height_, 2);

    drawText(graphics_);
  }
  else if (type_ == CWM_MENU_SPLITTER_TYPE)
    drawSplitter();
  else if (type_ == CWM_MENU_CASCADE_TYPE) {
    if (current == this)
      graphics_->drawButtonOut(xwindow_, 0, 0, menu_->getWidth() - 4, height_, 2);

    if (data1_ != 0)
      drawText(graphics_);
    else
      drawText(stipple_graphics_);

    graphics_->drawRightArrowOut(xwindow_, menu_->getWidth() - 15, height_/2 - 5,
                                 menu_->getWidth() -  8, height_/2 + 4);
  }
}

void
CwmMenuItem::
enter()
{
  if      (type_ == CWM_MENU_BUTTON_TYPE && proc_ != 0) {
    menu_->setCurrent(this);

    drawActive();
  }
  else if (type_ == CWM_MENU_TOGGLE_TYPE) {
    menu_->setCurrent(this);

    drawActive();
  }
  else if (type_ == CWM_MENU_CASCADE_TYPE && data1_ != 0) {
    menu_->setCurrent(this);

    drawActive();
  }
}

void
CwmMenuItem::
leave()
{
  if      (type_ == CWM_MENU_BUTTON_TYPE && proc_ != 0) {
    menu_->setCurrent(0);

    drawInactive();
  }
  else if (type_ == CWM_MENU_TOGGLE_TYPE) {
    menu_->setCurrent(0);

    drawInactive();
  }
  else if (type_ == CWM_MENU_CASCADE_TYPE && data1_ != 0) {
    menu_->setCurrent(0);

    drawInactive();
  }
}

bool
CwmMenuItem::
isMnemonicEvent(XKeyPressedEvent *event)
{
  return (mnemonic_ != '\0' && CwmXEventInst->isKeyPressEvent(event, mnemonic_));
}

bool
CwmMenuItem::
isAcceleratorEvent(XKeyPressedEvent *event)
{
  if (accelerator_event_ == 0)
    return false;

  return accelerator_event_->matchEvent((XEvent *) event);
}

void
CwmMenuItem::
select()
{
  if (proc_ != 0)
    proc_(data1_, data2_, data3_, data4_, data5_, data6_);
}

void
CwmMenuItem::
drawActive()
{
  xwindow_->clear();

  drawImage();

  graphics_->drawButtonOut(xwindow_, 0, 0, menu_->getWidth() - 4, height_, 2);

  drawText(graphics_);

  if (type_ == CWM_MENU_CASCADE_TYPE)
    graphics_->drawRightArrowOut(xwindow_, menu_->getWidth() - 15, height_/2 - 5,
                                 menu_->getWidth() -  8, height_/2 + 4);
}

void
CwmMenuItem::
drawInactive()
{
  xwindow_->clear();

  drawImage();

  drawText(graphics_);

  if (type_ == CWM_MENU_CASCADE_TYPE)
    graphics_->drawRightArrowOut(xwindow_, menu_->getWidth() - 15, height_/2 - 5,
                                 menu_->getWidth() -  8, height_/2 + 4);
}

void
CwmMenuItem::
drawImage()
{
  if (image_ == 0)
    return;

  int x = 2;
  int y = (height_ - image_->getHeight())/2;

  image_->draw(xwindow_, graphics_, x, y);
}

void
CwmMenuItem::
drawText(CwmGraphics *graphics1)
{
  int x = 4;
  int y = 4;

  if (image_ != 0)
    x += image_->getWidth() + 4;

  if (type_ == CWM_MENU_TOGGLE_TYPE) {
    if (selected_)
      graphics1->drawButtonOut(xwindow_, 4, height_/2 - 4, 8, 8, 2);

    x += 14;
  }

  int i;

  for (i = 0; i < (int) text_.size(); i++)
    if (text_[i] == mnemonic_)
      break;

  if (i < (int) text_.size()) {
    int x1 = x;

    std::string text1 = text_.substr(0, i);

    graphics1->drawText(xwindow_, x1, y, text1);

    int width1, height1;

    graphics1->getTextSize(text1, &width1, &height1);

    x1 += width1;

    text1 = text_.substr(i, 1);

    graphics1->drawText(xwindow_, x1, y, text1);

    graphics1->getTextSize(text1, &width1, &height1);

    graphics1->drawLine(xwindow_, x1         , y + graphics1->getFontAscent() + 1,
                        x1 + width1, y + graphics1->getFontAscent() + 1);

    x1 += width1;

    text1 = text_.substr(i + 1);

    graphics1->drawText(xwindow_, x1, y, text1);
  }
  else
    graphics1->drawText(xwindow_, x, y, text_);

  std::string accelerator_text;

  if (accelerator_event_ != 0)
    accelerator_text = accelerator_event_->getText();

  if      (type_ == CWM_MENU_BUTTON_TYPE && accelerator_text != "") {
    x += menu_->getItemWidth() + 8;

    graphics1->drawText(xwindow_, x, y, accelerator_text);
  }
  else if (type_ == CWM_MENU_TOGGLE_TYPE && accelerator_text != "") {
    x += menu_->getItemWidth() + 8;

    graphics1->drawText(xwindow_, x, y, accelerator_text);
  }
}

void
CwmMenuItem::
drawSplitter()
{
  graphics_->drawEtchedLine(xwindow_, 1, 1, menu_->getWidth() - 1, 1);
}

CwmNamedMenuMgr *
CwmNamedMenuMgr::
getInstance()
{
  static CwmNamedMenuMgr *instance;

  if (! instance)
    instance = new CwmNamedMenuMgr();

  return instance;
}

void
CwmNamedMenuMgr::
define(const std::string &name, CwmMenuDef *menu_def)
{
  CwmNamedMenu *named_menu = lookup(name);

  if (named_menu != 0)
    return;

  named_menu = new CwmNamedMenu(name, menu_def);

  named_menus_.push_back(named_menu);
}

CwmMenuDef *
CwmNamedMenuMgr::
lookupMenuDef(const std::string &name)
{
  CwmNamedMenu *named_menu = lookup(name);

  if (named_menu != 0)
    return named_menu->getMenuDef();

  if (CStrUtil::casecmp(name, "Root Functions") == 0)
    return createDefaultRootMenu();

  return 0;
}

CwmNamedMenu *
CwmNamedMenuMgr::
lookup(const std::string &name)
{
  NamedMenuList::const_iterator pnamed_menu1 = named_menus_.begin();
  NamedMenuList::const_iterator pnamed_menu2 = named_menus_.end  ();

  for ( ; pnamed_menu1 != pnamed_menu2; ++pnamed_menu1)
    if (CStrUtil::casecmp((*pnamed_menu1)->getName(), name) == 0)
      return *pnamed_menu1;

  return 0;
}

void
CwmNamedMenuMgr::
deleteAll()
{
  std::for_each(named_menus_.begin(), named_menus_.end(), CDeletePointer());

  named_menus_.clear();
}

CwmMenuDef *
CwmNamedMenuMgr::
createDefaultRootMenu()
{
  static CwmMenuDef *menu_def;

  if (menu_def == 0) {
    menu_def = new CwmMenuDef();

    menu_def->addTitle   ("Root Menu" );
    menu_def->addSplitter("----------");
    menu_def->addButton  ("", "New Window", '\0', "",
                          (CwmMenuProc) &CwmScreenMenu::runXCommandProc, (CwmData) "xterm &");
    menu_def->addButton  ("", "Restart"   , '\0', "",
                          (CwmMenuProc) &CwmScreenMenu::restartCwmProc, 0);
    menu_def->addSplitter("----------");
    menu_def->addButton  ("", "Quit"      , '\0', "",
                          (CwmMenuProc) &CwmScreenMenu::quitCwmProc, 0);
  }

  return menu_def;
}

CwmNamedMenu::
CwmNamedMenu(const std::string &name, CwmMenuDef *menu_def) :
 name_(name)
{
  if (menu_def != 0)
    menu_def_ = new CwmMenuDef(*menu_def);
  else
    menu_def_ = new CwmMenuDef();
}

CwmNamedMenu::
~CwmNamedMenu()
{
  delete menu_def_;
}
##concat##CwmMessage.cpp
#include <CwmI.h>

CwmMessage *
CwmMessage::
getInstance()
{
  static CwmMessage *instance;

  if (! instance)
    instance = new CwmMessage();

  return instance;
}

CwmMessage::
CwmMessage() :
 change_count_(0)
{
  XSetWindowAttributes attr;

  attr.event_mask        = PropertyChangeMask;
  attr.cursor            = None;
  attr.override_redirect = True;

  uint attr_mask = CWEventMask | CWCursor | CWOverrideRedirect;

  xwin_ = CwmMachineInst->createWindow(0, 0, 1, 1, 0, attr_mask, &attr);

  const CXAtom &atom = CwmMachineInst->getAtom("CWM_SERVER_WINDOW");

  CwmMachineInst->setWindowProperty(atom, xwin_);

  updateChangeCount();
}

CwmMessage::
~CwmMessage()
{
  CwmMachineInst->destroyWindow(xwin_);
}

void
CwmMessage::
init()
{
}

bool
CwmMessage::
processClientMessage(XClientMessageEvent *event)
{
  if (event->window != xwin_)
    return false;

  Window client_xwin;
  std::string value;

  CwmMachineInst->readStringClientMessage(xwin_, &client_xwin, value);

  vector<string> words;

  CStrUtil::toWords(value, words);

  int num_words = words.size();

  if (num_words == 0)
    goto fail;

  for (int i = 0; i < num_words; ++i) CwmMachineInst->log(words[i] + '\n');

  if      (words[0] == "get_windows") {
    const CwmScreen &screen = CwmMachineInst->getScreen(0);

    CwmCirculateWindowStack &window_stack = screen.getCirculateWindowStack();

    std::string str;

    for (int i = 0; i < window_stack.size(); i++) {
      CwmWindowGroup &window_group = window_stack[i];

      if (window_group.size() == 0)
        continue;

      int num_windows = window_group.size();

      for (int j = 0; j < num_windows; ++j) {
        CwmWMWindow &window = window_group[j];

        if (str != "")
          str += " ";

        str += CStrUtil::toString(window.getXWin());
      }
    }

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, str);
  }
  else if (words[0] == "circulate_up") {
    const CwmScreen &screen = CwmMachineInst->getScreen(0);

    screen.circulateUp();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "circulate_down") {
    const CwmScreen &screen = CwmMachineInst->getScreen(0);

    screen.circulateDown();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "raise_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->raise();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "lower_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->lower();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "close_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->close();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "restore_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->restore();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "move_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->move();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "resize_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->resize();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "iconise_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->iconise();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "maximize_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->maximize();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "minimize_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->minimize();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "roll_up_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->rollUp();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "roll_down_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->rollDown();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "focus_window") {
    if (num_words < 2)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    window->focus();

    CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "1");
  }
  else if (words[0] == "get_screen_value") {
    const CwmScreen &screen = CwmMachineInst->getScreen(0);

    if (num_words < 2)
      goto fail;

    if      (words[1] == "width") {
      int width = screen.getWidth();

      CwmMachineInst->sendIntegerServerMessage(client_xwin, xwin_, width);
    }
    else if (words[1] == "height") {
      int height = screen.getHeight();

      CwmMachineInst->sendIntegerServerMessage(client_xwin, xwin_, height);
    }
    else {
      CwmMachineInst->log("Invalid screen value " + words[2] + "\n");
    }
  }
  else if (words[0] == "get_window_value") {
    if (num_words < 3)
      goto fail;

    CwmWMWindow *window = stringToWindow(words[1]);

    if (window == 0)
      goto fail;

    if      (words[2] == "x") {
      int x = window->getFrame()->getX();

      CwmMachineInst->sendIntegerServerMessage(client_xwin, xwin_, x);
    }
    else if (words[2] == "y") {
      int y = window->getFrame()->getY();

      CwmMachineInst->sendIntegerServerMessage(client_xwin, xwin_, y);
    }
    else if (words[2] == "width") {
      int width = window->getFrame()->getWidth();

      CwmMachineInst->sendIntegerServerMessage(client_xwin, xwin_, width);
    }
    else if (words[2] == "height") {
      int height = window->getFrame()->getHeight();

      CwmMachineInst->sendIntegerServerMessage(client_xwin, xwin_, height);
    }
    else {
      CwmMachineInst->log("Invalid window value " + words[2] + "\n");
    }
  }
  else
    goto fail;

  return true;

 fail:
  CwmMachineInst->log("Invalid Command " + value + "\n");

  CwmMachineInst->sendStringServerMessage(client_xwin, xwin_, "0");

  return true;
}

CwmWMWindow *
CwmMessage::
stringToWindow(const std::string &str)
{
  Window xwin = CStrUtil::toInteger(str);

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(xwin);

  return window;
}

void
CwmMessage::
updateChangeCount()
{
  const CXAtom &atom = CwmMachineInst->getAtom("CHANGE_COUNT");

  CwmMachineInst->setIntegerProperty(xwin_, atom, change_count_);

  ++change_count_;
}
##concat##CwmMoveFeedback.cpp
#include <CwmI.h>

CwmMoveFeedback::
CwmMoveFeedback(CwmScreen &screen1) :
 screen(screen1)
{
  Pixel fg = CwmResourceDataInst->getFeedbackForeground(screen);
  Pixel bg = CwmResourceDataInst->getFeedbackBackground(screen);

  CwmColor *color = screen.getColor(fg, bg);

  CwmFont *font = CwmResourceDataInst->getFeedbackFont(screen);

  graphics = new CwmGraphics(screen, font, color);

  //------

  feedback_x = 0;
  feedback_y = 0;

  initGeometry();

  //------

  int width, height;

  std::string max_str = "-8888,-8888";

  graphics->getTextSize(max_str, &width, &height);

  width  += 8;
  height += 8;

  int x = feedback_x - width /2;
  int y = feedback_y - height/2;

  x = std::min(std::max(x, 0), screen.getWidth () - width );
  y = std::min(std::max(y, 0), screen.getHeight() - height);

  xwindow = new CwmWindow(screen, screen.getRoot(), x, y, width, height, 0, CWM_CURSOR_MOVE);

  xwindow->setBackground(graphics);

  xwindow->setSaveUnder(true);

  //------

  displayed = FALSE;
}

CwmMoveFeedback::
~CwmMoveFeedback()
{
  delete graphics;

  delete xwindow;
}

void
CwmMoveFeedback::
initGeometry()
{
  CHAlignType halign;
  CVAlignType valign;

  CwmResourceDataInst->getFeedbackGeometry(&halign, &valign, &feedback_x, &feedback_y);

  if      (halign == CHALIGN_TYPE_LEFT)
    ;
  else if (halign == CHALIGN_TYPE_RIGHT)
    feedback_x += screen.getWidth() - 1;
  else if (halign == CHALIGN_TYPE_CENTER)
    feedback_x += screen.getWidth()/2;

  if      (valign == CVALIGN_TYPE_TOP)
    feedback_y = 0;
  else if (valign == CVALIGN_TYPE_BOTTOM)
    feedback_y += screen.getHeight() - 1;
  else if (valign == CVALIGN_TYPE_CENTER)
    feedback_y += screen.getHeight()/2;
}

void
CwmMoveFeedback::
show()
{
  if (displayed)
    return;

  displayed = true;

  xwindow->mapRaised();
}

void
CwmMoveFeedback::
hide()
{
  if (! displayed)
    return;

  displayed = false;

  xwindow->unmap();
}

void
CwmMoveFeedback::
update(int x, int y)
{
  if (! displayed)
    return;

  xwindow->clear();

  graphics->drawButtonOut(xwindow, 0, 0, xwindow->getWidth (), xwindow->getHeight(), 2);

  std::string position_string = CStrUtil::toString(x) + "," + CStrUtil::toString(y);

  graphics->drawTextCentered(xwindow, 4, 4, xwindow->getWidth () - 8,
                             xwindow->getHeight() - 8, position_string);
}
##concat##CwmMoveWindow.cpp
#include <CwmI.h>

CwmMoveWindow::
CwmMoveWindow()
{
  move_threshold_     = 0;
  move_cursor_type_   = CWM_CURSOR_MOVE;
  position_on_screen_ = -1;
}

CwmMoveWindow::
~CwmMoveWindow()
{
}

CwmMoveWindow *
CwmMoveWindow::
getInstance()
{
  static CwmMoveWindow *instance;

  if (! instance)
    instance = new CwmMoveWindow();

  return instance;
}

void
CwmMoveWindow::
moveDelayed(CwmWMWindow *window)
{
  move_threshold_ = CwmResourceDataInst->getMoveThreshold();

  move(window);

  move_threshold_ = 0;
}

void
CwmMoveWindow::
movePlaced(CwmWMWindow *window)
{
  move_cursor_type_   = CWM_CURSOR_PLACE;
  position_on_screen_ = false;

  move(window);

  move_cursor_type_   = CWM_CURSOR_MOVE;
  position_on_screen_ = CwmResourceDataInst->getPositionOnScreen();
}

void
CwmMoveWindow::
move(CwmWMWindow *window)
{
  CwmScreen &screen = window->getScreen();

  CwmFrameWindow *frame = window->getFrame();

  if (position_on_screen_ == -1)
    position_on_screen_ = CwmResourceDataInst->getPositionOnScreen();

  int last_event_type = CwmEventMgrInst->getLastEventType();

  if (last_event_type == KeyPress && CwmResourceDataInst->getEnableWarp())
    screen.getRoot()->warpPointer(frame->getX() + frame->getWidth ()/2,
                                  frame->getY() + frame->getHeight()/2);

  int dx;
  int dy;

  moveInteractive(screen,
                  frame->getXWindow(),
                  frame->getX(),
                  frame->getY(),
                  frame->getWidth(),
                  frame->getHeight(),
                  &dx, &dy);

  if (dx == 0 && dy == 0)
    return;

  if (! CwmResourceDataInst->getMoveOpaque())
    window->move(frame->getX() + dx, frame->getY() + dy);
  else
    window->move(frame->getX(), frame->getY());
}

void
CwmMoveWindow::
moveInteractive(CwmScreen &screen, CwmWindow *xwindow, int x, int y,
                int width, int height, int *dx, int *dy)
{
  int save_x = x;
  int save_y = y;

  bool move_started = false;

  *dx = 0;
  *dy = 0;

  bool escape_pressed = false;

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    PointerMotionMask;

  if (! screen.getRoot()->grab(event_mask, move_cursor_type_))
    return;

  int start_x, start_y;

  xwindow->getPointerPosition(&start_x, &start_y);

  int end_x = start_x;
  int end_y = start_y;

  if (! CwmResourceDataInst->getMoveOpaque())
    CwmMachineInst->grabServer();

  while (true) {
    XEvent *event = CwmEventMgrInst->processNextEvent();

    if      (event->type == ButtonPress)
      break;
    else if (event->type == ButtonRelease)
      break;
    else if (event->type == MotionNotify) {
      if (move_started) {
        if (! CwmResourceDataInst->getMoveOpaque())
          screen.drawOutline(x + *dx, y + *dy, width, height);
      }

      end_x = event->xmotion.x_root;
      end_y = event->xmotion.y_root;

      *dx = end_x - start_x;
      *dy = end_y - start_y;

      if (! move_started &&
          (abs(*dx) >= move_threshold_ || abs(*dy) >= move_threshold_))
        move_started = true;

      if (CwmResourceDataInst->getFeedbackMove() && move_started)
        screen.showMoveFeedback();

      if (position_on_screen_) {
        if (x + *dx < 0)
          *dx = -x;

        if (y + *dy < 0)
          *dy = -y;

        if (x + width + *dx >= screen.getWidth())
          *dx = screen.getWidth() - width - x;

        if (y + height + *dy >= screen.getHeight())
          *dy = screen.getHeight() - height - y;
      }

      screen.updateMoveFeedback(x + *dx, y + *dy);

      if (move_started) {
        if (! CwmResourceDataInst->getMoveOpaque())
          screen.drawOutline(x + *dx, y + *dy, width, height);
        else {
          x += *dx;
          y += *dy;

          xwindow->move(x, y);

          start_x = end_x;
          start_y = end_y;
        }
      }
    }
    else if (event->type == KeyPress) {
      if (CwmXEventInst->isEscapeKeyEvent(&event->xkey)) {
        escape_pressed = true;

        break;
      }
    }
    else if (event->type == KeyRelease) {
    }
    else if (event->type == EnterNotify) {
    }
    else if (event->type == LeaveNotify) {
    }
    else
      CwmMachineInst->logf("MoveWindow: Unexpected event %d\n", event->type);
  }

  if (move_started) {
    if (! CwmResourceDataInst->getMoveOpaque())
      screen.drawOutline(x + *dx, y + *dy, width, height);
  }

  screen.hideMoveFeedback();

  if (! CwmResourceDataInst->getMoveOpaque())
    CwmMachineInst->ungrabServer();

  screen.getRoot()->ungrab();

  if (! move_started) {
    *dx = 0;
    *dy = 0;

    return;
  }

  if (escape_pressed) {
    if (! screen.getRoot()->grabPointer(event_mask, CWM_CURSOR_TITLE)) {
      CwmMachineInst->log("Grab Pointer Failed for Move\n");
      return;
    }

    while (true) {
      XEvent *event = CwmEventMgrInst->processNextEvent();

      if (event->type == ButtonRelease)
        break;
    }

    *dx = 0;
    *dy = 0;

    screen.getRoot()->ungrabPointer();

    return;
  }

  if (CwmResourceDataInst->getMoveOpaque()) {
    *dx = x - save_x;
    *dy = y - save_y;
  }
}
##concat##CwmPaste.cpp
#include <CwmI.h>

void
CwmPaste::
pasteText(CwmWMWindow *window, const std::string &text)
{
  for (int i = 0; i < (int) text.size(); i++)
    pasteChar(window, text[i]);
}

void
CwmPaste::
pasteChar(CwmWMWindow *window, int c)
{
  CwmUserWindow *user = window->getUser();

  if (user == 0)
    return;

  char key_string[2];

  key_string[0] = c;
  key_string[1] = '\0';

  KeySym keysym = XStringToKeysym(key_string);

  if (keysym == NoSymbol)
    return;

  uint keycode = CwmMachineInst->keysymToKeycode(keysym);

  CwmMachineInst->sendKeyPressedEvent(user->getXWindow()->getXWin(),
                                      user->getX(), user->getY(),
                                      keycode);

  CwmMachineInst->sendKeyReleasedEvent(user->getXWindow()->getXWin(),
                                       user->getX(), user->getY(),
                                       keycode);
}
##concat##CwmResizeFeedback.cpp
#include <CwmI.h>

CwmResizeFeedback::
CwmResizeFeedback(CwmScreen &screen1) :
 screen(screen1)
{
  Pixel fg = CwmResourceDataInst->getFeedbackForeground(screen);
  Pixel bg = CwmResourceDataInst->getFeedbackBackground(screen);

  CwmColor *color = screen.getColor(fg, bg);

  CwmFont *font = CwmResourceDataInst->getFeedbackFont(screen);

  graphics = new CwmGraphics(screen, font, color);

  //------

  feedback_x = 0;
  feedback_y = 0;

  initGeometry();

  //------

  int width, height;

  std::string max_str = "8888x8888";

  graphics->getTextSize(max_str, &width, &height);

  width  += 8;
  height += 8;

  int x = feedback_x - width /2;
  int y = feedback_y - height/2;

  x = std::min(std::max(x, 0), screen.getWidth () - width );
  y = std::min(std::max(y, 0), screen.getHeight() - height);

  xwindow = new CwmWindow(screen, screen.getRoot(), x, y, width, height, 0, CWM_CURSOR_SE);

  xwindow->setBackground(graphics);

  xwindow->setSaveUnder(true);

  //------

  displayed = false;
}

CwmResizeFeedback::
~CwmResizeFeedback()
{
  delete graphics;

  delete xwindow;
}

void
CwmResizeFeedback::
initGeometry()
{
  CHAlignType halign;
  CVAlignType valign;

  CwmResourceDataInst->getFeedbackGeometry
    (&halign, &valign, &feedback_x, &feedback_y);

  if      (halign == CHALIGN_TYPE_LEFT)
    ;
  else if (halign == CHALIGN_TYPE_RIGHT)
    feedback_x += screen.getWidth() - 1;
  else if (halign == CHALIGN_TYPE_CENTER)
    feedback_x += screen.getWidth()/2;

  if      (valign == CVALIGN_TYPE_TOP)
    feedback_y = 0;
  else if (valign == CVALIGN_TYPE_BOTTOM)
    feedback_y += screen.getHeight() - 1;
  else if (valign == CVALIGN_TYPE_CENTER)
    feedback_y += screen.getHeight()/2;
}

void
CwmResizeFeedback::
show()
{
  if (displayed)
    return;

  displayed = true;

  xwindow->mapRaised();
}

void
CwmResizeFeedback::
hide()
{
  if (! displayed)
    return;

  displayed = false;

  xwindow->unmap();
}

void
CwmResizeFeedback::
update(CwmWMWindow *size_window, int dwidth, int dheight)
{
  if (! displayed)
    return;

  xwindow->clear();

  graphics->drawButtonOut(xwindow, 0, 0, xwindow->getWidth (), xwindow->getHeight(), 2);

  CwmUserWindow *user = size_window->getUser();

  if (user == 0)
    return;

  int width1  = user->getWidth()  + dwidth  - size_window->getBaseWidthHint();
  int height1 = user->getHeight() + dheight - size_window->getBaseHeightHint();

  width1  = (width1  + size_window->getWidthIncHint() /2)/size_window->getWidthIncHint() ;
  height1 = (height1 + size_window->getHeightIncHint()/2)/size_window->getHeightIncHint();

  std::string size_string = CStrUtil::toString(width1 ) + "x" + CStrUtil::toString(height1);

  graphics->drawTextCentered(xwindow, 4, 4, xwindow->getWidth () - 8,
                             xwindow->getHeight() - 8, size_string);
}
##concat##CwmResizeWindow.cpp
#include <CwmI.h>

CwmResizeWindow::
CwmResizeWindow()
{
  resize_tolerance_ = 0;
}

CwmResizeWindow::
~CwmResizeWindow()
{
}

CwmResizeWindow *
CwmResizeWindow::
getInstance()
{
  static CwmResizeWindow *instance;

  if (! instance)
    instance = new CwmResizeWindow();

  return instance;
}

void
CwmResizeWindow::
resizeDelayed(CwmWMWindow *window, int resize_type)
{
  resize_tolerance_ = 4;

  resize(window, resize_type);

  resize_tolerance_ = 0;
}

void
CwmResizeWindow::
resize(CwmWMWindow *window, int resize_type)
{
  CwmScreen &screen = window->getScreen();

  CwmFrameWindow *frame = window->getFrame();
  CwmUserWindow  *user  = window->getUser ();

  if (user == 0)
    return;

  int last_event_type = CwmEventMgrInst->getLastEventType();

  if (last_event_type == KeyPress && CwmResourceDataInst->getEnableWarp())
    screen.getRoot()->warpPointer(frame->getX() + frame->getWidth ()/2,
                                  frame->getY() + frame->getHeight()/2);

  bool resize_started = false;

  bool escape_pressed = false;

  CwmCursorType cursor_type = CWM_CURSOR_MOVE;

  if      (resize_type == CWM_RESIZE_TOP_LEFT)
    cursor_type = CWM_CURSOR_NW;
  else if (resize_type == CWM_RESIZE_BOTTOM_LEFT)
    cursor_type = CWM_CURSOR_SW;
  else if (resize_type == CWM_RESIZE_TOP_RIGHT)
    cursor_type = CWM_CURSOR_NE;
  else if (resize_type == CWM_RESIZE_BOTTOM_RIGHT)
    cursor_type = CWM_CURSOR_SE;
  else if (resize_type == CWM_RESIZE_LEFT)
    cursor_type = CWM_CURSOR_W;
  else if (resize_type == CWM_RESIZE_RIGHT)
    cursor_type = CWM_CURSOR_E;
  else if (resize_type == CWM_RESIZE_TOP)
    cursor_type = CWM_CURSOR_N;
  else if (resize_type == CWM_RESIZE_BOTTOM)
    cursor_type = CWM_CURSOR_S;

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    PointerMotionMask;

  if (! screen.getRoot()->grab(event_mask, cursor_type))
    return;

  int start_x;
  int start_y;

  screen.getRoot()->getPointerPosition(&start_x, &start_y);

  int x11 = frame->getX();
  int y11 = frame->getY();
  int x12 = frame->getX() + frame->getWidth () - 1;
  int y12 = frame->getY() + frame->getHeight() - 1;

  int x21 = x11;
  int y21 = y11;
  int x22 = x12;
  int y22 = y12;

  CwmGrabServer grab;

  int dx1 = x21 - x11;
  int dy1 = y21 - y11;
  int dx2 = x22 - x12;
  int dy2 = y22 - y12;

  while (true) {
    XEvent *event = CwmEventMgrInst->processNextEvent();

    if      (event->type == ButtonPress)
      break;
    else if (event->type == ButtonRelease)
      break;
    else if (event->type == MotionNotify) {
      if (resize_started)
        screen.drawOutline(x21, y21, x22 - x21, y22 - y21);

      int end_x = event->xmotion.x_root;
      int end_y = event->xmotion.y_root;

      if (! (resize_type & CWM_RESIZE_LEFT ) &&
          ! (resize_type & CWM_RESIZE_RIGHT)) {
        start_x = end_x;

        if      (end_x < x21)
          resize_type |= CWM_RESIZE_LEFT;
        else if (end_x > x22)
          resize_type |= CWM_RESIZE_RIGHT;
      }

      if (! (resize_type & CWM_RESIZE_TOP   ) &&
          ! (resize_type & CWM_RESIZE_BOTTOM)) {
        start_y = end_y;

        if      (end_y < y21)
          resize_type |= CWM_RESIZE_TOP;
        else if (end_y > y22)
          resize_type |= CWM_RESIZE_BOTTOM;
      }

      if (! resize_started &&
          (abs(end_x - start_x) >= resize_tolerance_ ||
           abs(end_y - start_y) >= resize_tolerance_))
        resize_started = true;

      if (resize_type & CWM_RESIZE_LEFT  ) x21 = x11 + (end_x - start_x);
      if (resize_type & CWM_RESIZE_TOP   ) y21 = y11 + (end_y - start_y);
      if (resize_type & CWM_RESIZE_RIGHT ) x22 = x12 + (end_x - start_x);
      if (resize_type & CWM_RESIZE_BOTTOM) y22 = y12 + (end_y - start_y);

      dx1 = x21 - x11;
      dy1 = y21 - y11;
      dx2 = x22 - x12;
      dy2 = y22 - y12;

      if (user->getWidth() + (dx2 - dx1) < window->getMinWidthHint()) {
        if (resize_type & CWM_RESIZE_LEFT)
          x21 = user->getWidth() - window->getMinWidthHint() + dx2 + x11;

        if (resize_type & CWM_RESIZE_RIGHT)
          x22 = window->getMinWidthHint() - user->getWidth() + dx1 + x12;

        dx1 = x21 - x11;
        dx2 = x22 - x12;
      }

      if (user->getHeight() + (dy2 - dy1) < window->getMinHeightHint()) {
        if (resize_type & CWM_RESIZE_TOP)
          y21 = user->getHeight() - window->getMinHeightHint() + dy2 + y11;

        if (resize_type & CWM_RESIZE_BOTTOM)
          y22 = window->getMinHeightHint() - user->getHeight() + dy1 + y12;

        dy1 = y21 - y11;
        dy2 = y22 - y12;
      }

      if (CwmResourceDataInst->getFeedbackResize() && resize_started)
        screen.showResizeFeedback();

      screen.updateResizeFeedback(window, dx2 - dx1, dy2 - dy1);

      if (resize_started)
        screen.drawOutline(x21, y21, x22 - x21, y22 - y21);
    }
    else if (event->type == KeyPress) {
      if (CwmXEventInst->isEscapeKeyEvent(&event->xkey)) {
        escape_pressed = true;

        break;
      }
    }
    else if (event->type == KeyRelease) {
    }
    else if (event->type == EnterNotify) {
    }
    else if (event->type == LeaveNotify) {
    }
    else
      CwmMachineInst->logf("ResizeWindow: Unexpected event %d\n", event->type);
  }

  if (resize_started)
    screen.drawOutline(x21, y21, x22 - x21, y22 - y21);

  screen.hideResizeFeedback();

  screen.getRoot()->ungrab();

  if (! resize_started) {
    x21 = x11;
    y21 = y11;
    x22 = x12;
    y22 = y12;
  }

  if (escape_pressed) {
    if (! screen.getRoot()->grabPointer(event_mask, CWM_CURSOR_TITLE)) {
      CwmMachineInst->log("Grab Failed for Resize\n");
      return;
    }

    while (true) {
      XEvent *event = CwmEventMgrInst->processNextEvent();

      if (event->type == ButtonRelease)
        break;
    }

    x21 = x11;
    y21 = y11;
    x22 = x12;
    y22 = y12;

    screen.getRoot()->ungrabPointer();
  }

  if (x11 == x21 && y11 == y21 && x12 == x22 && y12 == y22)
    return;

  if (frame->getX() + dx1 < 0)
    dx1 = -frame->getX();

  if (frame->getY() + dy1 < 0)
    dy1 = -frame->getY();

  if (frame->getX() + frame->getWidth () + dx2 > screen.getWidth())
    dx2 = screen.getWidth()  - frame->getX() - frame->getWidth ();

  if (frame->getY() + frame->getHeight() + dy2 > screen.getHeight())
    dy2 = screen.getHeight() - frame->getY() - frame->getHeight();

  window->moveResize(frame->getX() + dx1,
                     frame->getY() + dy1,
                     frame->getWidth () + (dx2 - dx1),
                     frame->getHeight() + (dy2 - dy1));

  window->setNormal();

  window->redecorate();
}
##concat##CwmResourceData.cpp
#include <CwmI.h>

CwmResourceData *
CwmResourceData::
getInstance()
{
  static CwmResourceData *instance;

  if (! instance)
    instance = new CwmResourceData();

  return instance;
}

CwmResourceData::
CwmResourceData()
{
  loadMenus();

  loadDeskIcons();

  loadToolBarIcons();

  loadDesks();

  loadGroups();

  loadRoot();
}

CwmResourceData::
~CwmResourceData()
{
}

void
CwmResourceData::
save()
{
  CwmConfigInst->save();
}

CwmFeedbackType
CwmResourceData::
parseShowFeedback(const std::string &str)
{
  int feedback = CWM_FEEDBACK_NONE;

  CStrWords words = CStrUtil::toWords(str, 0);

  for (int i = 0; i < words.size(); i++) {
    std::string word = words[i].getWord();

    if (i == 0 && words[i].getWord()[0] == '-')
      feedback = CWM_FEEDBACK_ALL;
    else
      feedback = CWM_FEEDBACK_NONE;

    int add;

    if (word[0] == '-') {
      add = false;

      word = word.substr(1);
    }
    else
      add = true;

    int flag;

    if      (CStrUtil::casecmp(word, "all") == 0)
      flag = CWM_FEEDBACK_ALL;
    else if (CStrUtil::casecmp(word, "none") == 0)
      flag = CWM_FEEDBACK_NONE;
    else if (CStrUtil::casecmp(word, "move") == 0)
      flag = CWM_FEEDBACK_MOVE;
    else if (CStrUtil::casecmp(word, "resize") == 0)
      flag = CWM_FEEDBACK_RESIZE;
    else
      continue;

    if (add)
      feedback |= flag;
    else
      feedback &= ~flag;
  }

  return (CwmFeedbackType) feedback;
}

CwmIconDecoration
CwmResourceData::
parseIconDecoration(const std::string &str)
{
  int decoration = CWM_ICON_DECORATION_NONE;

  CStrWords words = CStrUtil::toWords(str, 0);

  for (int i = 0; i < words.size(); i++) {
    if      (CStrUtil::casecmp(words[i].getWord(), "label") == 0)
      decoration |= CWM_ICON_DECORATION_LABEL;
    else if (CStrUtil::casecmp(words[i].getWord(), "image") == 0)
      decoration |= CWM_ICON_DECORATION_IMAGE;
    else if (CStrUtil::casecmp(words[i].getWord(), "clip") == 0)
      decoration |= CWM_ICON_DECORATION_CLIP_LABEL;
    else if (CStrUtil::casecmp(words[i].getWord(), "activelabel") == 0)
      decoration |= CWM_ICON_DECORATION_ACTIVE_LABEL;
    else
      continue;
  }

  if (! (decoration & CWM_ICON_DECORATION_LABEL) &&
      ! (decoration & CWM_ICON_DECORATION_IMAGE))
    decoration |= CWM_ICON_DECORATION_LABEL;

  if (! (decoration & CWM_ICON_DECORATION_IMAGE))
    decoration &= ~CWM_ICON_DECORATION_CLIP_LABEL;

  return (CwmIconDecoration) decoration;
}

void
CwmResourceData::
parseFeedbackGeometry(const std::string &str, CHAlignType *halign, CVAlignType *valign,
                      int *x_offset, int *y_offset)
{
  *halign   = CHALIGN_TYPE_CENTER;
  *valign   = CVALIGN_TYPE_CENTER;
  *x_offset = 0;
  *y_offset = 0;

  CStrWords words = CStrUtil::toTokens(str, " ,");

  if (words.size() != 2)
    return;

  std::string word = words.getWord(0).getWord();

  if      (CStrUtil::casecmp(word, "left"  ) == 0)
    *halign = CHALIGN_TYPE_LEFT;
  else if (CStrUtil::casecmp(word, "right" ) == 0)
    *halign = CHALIGN_TYPE_RIGHT;
  else if (CStrUtil::casecmp(word, "center") == 0 ||
           CStrUtil::casecmp(word, "centre") == 0)
    *halign = CHALIGN_TYPE_CENTER;
  else {
    if (! CStrUtil::isInteger(word))
      return;

    *x_offset = CStrUtil::toInteger(word);
  }

  word = words.getWord(1).getWord();

  if      (CStrUtil::casecmp(word, "top"   ) == 0)
    *valign = CVALIGN_TYPE_TOP;
  else if (CStrUtil::casecmp(word, "bottom") == 0)
    *valign = CVALIGN_TYPE_BOTTOM;
  else if (CStrUtil::casecmp(word, "center") == 0 ||
           CStrUtil::casecmp(word, "centre") == 0)
    *valign = CVALIGN_TYPE_CENTER;
  else {
    if (! CStrUtil::isInteger(word))
      return;

    *y_offset = CStrUtil::toInteger(word);
  }
}

CwmFocusHighlightType
CwmResourceData::
parseFocusHighlightType(const std::string &str)
{
  CwmFocusHighlightType type = CWM_FOCUS_HIGHLIGHT_ALL;

  if      (CStrUtil::casecmp(str, "none") == 0)
    type = CWM_FOCUS_HIGHLIGHT_NONE;
  else if (CStrUtil::casecmp(str, "title") == 0)
    type = CWM_FOCUS_HIGHLIGHT_TITLE;
  else if (CStrUtil::casecmp(str, "all") == 0)
    type = CWM_FOCUS_HIGHLIGHT_ALL;
  else
    type = CWM_FOCUS_HIGHLIGHT_NONE;

  return type;
}

string
CwmResourceData::
getResource(const std::string &path, const std::string &fallback)
{
  std::string value = CwmConfigInst->getValue(path, fallback);

  return value;
}

string
CwmResourceData::
getSectionResource(const std::string &path, const std::string &section, const std::string &fallback)
{
  std::string value = CwmConfigInst->getSectionValue(path, section, fallback);

  return value;
}

int
CwmResourceData::
getSectionResource(const std::string &path, const std::string &section, int fallback)
{
  int value = CwmConfigInst->getSectionValue(path, section, fallback);

  return value;
}

string
CwmResourceData::
getBackground()
{
  return getResource("window/background", "white");
}

Pixel
CwmResourceData::
getBackground(CwmScreen &screen)
{
  return screen.getPixel(getBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getForeground()
{
  return getResource("window/foreground", "black");
}

Pixel
CwmResourceData::
getForeground(CwmScreen &screen)
{
  return screen.getPixel(getForeground(), screen.getBlackPixel());
}

CwmColor *
CwmResourceData::
getColor(CwmScreen &screen)
{
  return screen.getColor(getForeground(screen), getBackground(screen));
}

string
CwmResourceData::
getFont()
{
  std::string default_font_name = "8x13";

  return getResource("window/font", default_font_name);
}

CwmFont *
CwmResourceData::
getFont(CwmScreen &screen)
{
  return screen.getFont(getFont());
}

string
CwmResourceData::
getCursorBackground()
{
  return getResource("cursor/background", "black");
}

Pixel
CwmResourceData::
getCursorBackground(CwmScreen &screen)
{
  return screen.getPixel(getCursorBackground(), screen.getBlackPixel());
}

string
CwmResourceData::
getCursorForeground()
{
  return getResource("cursor/foreground", "white");
}

Pixel
CwmResourceData::
getCursorForeground(CwmScreen &screen)
{
  return screen.getPixel(getCursorForeground(), screen.getWhitePixel());
}

CwmColor *
CwmResourceData::
getCursorColor(CwmScreen &screen)
{
  return screen.getColor(getCursorForeground(screen), getCursorBackground(screen));
}

string
CwmResourceData::
getIconBackground()
{
  return getResource("icon/background", getBackground());
}

Pixel
CwmResourceData::
getIconBackground(CwmScreen &screen)
{
  return screen.getPixel(getIconBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getIconForeground()
{
  return getResource("icon/foreground", getForeground());
}

Pixel
CwmResourceData::
getIconForeground(CwmScreen &screen)
{
  return screen.getPixel(getIconForeground(), screen.getBlackPixel());
}

CwmColor *
CwmResourceData::
getIconColor(CwmScreen &screen)
{
  return screen.getColor(getIconForeground(screen), getIconBackground(screen));
}

string
CwmResourceData::
getIconFont()
{
  return getResource("icon/font", getFont());
}

CwmFont *
CwmResourceData::
getIconFont(CwmScreen &screen)
{
  return screen.getFont(getIconFont());
}

string
CwmResourceData::
getIconImage()
{
  return getResource("icon/image", "");
}

CwmIconDecoration
CwmResourceData::
getIconDecoration()
{
  std::string str = getResource("icon/decoration", "label image");

  return parseIconDecoration(str);
}

int
CwmResourceData::
getIconLabelWidth()
{
  std::string str = getResource("icon/labelWidth", "9999");

  if (CStrUtil::isInteger(str))
    return CStrUtil::toInteger(str);

  return 9999;
}

string
CwmResourceData::
getInfoBackground()
{
  return getResource("info/background", getBackground());
}

Pixel
CwmResourceData::
getInfoBackground(CwmScreen &screen)
{
  return screen.getPixel(getInfoBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getInfoForeground()
{
  return getResource("info/foreground", getBackground());
}

Pixel
CwmResourceData::
getInfoForeground(CwmScreen &screen)
{
  return screen.getPixel(getInfoForeground(), screen.getBlackPixel());
}

CwmColor *
CwmResourceData::
getInfoColor(CwmScreen &screen)
{
  return screen.getColor(getInfoForeground(screen), getInfoBackground(screen));
}

string
CwmResourceData::
getInfoFont()
{
  return getResource("info/font", getFont());
}

CwmFont *
CwmResourceData::
getInfoFont(CwmScreen &screen)
{
  return screen.getFont(getInfoFont());
}

string
CwmResourceData::
getFocusBackground()
{
  return getResource("window/focusBackground", getBackground());
}

Pixel
CwmResourceData::
getFocusBackground(CwmScreen &screen)
{
  return screen.getPixel(getFocusBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getFocusForeground()
{
  return getResource("window/focusForeground", getForeground());
}

Pixel
CwmResourceData::
getFocusForeground(CwmScreen &screen)
{
  return screen.getPixel(getFocusForeground(), screen.getBlackPixel());
}

CwmColor *
CwmResourceData::
getFocusColor(CwmScreen &screen)
{
  return screen.getColor(getFocusForeground(screen), getFocusBackground(screen));
}

string
CwmResourceData::
getFocusFont()
{
  return getResource("window/focusFont", getFont());
}

CwmFont *
CwmResourceData::
getFocusFont(CwmScreen &screen)
{
  return screen.getFont(getFocusFont());
}

bool
CwmResourceData::
getClickToFocus()
{
  std::string str = getResource("window/clickToFocus", "No");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return false;
}

bool
CwmResourceData::
getFocusAutoRaise()
{
  std::string str = getResource("window/focusAutoRaise", "No" );

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return false;
}

bool
CwmResourceData::
getFocusGrabKeys()
{
  std::string str = getResource("window/focusGrabKeys", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

CwmFocusHighlightType
CwmResourceData::
getFocusHighlightType()
{
  std::string str = getResource("window/focusHighlightType", "all");

  return parseFocusHighlightType(str);
}

bool
CwmResourceData::
getNoIconFocus()
{
  std::string str = getResource("window/focusNoIcon", "No" );

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return false;
}

string
CwmResourceData::
getMenuBackground()
{
  return getResource("menu/background", getBackground());
}

Pixel
CwmResourceData::
getMenuBackground(CwmScreen &screen)
{
  return screen.getPixel(getMenuBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getMenuForeground()
{
  return getResource("menu/foreground", getForeground());
}

Pixel
CwmResourceData::
getMenuForeground(CwmScreen &screen)
{
  return screen.getPixel(getMenuForeground(), screen.getBlackPixel());
}

string
CwmResourceData::
getMenuTitleBackground()
{
  return getSectionResource("menu/background", "title", getMenuBackground());
}

Pixel
CwmResourceData::
getMenuTitleBackground(CwmScreen &screen)
{
  return screen.getPixel(getMenuTitleBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getMenuTitleForeground()
{
  return getSectionResource("menu/foreground", "title", getMenuForeground());
}

Pixel
CwmResourceData::
getMenuTitleForeground(CwmScreen &screen)
{
  return screen.getPixel(getMenuTitleForeground(), screen.getBlackPixel());
}

string
CwmResourceData::
getMenuFont()
{
  return getResource("menu/font", getFont());
}

CwmFont *
CwmResourceData::
getMenuFont(CwmScreen &screen)
{
  return screen.getFont(getMenuFont());
}

string
CwmResourceData::
getMenuTitleFont()
{
  return getSectionResource("menu/font", "title", getMenuFont());
}

CwmFont *
CwmResourceData::
getMenuTitleFont(CwmScreen &screen)
{
  return screen.getFont(getMenuTitleFont());
}

CHAlignType
CwmResourceData::
getTitleAlign()
{
  std::string str = getSectionResource("window/align", "title", "center");

  if      (CStrUtil::casecmp(str, "left" ) == 0)
    return CHALIGN_TYPE_LEFT;
  else if (CStrUtil::casecmp(str, "right") == 0)
    return CHALIGN_TYPE_RIGHT;
  else
    return CHALIGN_TYPE_CENTER;
}

CwmTitlePatternType
CwmResourceData::
getTitlePatternType()
{
  std::string str = getSectionResource("window/titlePatternType", "title", "solid");

  if      (CStrUtil::casecmp(str, "solid"   ) == 0)
    return CWM_TITLE_PATTERN_SOLID;
  else if (CStrUtil::casecmp(str, "gradient") == 0)
    return CWM_TITLE_PATTERN_GRADIENT;
  else
    return CWM_TITLE_PATTERN_SOLID;
}

string
CwmResourceData::
getTitleForeground()
{
  return getSectionResource("window/titleForeground", "title", "#666666");
}

string
CwmResourceData::
getTitleBackground()
{
  return getSectionResource("window/titleBackground", "title", "#666666");
}

CwmColor *
CwmResourceData::
getTitleColor(CwmScreen &screen)
{
  Pixel fg = screen.getPixel(getTitleForeground(), screen.getBlackPixel());
  Pixel bg = screen.getPixel(getTitleBackground(), screen.getWhitePixel());

  return screen.getColor(fg, bg);
}

string
CwmResourceData::
getTitleFocusForeground()
{
  return getSectionResource("window/titleFocusForeground", "title", "#4c7fb2");
}

string
CwmResourceData::
getTitleFocusBackground()
{
  return getSectionResource("window/titleFocusBackground", "title", "#4c7fb2");
}

CwmColor *
CwmResourceData::
getTitleFocusColor(CwmScreen &screen)
{
  Pixel fg = screen.getPixel(getTitleFocusForeground(), screen.getBlackPixel());
  Pixel bg = screen.getPixel(getTitleFocusBackground(), screen.getWhitePixel());

  return screen.getColor(fg, bg);
}

string
CwmResourceData::
getTitleGradientForeground()
{
  return getSectionResource("window/gradientForeground", "title", "#999999");
}

string
CwmResourceData::
getTitleGradientBackground()
{
  return getSectionResource("window/gradientBackground", "title", "#7f7f7f");
}

CwmColor *
CwmResourceData::
getTitleGradientColor(CwmScreen &screen)
{
  Pixel fg = screen.getPixel(getTitleGradientForeground(), screen.getBlackPixel());
  Pixel bg = screen.getPixel(getTitleGradientBackground(), screen.getWhitePixel());

  return screen.getColor(fg, bg);
}

string
CwmResourceData::
getTitleGradientFocusForeground()
{
  return getSectionResource("window/gradientFocusForeground", "title", "#4c7fb2");
}

string
CwmResourceData::
getTitleGradientFocusBackground()
{
  return getSectionResource("window/gradientFocusBackground", "title", "#000099");
}

CwmColor *
CwmResourceData::
getTitleGradientFocusColor(CwmScreen &screen)
{
  Pixel fg = screen.getPixel(getTitleGradientFocusForeground(), screen.getBlackPixel());
  Pixel bg = screen.getPixel(getTitleGradientFocusBackground(), screen.getWhitePixel());

  return screen.getColor(fg, bg);
}

int
CwmResourceData::
getAutoRaiseDelay()
{
  std::string str = getResource("window/autoRaiseDelay", "500");

  if (CStrUtil::isInteger(str))
    return CStrUtil::toInteger(str);

  return 500;
}

bool
CwmResourceData::
getCirculateSkipIcons()
{
  std::string str = getResource("circulateSkipIcons", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

bool
CwmResourceData::
getClientAutoPlace()
{
  std::string str = getResource("clientAutoPlace", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

int
CwmResourceData::
getDoubleClickTime()
{
  std::string str = getResource("doubleClickTime", "500");

  int doubleClickTime = 0;

  if (CStrUtil::isInteger(str))
    doubleClickTime = CStrUtil::toInteger(str);
  else
    doubleClickTime = 0;

  if (doubleClickTime == 0)
    doubleClickTime = CwmMachineInst->getMulticlickTime();

  return doubleClickTime;
}

bool
CwmResourceData::
getEnableWarp()
{
  std::string str = getResource("enableWarp", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

bool
CwmResourceData::
getMoveOpaque()
{
  std::string str = getResource("window/moveOpaque", "No");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return false;
}

int
CwmResourceData::
getMoveThreshold()
{
  std::string str = getResource("window/moveThreshold", "4");

  if (CStrUtil::isInteger(str))
    return CStrUtil::toInteger(str);

  return 4;
}

bool
CwmResourceData::
getInteractivePlacement()
{
  std::string str = getResource("window/interactivePlacement", "No");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return false;
}

bool
CwmResourceData::
getPositionIsFrame()
{
  std::string str = getResource("window/positionIsFrame", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

bool
CwmResourceData::
getPositionOnScreen()
{
  std::string str = getResource("window/positionOnScreen", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

bool
CwmResourceData::
getWindowPressRaise()
{
  std::string str = getResource("window/pressRaise", "false");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return false;
}

CwmFeedbackType
CwmResourceData::
getFeedbackType()
{
  std::string str = getSectionResource("window/type", "feedback", "all");

  return parseShowFeedback(str);
}

string
CwmResourceData::
getFeedbackBackground()
{
  return getSectionResource("window/background", "feedback", getBackground());
}

Pixel
CwmResourceData::
getFeedbackBackground(CwmScreen &screen)
{
  return screen.getPixel(getFeedbackBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getFeedbackForeground()
{
  return getSectionResource("window/foreground", "feedback", getForeground());
}

Pixel
CwmResourceData::
getFeedbackForeground(CwmScreen &screen)
{
  return screen.getPixel(getFeedbackForeground(), screen.getBlackPixel());
}

string
CwmResourceData::
getFeedbackFont()
{
  return getSectionResource("window/font", "feedback", getFont());
}

CwmFont *
CwmResourceData::
getFeedbackFont(CwmScreen &screen)
{
  return screen.getFont(getFeedbackFont());
}

void
CwmResourceData::
getFeedbackGeometry(CHAlignType *halign, CVAlignType *valign, int *x_offset, int *y_offset)
{
  std::string str = getSectionResource("window/geometry", "feedback", "center,center");

  parseFeedbackGeometry(str, halign, valign, x_offset, y_offset);
}

string
CwmResourceData::
getToolBarBackground()
{
  return getResource("toolbar/background", getBackground());
}

Pixel
CwmResourceData::
getToolBarBackground(CwmScreen &screen)
{
  return screen.getPixel(getToolBarBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getToolBarForeground()
{
  return getResource("toolbar/foreground", getForeground());
}

Pixel
CwmResourceData::
getToolBarForeground(CwmScreen &screen)
{
  return screen.getPixel(getToolBarForeground(), screen.getBlackPixel());
}

string
CwmResourceData::
getToolBarFont()
{
  return getResource("toolbar/font", getFont());
}

CwmFont *
CwmResourceData::
getToolBarFont(CwmScreen &screen)
{
  return screen.getFont(getToolBarFont());
}

bool
CwmResourceData::
getToolBarShowClock()
{
  std::string str = getResource("toolbar/showClock", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

bool
CwmResourceData::
getToolBarAddIcons()
{
  std::string str = getResource("toolbar/addIcons", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

bool
CwmResourceData::
getToolBarAddWindows()
{
  std::string str = getResource("toolbar/addWindows", "Yes");

  if (CStrUtil::isBool(str))
    return CStrUtil::toBool(str);

  return true;
}

int
CwmResourceData::
getToolBarHeight()
{
  std::string str = getResource("toolbar/height", "28");

  if (CStrUtil::isInteger(str))
    return CStrUtil::toInteger(str);

  return 28;
}

int
CwmResourceData::
getToolBarIconWidth()
{
  std::string str = getResource("toolbar/iconWidth", "108");

  if (CStrUtil::isInteger(str))
    return CStrUtil::toInteger(str);

  return 108;
}

string
CwmResourceData::
getToolBarClockBackground()
{
  return getSectionResource("toolbar/background", "clock", getToolBarBackground());
}

Pixel
CwmResourceData::
getToolBarClockBackground(CwmScreen &screen)
{
  return screen.getPixel(getToolBarClockBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getToolBarClockForeground()
{
  return getSectionResource("toolbar/foreground", "clock", getToolBarForeground());
}

Pixel
CwmResourceData::
getToolBarClockForeground(CwmScreen &screen)
{
  return screen.getPixel(getToolBarClockForeground(), screen.getBlackPixel());
}

CwmColor *
CwmResourceData::
getToolBarClockColor(CwmScreen &screen)
{
  return screen.getColor(getToolBarClockForeground(screen), getToolBarClockBackground(screen));
}

string
CwmResourceData::
getToolBarClockFont()
{
  return getSectionResource("toolbar/font", "clock", getToolBarFont());
}

CwmFont *
CwmResourceData::
getToolBarClockFont(CwmScreen &screen)
{
  return screen.getFont(getToolBarClockFont());
}

string
CwmResourceData::
getToolBarClockTimeFormat()
{
  return getSectionResource("toolbar/timeFormat", "clock", "%H:%M:%S");
}

string
CwmResourceData::
getToolBarIconBackground()
{
  return getSectionResource("toolbar/background", "icon", getToolBarBackground());
}

Pixel
CwmResourceData::
getToolBarIconBackground(CwmScreen &screen)
{
  return screen.getPixel(getToolBarIconBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getToolBarIconForeground()
{
  return getSectionResource("toolbar/foreground", "icon", getToolBarForeground());
}

Pixel
CwmResourceData::
getToolBarIconForeground(CwmScreen &screen)
{
  return screen.getPixel(getToolBarIconForeground(), screen.getBlackPixel());
}

string
CwmResourceData::
getToolBarIconFont()
{
  return getSectionResource("toolbar/font", "icon", getToolBarFont());
}

CwmFont *
CwmResourceData::
getToolBarIconFont(CwmScreen &screen)
{
  return screen.getFont(getToolBarIconFont());
}

string
CwmResourceData::
getToolBarIconFocusBackground()
{
  return getSectionResource("toolbar/focusBackground", "icon", getToolBarIconBackground());
}

Pixel
CwmResourceData::
getToolBarIconFocusBackground(CwmScreen &screen)
{
  return screen.getPixel(getToolBarIconFocusBackground(), screen.getWhitePixel());
}

string
CwmResourceData::
getToolBarIconFocusForeground()
{
  return getSectionResource("toolbar/focusForeground", "icon", getToolBarIconForeground());
}

Pixel
CwmResourceData::
getToolBarIconFocusForeground(CwmScreen &screen)
{
  return screen.getPixel(getToolBarIconFocusForeground(), screen.getBlackPixel());
}

string
CwmResourceData::
getToolBarIconFocusFont()
{
  return getSectionResource("toolbar/focusFont", "icon", getToolBarIconFont());
}

CwmFont *
CwmResourceData::
getToolBarIconFocusFont(CwmScreen &screen)
{
  return screen.getFont(getToolBarIconFocusFont());
}

void
CwmResourceData::
loadMenus()
{
  StringVectorT names;
  StringVectorT paths;

  CwmConfigInst->getGroups("menus", names, paths);

  StringVectorT::iterator pname1 = names.begin();
  StringVectorT::iterator ppath1 = paths.begin();
  StringVectorT::iterator pname2 = names.end  ();

  for ( ; pname1 != pname2; ++pname1, ++ppath1) {
    CwmMenuDef *menu_def = loadMenu(*ppath1, *pname1);

    std::string name = CwmConfigInst->getValue(*ppath1 + "/name", *pname1);

    CwmNamedMenuMgrInst->define(name, menu_def);
  }
}

CwmMenuDef *
CwmResourceData::
loadMenu(const std::string &path, const std::string &)
{
  CwmMenuDef *menu_def = new CwmMenuDef();

  StringVectorT sections;

  CwmConfigInst->getSections(path, sections);

  StringVectorT::iterator psection1 = sections.begin();
  StringVectorT::iterator psection2 = sections.end  ();

  for ( ; psection1 != psection2; ++psection1) {
    if (CStrUtil::casecmp(*psection1, "") == 0)
      continue;

    std::string type =
      getSectionResource(path + "/type", *psection1, "button");

    if     (CStrUtil::casecmp(type, "title") == 0) {
      std::string name =
        getSectionResource(path + "/name", *psection1, "title");

      menu_def->addTitle(name);

      menu_def->addSplitter("----");
    }
    else if (CStrUtil::casecmp(type, "splitter") == 0) {
      menu_def->addSplitter("----");
    }
    else if (CStrUtil::casecmp(type, "button") == 0) {
      std::string name =
        getSectionResource(path + "/name", *psection1, "button");
      std::string image =
        getSectionResource(path + "/image", *psection1, "");
      std::string mnemonic =
        getSectionResource(path + "/mnemonic", *psection1, "");
      std::string accelerator =
        getSectionResource(path + "/accelerator", *psection1, "");
      std::string function =
        getSectionResource(path + "/function", *psection1, "f.null");
      std::string data =
        getSectionResource(path + "/data", *psection1, "");

      CwmFunctionDef *function_def = new CwmFunctionDef(function);

      function_def->setData(new string(data));

      menu_def->addButton(image, name,
                          (mnemonic.size() > 0 ? mnemonic[0] : '\0'), accelerator,
                          (CwmMenuProc) CwmFunctionDef::processProc, function_def);
    }
    else if (CStrUtil::casecmp(type, "toggle") == 0) {
      std::string name =
        getSectionResource(path + "/name", *psection1, "toggle");
      std::string image =
        getSectionResource(path + "/image", *psection1, "");
      std::string mnemonic =
        getSectionResource(path + "/mnemonic", *psection1, "");
      std::string accelerator =
        getSectionResource(path + "/accelerator", *psection1, "");
      std::string function =
        getSectionResource(path + "/function", *psection1, "f.null");
      std::string data =
        getSectionResource(path + "/data", *psection1, "");

      CwmFunctionDef *function_def = new CwmFunctionDef(function);

      function_def->setData(new string(data));

      menu_def->addToggle(image, name,
                          (mnemonic.size() > 0 ? mnemonic[0] : '\0'), accelerator,
                          (CwmMenuProc) CwmFunctionDef::processProc, function_def);
    }
    else if (CStrUtil::casecmp(type, "cascade") == 0) {
      std::string name =
        getSectionResource(path + "/name", *psection1, "cascade");
      std::string path1 =
        getSectionResource(path + "/path", *psection1, "cascade");

      CwmMenuDef *menu_def1 = loadMenu(path + "/" + path1, path1);

      menu_def->addCascade(name, menu_def1);
    }
  }

  return menu_def;
}

void
CwmResourceData::
loadDeskIcons()
{
  StringVectorT sections;

  CwmConfigInst->getSections("desk_icons", sections);

  StringVectorT::iterator psection1 = sections.begin();
  StringVectorT::iterator psection2 = sections.end  ();

  for ( ; psection1 != psection2; ++psection1)
    loadDeskIcon("desk_icons", *psection1);
}

void
CwmResourceData::
loadDeskIcon(const std::string &path, const std::string &section)
{
  std::string icon =
    getSectionResource(path + "/icon", section, "");
  std::string label =
    getSectionResource(path + "/label", section, "");
  std::string command =
    getSectionResource(path + "/command", section, "");
  std::string background =
    getSectionResource(path + "/background", section, "");
  std::string foreground =
    getSectionResource(path + "/foreground", section, "");
  int x =
    getSectionResource(path + "/x", section, 0);
  int y =
    getSectionResource(path + "/y", section, 0);

  CwmCustomIconMgrInst->addCustomIcon(icon, label, command, background, foreground, x, y);
}

void
CwmResourceData::
loadToolBarIcons()
{
  StringVectorT sections;

  CwmConfigInst->getSections("toolbar/icons", sections);

  StringVectorT::iterator psection1 = sections.begin();
  StringVectorT::iterator psection2 = sections.end  ();

  for ( ; psection1 != psection2; ++psection1)
    loadToolBarIcon("toolbar/icons", *psection1);
}

void
CwmResourceData::
loadToolBarIcon(const std::string &path, const std::string &section)
{
  std::string icon  = getSectionResource(path + "/icon" , section, "");
  std::string label = getSectionResource(path + "/label", section, "");

  bool add_display = false;

  std::string command = getSectionResource(path + "/command", section, "");

  if (command == "") {
    add_display = true;

    command = getSectionResource(path + "/xcommand", section, "");
  }

  std::string background = getSectionResource(path + "/background", section, "");
  std::string foreground = getSectionResource(path + "/foreground", section, "");

  CwmToolBarIconDefMgrInst->addToolBarIcon(icon, label, command, add_display,
                                           background, foreground);
}

void
CwmResourceData::
loadDesks()
{
  StringVectorT sections;

  CwmConfigInst->getSections("desks", sections);

  StringVectorT::iterator psection1 = sections.begin();
  StringVectorT::iterator psection2 = sections.end  ();

  for ( ; psection1 != psection2; ++psection1) {
    int num =
      getSectionResource("desks/num", *psection1, 1);
    std::string name =
      getSectionResource("desks/name", *psection1, "");
    std::string icons =
      getSectionResource("desks/icons", *psection1, "no");
    std::string toolbar =
      getSectionResource("desks/toolbar", *psection1, "yes");
    std::string image =
      getSectionResource("desks/image", *psection1, "");

    CwmDeskResourceMgrInst->setDeskName(num - 1, name);

    CwmDeskResourceMgrInst->setDeskDisplayIcons
     (num - 1, CStrUtil::toBool(icons));
    CwmDeskResourceMgrInst->setDeskDisplayToolBar
     (num - 1, CStrUtil::toBool(toolbar));

    if (image != "")
      CwmDeskResourceMgrInst->setDeskImage(num - 1, image);
  }
}

void
CwmResourceData::
loadGroups()
{
  StringVectorT names;
  StringVectorT paths;

  CwmConfigInst->getGroups("groups", names, paths);

  StringVectorT::iterator pname1 = names.begin();
  StringVectorT::iterator ppath1 = paths.begin();
  StringVectorT::iterator pname2 = names.end  ();

  for ( ; pname1 != pname2; ++pname1, ++ppath1) {
    std::string pattern =
      CwmConfigInst->getValue(*ppath1 + "/pattern", "");
    std::string icon =
      CwmConfigInst->getValue(*ppath1 + "/icon", "");
    std::string iconSmall =
      CwmConfigInst->getValue(*ppath1 + "/iconSmall", "");
    std::string decorations =
      CwmConfigInst->getValue(*ppath1 + "/decorations", "");
    std::string functions =
      CwmConfigInst->getValue(*ppath1 + "/functions", "");
    std::string focusAutoRaise =
      CwmConfigInst->getValue(*ppath1 + "/focusAutoRaise", "");
    std::string circulateSkip =
      CwmConfigInst->getValue(*ppath1 + "/circulateSkip", "");
    std::string toolbarSkip =
      CwmConfigInst->getValue(*ppath1 + "/toolbarSkip", "");

    if (icon != "")
      CwmCustomDeskIconMgrInst->setIcon(pattern, icon);

    if (iconSmall != "")
      CwmCustomDeskIconMgrInst->setIconSmall(pattern, iconSmall);

    if (decorations != "") {
      long flags = stringToDecorations(decorations);

      CwmCustomHintMgrInst->
       addCustomHintValue(pattern, CwmNdecorations, CwmTint, (CwmData) flags);
    }

    if (functions != "") {
      long flags = stringToFunctions(functions);

      CwmCustomHintMgrInst->
       addCustomHintValue(pattern, CwmNfunctions, CwmTint, (CwmData) flags);
    }

    if (focusAutoRaise != "")
      CwmCustomHintMgrInst->
       addCustomHintValue(pattern, CwmNfocusAutoRaise, CwmTint,
                          (CwmData) CStrUtil::toBool(focusAutoRaise));

    if (circulateSkip != "")
      CwmCustomHintMgrInst->
       addCustomHintValue(pattern, CwmNcirculateSkip, CwmTint,
                          (CwmData) CStrUtil::toBool(circulateSkip));

    if (toolbarSkip != "")
      CwmCustomHintMgrInst->
       addCustomHintValue(pattern, CwmNtoolbarSkip, CwmTint,
                          (CwmData) CStrUtil::toBool(toolbarSkip));

    loadGroupEvents(pattern, *ppath1 + "/events");
  }
}

void
CwmResourceData::
loadGroupEvents(const std::string &pattern, const std::string &path)
{
  StringVectorT sections;

  CwmConfigInst->getSections(path, sections);

  StringVectorT::iterator psection1 = sections.begin();
  StringVectorT::iterator psection2 = sections.end  ();

  for ( ; psection1 != psection2; ++psection1) {
    std::string area =
      getSectionResource(path + "/area", *psection1, "");
    std::string event =
      getSectionResource(path + "/event", *psection1, "");
    std::string function =
      getSectionResource(path + "/function", *psection1, "");
    std::string data =
      getSectionResource(path + "/data", *psection1, "");

    int area1 = stringToArea(area);

    CXNamedEvent *event1 = new CXNamedEvent(event);

    if (event1->getEvent() == 0) {
      CwmMachineInst->logf("Bad Event %s\n", event.c_str());
      delete event1;
      continue;
    }

    CwmFunctionDef *function1 = new CwmFunctionDef(function);

    if (function1 == 0) {
      CwmMachineInst->logf("Bad Function %s\n", event.c_str());
      delete event1;
      continue;
    }

    CwmWindowEventFunctionMgrInst->
      addPatternEventFunction(pattern, area1, event1, function1, (CwmData) new string(data));
  }
}

void
CwmResourceData::
loadRoot()
{
  std::string image = getResource("root/image", "");

  if (image != "")
    CwmInst->setRootImage(image);

  loadRootEvents();
}

void
CwmResourceData::
loadRootEvents()
{
  StringVectorT sections;

  CwmConfigInst->getSections("root/events", sections);

  StringVectorT::iterator psection1 = sections.begin();
  StringVectorT::iterator psection2 = sections.end  ();

  for ( ; psection1 != psection2; ++psection1) {
    std::string event    =
      getSectionResource("root/events/event"   , *psection1, "");
    std::string function =
      getSectionResource("root/events/function", *psection1, "");
    std::string data     =
      getSectionResource("root/events/data"    , *psection1, "");

    CXNamedEvent *event1 = new CXNamedEvent(event);

    if (event1->getEvent() == 0) {
      CwmMachineInst->logf("Bad Event %s\n", event.c_str());
      delete event1;
      continue;
    }

    CwmFunctionDef *function1 = new CwmFunctionDef(function);

    if (function1 == 0) {
      CwmMachineInst->logf("Bad Function %s\n", event.c_str());
      delete event1;
      continue;
    }

    CwmRootEventFunctionMgrInst->add(event1, function1, new string(data));
  }
}

void
CwmResourceData::
loadStartupCommands(CwmScreen &screen)
{
  StringVectorT sections;

  CwmConfigInst->getSections("startup", sections);

  StringVectorT::iterator psection1 = sections.begin();
  StringVectorT::iterator psection2 = sections.end  ();

  for ( ; psection1 != psection2; ++psection1)
    loadStartupCommand(screen, "startup", *psection1);
}

void
CwmResourceData::
loadStartupCommand(CwmScreen &screen, const std::string &path, const std::string &section)
{
  bool add_display = false;

  std::string command = getSectionResource(path + "/command", section, "");

  if (command == "") {
    add_display = true;

    command = getSectionResource(path + "/xcommand", section, "");
  }

  UnixCmd cmd(screen, command);

  cmd.setAddDisplay(add_display);

  cmd.run();
}

int
CwmResourceData::
stringToDecorations(const std::string &str)
{
  int decorations = 0;

  StringVectorT words;

  CStrUtil::addWords(str, words);

  for (int i = 0; i < (int) words.size(); i++) {
    std::string word = words[i];

    if (i == 0) {
      if (word[0] == '-')
        decorations = MWM_DECOR_BORDER   | MWM_DECOR_RESIZEH |
                      MWM_DECOR_TITLE    | MWM_DECOR_MENU    |
                      MWM_DECOR_MINIMIZE | MWM_DECOR_MAXIMIZE;
      else
        decorations = 0;
    }

    bool add = true;

    if (word[0] == '-') {
      add = false;

      word = word.substr(1);
    }

    int flag = 0;

    if      (CStrUtil::casecmp(word, "none") == 0)
      flag = 0;
    else if (CStrUtil::casecmp(word, "all") == 0)
      flag = MWM_DECOR_BORDER   | MWM_DECOR_RESIZEH |
             MWM_DECOR_TITLE    | MWM_DECOR_MENU    |
             MWM_DECOR_MINIMIZE | MWM_DECOR_MAXIMIZE;
    else if (CStrUtil::casecmp(word, "border") == 0)
      flag = MWM_DECOR_BORDER;
    else if (CStrUtil::casecmp(word, "resizeh") == 0)
      flag = MWM_DECOR_RESIZEH;
    else if (CStrUtil::casecmp(word, "title") == 0)
      flag = MWM_DECOR_TITLE;
    else if (CStrUtil::casecmp(word, "menu") == 0)
      flag = MWM_DECOR_MENU;
    else if (CStrUtil::casecmp(word, "minimize") == 0)
      flag = MWM_DECOR_MINIMIZE;
    else if (CStrUtil::casecmp(word, "maximize") == 0)
      flag = MWM_DECOR_MAXIMIZE;

    if (add)
      decorations |= flag;
    else
      decorations &= ~flag;
  }

  return decorations;
}

int
CwmResourceData::
stringToFunctions(const std::string &str)
{
  int functions = 0;

  StringVectorT words;

  CStrUtil::addWords(str, words);

  for (int i = 0; i < (int) words.size(); i++) {
    std::string word = words[i];

    if (i == 0) {
      if (word[0] == '-')
        functions = MWM_FUNC_RESIZE   | MWM_FUNC_MOVE     |
                    MWM_FUNC_MINIMIZE | MWM_FUNC_MAXIMIZE |
                    MWM_FUNC_CLOSE    | MWM_FUNC_RESTORE;
      else
        functions = 0;
    }

    bool add = true;

    if (word[0] == '-') {
      add = false;

      word = word.substr(1);
    }

    int flag = 0;

    if      (CStrUtil::casecmp(word, "none") == 0)
      flag = 0;
    else if (CStrUtil::casecmp(word, "all") == 0)
      flag = MWM_FUNC_RESIZE   | MWM_FUNC_MOVE     |
             MWM_FUNC_MINIMIZE | MWM_FUNC_MAXIMIZE |
             MWM_FUNC_CLOSE    | MWM_FUNC_RESTORE;
    else if (CStrUtil::casecmp(word, "resize") == 0)
      flag = MWM_FUNC_RESIZE;
    else if (CStrUtil::casecmp(word, "move") == 0)
      flag = MWM_FUNC_MOVE;
    else if (CStrUtil::casecmp(word, "minimize") == 0)
      flag = MWM_FUNC_MINIMIZE;
    else if (CStrUtil::casecmp(word, "maximize") == 0)
      flag = MWM_FUNC_MAXIMIZE;
    else if (CStrUtil::casecmp(word, "close") == 0)
      flag = MWM_FUNC_CLOSE;
    else if (CStrUtil::casecmp(word, "restore") == 0)
      flag = MWM_FUNC_RESTORE;

    if (add)
      functions |= flag;
    else
      functions &= ~flag;
  }

  return functions;
}

int
CwmResourceData::
stringToArea(const std::string &str)
{
  if      (CStrUtil::casecmp(str, "Menu") == 0)
    return CWM_WINDOW_MENU_AREA;
  else if (CStrUtil::casecmp(str, "Title") == 0)
    return CWM_WINDOW_TITLE_AREA;
  else if (CStrUtil::casecmp(str, "Minimize") == 0)
    return CWM_WINDOW_MINIMIZE_AREA;
  else if (CStrUtil::casecmp(str, "Maximize") == 0)
    return CWM_WINDOW_MAXIMIZE_AREA;
  else if (CStrUtil::casecmp(str, "Border") == 0)
    return CWM_WINDOW_BORDER_AREA;
  else if (CStrUtil::casecmp(str, "User") == 0)
    return CWM_WINDOW_USER_AREA;
  else if (CStrUtil::casecmp(str, "Any") == 0)
    return CWM_WINDOW_ANY_AREA;
  else
    return CWM_WINDOW_ANY_AREA;
}
##concat##CwmRoot.cpp
#include <CwmI.h>
#include <sstream>
#include <iomanip>

struct CwmRootImageSpec {
  friend class CwmRootImage;

 private:
  std::string image_file_;
  std::string bg_color_;
  std::string fg_color_;
  int    bgindex_;
  bool   resize_image_;
  bool   tile_image_;
  bool   aspect_;
  int    halign_;
  int    valign_;

 public:
  CwmRootImageSpec(string spec) :
   image_file_(""), bg_color_("white"), fg_color_("black"), bgindex_(-1), resize_image_(false),
   tile_image_(false), aspect_(false), halign_(CHALIGN_TYPE_CENTER), valign_(CVALIGN_TYPE_CENTER) {
    decode(spec);
  }

 private:
  bool decode(string spec);
};

CwmRootEventFunctionMgr *
CwmRootEventFunctionMgr::
getInstance()
{
  static CwmRootEventFunctionMgr *instance;

  if (! instance) {
    instance = new CwmRootEventFunctionMgr();

    instance->addFunctions();
  }

  return instance;
}

CwmRootEventFunctionMgr::
CwmRootEventFunctionMgr()
{
}

void
CwmRootEventFunctionMgr::
addFunctions()
{
  CXNamedEvent   *event    = new CXNamedEvent("<Button3>");
  CwmFunctionDef *function = new CwmFunctionDef("f.menu");

  std::string *data = new string("Root Functions");

  add(event, function, data);
}

void
CwmRootEventFunctionMgr::
add(CXNamedEvent *event, CwmFunctionDef *function, CwmData data)
{
  if (event == 0)
    return;

  int num_functions = functions_.size();

  for (int i = 0; i < num_functions; i++) {
    CXNamedEvent *event1 = functions_[i]->getEvent();

    if (event1 != 0 && event1->matchEvent(event)) {
      functions_[i]->setFunction(function, data);

      return;
    }
  }

  CwmRootEventFunction *root_event_function =
    new CwmRootEventFunction(event, function, data);

  functions_.push_back(root_event_function);
}

void
CwmRootEventFunctionMgr::
process(CwmScreen &screen, XEvent *event)
{
  int num_functions = functions_.size();

  for (int i = 0; i < num_functions; i++) {
    CXNamedEvent *event1 = functions_[i]->getEvent();

    if (event1->matchEvent(event)) {
      functions_[i]->process(screen);
      return;
    }
  }
}

void
CwmRootEventFunctionMgr::
deleteAll()
{
  int num_functions = functions_.size();

  for (int i = 0; i < num_functions; i++)
    delete functions_[i];

  functions_.clear();
}

CwmRootEventFunction::
CwmRootEventFunction(CXNamedEvent *event, CwmFunctionDef *function, CwmData data) :
 event_(event), function_(function), data_(data)
{
}

CwmRootEventFunction::
~CwmRootEventFunction()
{
  delete event_;
}

CwmRootImage::
CwmRootImage(CwmScreen &screen, const std::string &spec) :
 screen_(screen), image_(0), x_(0), y_(0), bg_(0), fg_(0), bgindex_(-1)
{
  CwmRootImageSpec image_spec(spec);

  // TODO: use aspect ratio flag for resize

  bgindex_ = image_spec.bgindex_;

  bg_ = screen_.getPixel(image_spec.bg_color_, screen_.getWhitePixel());
  fg_ = screen_.getPixel(image_spec.fg_color_, screen_.getBlackPixel());

  CwmColor *color = screen_.getColor(fg_, bg_);

  CRGBA fg_rgba = color->getFgRGBA();
  CRGBA bg_rgba = color->getBgRGBA();

  x_ = 0;
  y_ = 0;

  image_ = 0;

  if (image_spec.image_file_.size() == 0)
    return;

  if      (image_spec.resize_image_) {
    image_ = CwmImageMgrInst->getImage(screen_, image_spec.image_file_, screen_.getWidth(),
                                       screen_.getHeight());
  }
  else if (image_spec.tile_image_) {
    image_ = CwmImageMgrInst->getTiledImage(screen_, image_spec.image_file_,
                                            screen_.getWidth (), screen_.getHeight(),
                                            image_spec.halign_, image_spec.valign_);
  }
  else {
    image_ = CwmImageMgrInst->getImage(screen_, image_spec.image_file_);

    if (image_ != 0) {
      if (image_spec.halign_ == CHALIGN_TYPE_CENTER)
        x_ = (screen_.getWidth() - image_->getWidth())/2;
      else
        x_ = screen_.getWidth() - image_->getWidth();

      if (x_ < 0)
        x_ = 0;

      if (image_spec.valign_ == CVALIGN_TYPE_CENTER)
        y_ = (screen_.getHeight() - image_->getHeight())/2;
      else
        y_ = screen_.getHeight() - image_->getHeight();

      if (y_ < 0)
        y_ = 0;
    }
  }

  if (image_ == 0)
    return;

  CImagePtr cimage = image_->getImage();

  if (cimage->getNumColors() == 2) {
    cimage->setColor(0, bg_rgba);
    cimage->setColor(1, fg_rgba);
  }
}

CwmRootImage::
~CwmRootImage()
{
}

void
CwmRootImage::
draw()
{
  if (image_ == 0)
    return;

  if (! screen_.getRoot()->grabPointer(0, CWM_CURSOR_BUSY))
    return;

  CImagePtr image1 = image_->getImage();

  CwmColor *color = 0;

  if (bgindex_ != -1 && image1->hasColormap()) {
    double r, g, b, a;

    image1->getColorRGBA(bgindex_, &r, &g, &b, &a);

    std::ostringstream ostr;

    ostr << "#" << std::setw(2) << std::setfill('0') << (int) (r*255) <<
                   std::setw(2) << std::setfill('0') << (int) (g*255) <<
                   std::setw(2) << std::setfill('0') << (int) (b*255);

    Pixel pixel = screen_.getPixel(ostr.str(), screen_.getWhitePixel());

    color = screen_.getColor(pixel, pixel);
  }

  CwmGraphics *graphics = new CwmGraphics(screen_, 0, color);

  CwmXPixmap *xpixmap =
    new CwmXPixmap(screen_, screen_.getWidth(), screen_.getHeight());

  graphics->fillRectangle(xpixmap, 0, 0, screen_.getWidth(), screen_.getHeight());

  image_->draw(screen_.getRoot(), graphics, 0, 0);

  image_->draw(xpixmap, graphics, x_, y_);

  screen_.getRoot()->setBackgroundPixmap(xpixmap);

  screen_.getRoot()->clear();

  delete xpixmap;

  delete graphics;

  CwmMachineInst->flushEvents();

  const CXAtom &prop = CwmMachineInst->getXSetRootIdAtom();

  Pixmap pixmap;

  if (CwmMachineInst->getPixmapProperty(screen_.getRoot()->getXWin(), prop, &pixmap))
    CwmMachineInst->killClient(pixmap);

  CwmMachineInst->deleteProperty(screen_.getRoot()->getXWin(), prop);

  CwmMachineInst->flushEvents();

  screen_.refresh();

  screen_.getRoot()->ungrabPointer();
}

bool
CwmRootImageSpec::
decode(string spec)
{
  CStrWords words = CStrUtil::toWords(spec, 0);

  if (words.size() == 0)
    return false;

  image_file_ = words[0].getWord();

  for (int i = 1; i < words.size(); i++) {
    std::string word = words[i].getWord();

    if      (CStrUtil::casecmp(word, "resize") == 0)
      resize_image_ = true;
    else if (CStrUtil::casecmp(word, "tile") == 0)
      tile_image_ = true;
    else if (CStrUtil::casecmp(word, "bg") == 0) {
      if (i < words.size() - 1) {
        word = words[++i].getWord();

        bg_color_ = word;
      }
      else
        CwmMachineInst->log("Missing color for bg\n");
    }
    else if (CStrUtil::casecmp(word, "fg") == 0) {
      if (i < words.size() - 1) {
        word = words[++i].getWord();

        fg_color_ = word;
      }
      else
        CwmMachineInst->log("Missing color for fg\n");
    }
    else if (CStrUtil::casecmp(word, "halign") == 0) {
      if (i < words.size() - 1) {
        i++;

        word = words[i].getWord();

        if      (CStrUtil::casecmp(word, "left") == 0)
          halign_ = CHALIGN_TYPE_LEFT;
        else if (CStrUtil::casecmp(word, "right") == 0)
          halign_ = CHALIGN_TYPE_RIGHT;
        else if (CStrUtil::casecmp(word, "center") == 0 ||
                 CStrUtil::casecmp(word, "center") == 0)
          halign_ = CHALIGN_TYPE_CENTER;
        else
          CwmMachineInst->logf("Missing value for halign - %s\n", word.c_str());
      }
      else
        CwmMachineInst->log("Missing value for halign\n");
    }
    else if (CStrUtil::casecmp(word, "valign") == 0) {
      if (i < words.size() - 1) {
        i++;

        word = words[i].getWord();

        if      (CStrUtil::casecmp(word, "top") == 0)
          valign_ = CVALIGN_TYPE_TOP;
        else if (CStrUtil::casecmp(word, "bottom") == 0)
          valign_ = CVALIGN_TYPE_BOTTOM;
        else if (CStrUtil::casecmp(word, "center") == 0 ||
                 CStrUtil::casecmp(word, "center") == 0)
          valign_ = CVALIGN_TYPE_CENTER;
        else
          CwmMachineInst->logf("Missing value for valign - %s\n", word.c_str());
      }
      else
        CwmMachineInst->log("Missing value for valign\n");
    }
    else if (CStrUtil::casecmp(word, "bgindex") == 0) {
      if (i < words.size() - 1) {
        word = words[++i].getWord();

        bgindex_ = CStrUtil::toInteger(word);
      }
      else
        CwmMachineInst->log("Missing value for bgindex\n");
    }
    else if (CStrUtil::casecmp(word, "aspect") == 0)
      aspect_ = true;
    else
      CwmMachineInst->logf("Invalid root image option %s\n", word.c_str());
  }

  return true;
}
##concat##CwmScreen.cpp
#include <CwmI.h>
#include <CXScreen.h>
#include <X11/XKBlib.h>
#include <climits>

CwmScreenMgr::
CwmScreenMgr()
{
}

CwmScreenMgr::
~CwmScreenMgr()
{
  term();
}

void
CwmScreenMgr::
term()
{
  std::for_each(screen_num_map_.begin(), screen_num_map_.end(),
                CDeleteMapSecond<ScreenNumMap>());

  screen_num_map_ .clear();
  screen_root_map_.clear();
}

CwmScreen &
CwmScreenMgr::
getScreenByNum(int screen_num)
{
  ScreenNumMap::iterator pscreen = screen_num_map_.find(screen_num);

  if (pscreen != screen_num_map_.end())
    return *(*pscreen).second;

  int num_screens = CwmMachineInst->getNumScreens();

  if (screen_num < 0 || screen_num >= num_screens) {
    CwmMachineInst->log("Invalid Screen Number " +
                        CStrUtil::toString(screen_num) + "\n");
    return getScreenByNum(0);
  }

  return *addScreen(screen_num);
}

CwmScreen &
CwmScreenMgr::
getScreenByWindow(Window xwin)
{
  if (! CwmMachineInst->isValidWindow(xwin)) {
    CwmMachineInst->log("Invalid Window " +
                        CStrUtil::toString(xwin) + "\n");
    return getScreenByNum(0);
  }

  Window root = CwmMachineInst->getWindowRoot(xwin);

  if (root == None) {
    CwmMachineInst->log("No Root for Window " +
                        CStrUtil::toString(xwin) + "\n");
    return getScreenByNum(0);
  }

  ScreenRootMap::iterator pscreen = screen_root_map_.find(root);

  if (pscreen != screen_root_map_.end())
    return *(*pscreen).second;

  CwmMachineInst->log("No Screen Found for Window " +
                      CStrUtil::toString(xwin) + "\n");

  return getScreenByNum(0);
}

CwmScreen *
CwmScreenMgr::
addScreen(int screen_num)
{
  CwmScreen *screen = new CwmScreen(screen_num);

  Window root = screen->getRoot()->getXWin();

  screen_num_map_ [screen_num] = screen;
  screen_root_map_[root      ] = screen;

  return screen;
}

void
CwmScreenMgr::
disableScreens()
{
  ScreenNumMap::iterator p1 = screen_num_map_.begin();
  ScreenNumMap::iterator p2 = screen_num_map_.end  ();

  for ( ; p1 != p2; ++p1)
    (*p1).second->disable();
}

void
CwmScreenMgr::
enableScreens()
{
  ScreenNumMap::iterator p1 = screen_num_map_.begin();
  ScreenNumMap::iterator p2 = screen_num_map_.end  ();

  for ( ; p1 != p2; ++p1)
    (*p1).second->enable();
}

//-----------------

CwmScreen::
CwmScreen(int screen_num) :
 num_(screen_num)
{
  default_x_ = 0;
  default_y_ = 0;

  //------

  cxscreen_ = new CXScreen(screen_num);

  //------

  root_ = new CwmWindow(*this, cxscreen_->getRoot(),
                        0, 0, cxscreen_->getWidth(), cxscreen_->getHeight(),
                        true);

  //------

  color_mgr_ = new CwmColorMgr(*this);
  font_mgr_  = new CwmFontMgr (*this);

  //------

  CwmFont  *font  = CwmResourceDataInst->getFont (*this);
  CwmColor *color = CwmResourceDataInst->getColor(*this);

  //------

  graphics_     = new CwmGraphics(*this, font, color);
  xor_graphics_ = new CwmGraphics(*this, font, color, true);

  //------

  colormap_mgr_ = new CwmColormapMgr(*this);

  cursor_mgr_ = new CwmCursorMgr(*this);

  icon_grid_ = new CwmGrid(*this, 16, 16);

  move_feedback_   = new CwmMoveFeedback  (*this);
  resize_feedback_ = new CwmResizeFeedback(*this);

  info_ = new CwmInfo(*this);

  desk_mgr_ = new CwmDeskMgr(*this, 4);

  desk_mgr_->changeDesk(0);

  //------

  window_stack_ = new CwmCirculateWindowStack(*this);

  tab_window_ = new CwmTabWindow(*this);

  CwmGnomeInst->init(*this);
}

CwmScreen::
~CwmScreen()
{
  delete icon_grid_;

  delete move_feedback_;
  delete resize_feedback_;

  delete info_;

  delete desk_mgr_;

  delete colormap_mgr_;

  delete cursor_mgr_;

  delete color_mgr_;

  delete window_stack_;

  delete graphics_;

  delete xor_graphics_;
}

CwmWMWindow *
CwmScreen::
addWMWindow(Window xwin)
{
  CwmWMWindow *window = CwmMachineInst->addWMWindow(*this, xwin);

  windows_.push_back(window);

  return window;
}

void
CwmScreen::
removeWMWindow(CwmWMWindow *window)
{
  windows_.remove(window);
}

Colormap
CwmScreen::
getColormap() const
{
  return cxscreen_->getColormap();
}

int
CwmScreen::
getWidth() const
{
  return cxscreen_->getWidth();
}

int
CwmScreen::
getHeight() const
{
  return cxscreen_->getHeight();
}

int
CwmScreen::
getDepth() const
{
  return cxscreen_->getDepth();
}

Pixel
CwmScreen::
getBlackPixel() const
{
  return cxscreen_->getBlackPixel();
}

Pixel
CwmScreen::
getWhitePixel() const
{
  return cxscreen_->getWhitePixel();
}

CwmColor *
CwmScreen::
getColor(Pixel fg, Pixel bg)
{
  return color_mgr_->getColor(fg, bg);
}

Pixel
CwmScreen::
getPixel(const std::string &name, Pixel default_pixel)
{
  return color_mgr_->getPixel(name, default_pixel);
}

Pixel
CwmScreen::
getPixel(const CRGBA &rgba)
{
  return cxscreen_->rgbaToPixel(rgba);
}

CwmFont *
CwmScreen::
getFont(const std::string &name)
{
  return font_mgr_->getFont(name);
}

Cursor
CwmScreen::
getCursor(CwmCursorType type) const
{
  return cursor_mgr_->getCursor(type);
}

CwmCirculateWindowStack &
CwmScreen::
getCirculateWindowStack() const
{
  window_stack_->update();

  return *window_stack_;
}

int
CwmScreen::
getNumDesks()
{
  return desk_mgr_->getNumDesks();
}

CwmDesk *
CwmScreen::
getCurrentDesk()
{
  return desk_mgr_->getCurrentDesk();
}

int
CwmScreen::
getCurrentDeskNum()
{
  return desk_mgr_->getCurrentDeskNum();
}

CwmDesk *
CwmScreen::
getDesk(int num)
{
  return desk_mgr_->getDesk(num);
}

CwmDesk *
CwmScreen::
getDesk(CwmWMWindow *window)
{
  return desk_mgr_->getDesk(window);
}

int
CwmScreen::
getDeskNum(CwmWMWindow *window)
{
  return desk_mgr_->getDeskNum(window);
}

void
CwmScreen::
changeDesk(int desk_num)
{
  desk_mgr_->changeDesk(desk_num);
}

void
CwmScreen::
showInfo(const std::string &str) const
{
  info_->show(str);
}

void
CwmScreen::
hideInfo() const
{
  info_->hide();
}

void
CwmScreen::
showMoveFeedback()
{
  move_feedback_->show();
}

void
CwmScreen::
hideMoveFeedback()
{
  move_feedback_->hide();
}

void
CwmScreen::
updateMoveFeedback(int x, int y)
{
  move_feedback_->update(x, y);
}

void
CwmScreen::
showResizeFeedback()
{
  resize_feedback_->show();
}

void
CwmScreen::
hideResizeFeedback()
{
  resize_feedback_->hide();
}

void
CwmScreen::
updateResizeFeedback(CwmWMWindow *window, int dx, int dy)
{
  resize_feedback_->update(window, dx, dy);
}

void
CwmScreen::
refresh()
{
  cxscreen_->refresh();
}

void
CwmScreen::
installColormap(CwmWMWindow *window)
{
  colormap_mgr_->install(window);
}

void
CwmScreen::
uninstallColormap()
{
  colormap_mgr_->uninstall();
}

bool
CwmScreen::
isTop(CwmWMWindow *window) const
{
  return getCirculateWindowStack().isTop(window);
}

void
CwmScreen::
raise(CwmWMWindow *window) const
{
  getCirculateWindowStack().raise(window);
}

void
CwmScreen::
lower(CwmWMWindow *window) const
{
  getCirculateWindowStack().lower(window);
}

void
CwmScreen::
circulateUp() const
{
  getCirculateWindowStack().circulateUp();
}

void
CwmScreen::
circulateDown() const
{
  getCirculateWindowStack().circulateDown();
}

void
CwmScreen::
selectNext()
{
  CwmMachineInst->grabKeyboard(getRoot()->getXWin());

  uint timeout, interval;

  CwmMachineInst->getKeyAutoRepeatRate(&timeout, &interval);

  CwmMachineInst->setKeyAutoRepeatRate(UINT_MAX, UINT_MAX);

  CwmEventMgrInst->waitForKeyRelease(*this);

  CwmMachineInst->setKeyAutoRepeatRate(timeout, interval);

  CwmMachineInst->ungrabKeyboard();

  tab_window_->hide();
}

void
CwmScreen::
selectPrev()
{
}

void
CwmScreen::
installColormap(Colormap cmap)
{
  CwmMachineInst->installColormap(cmap);
}

void
CwmScreen::
getDefaultPos(int window_width, int window_height, int *x, int *y)
{
  *x = default_x_;
  *y = default_y_;

  if (*x + window_width > getWidth()) {
    default_x_ = 0;

    *x = default_x_;
  }

  if (*y + window_height > getHeight()) {
    default_y_ = 0;

    *y = default_y_;
  }

  default_x_ += 16;
  default_y_ += 16;
}

void
CwmScreen::
drawOutline(int x1, int y1, int width1, int height1)
{
  xor_graphics_->drawRectangle(getRoot(), x1, y1, width1 -2, height1 - 2);
}

CwmWindow *
CwmScreen::
getPointerWindow()
{
  Window xwin = cxscreen_->getPointerWindow();

  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(xwin);

  return xwindow;
}

Window
CwmScreen::
getCoordWindow(int x, int y)
{
  return cxscreen_->getCoordWindow(x, y);
}

bool
CwmScreen::
hasPointer()
{
  int x, y;

  return getRoot()->getPointerPosition(&x, &y);
}

void
CwmScreen::
updateCirculateWindowStack()
{
  window_stack_->update();
}

void
CwmScreen::
disable()
{
  desk_mgr_->disable();
}

void
CwmScreen::
enable()
{
  desk_mgr_->enable();
}

GC
CwmScreen::
createGC(CwmColor *color)
{
  GC gc;

  if (color != 0)
    gc = CwmMachineInst->createGC(color->getBg(), color->getFg());
  else
    gc = CwmMachineInst->createGC(0, 1);

  return gc;
}

GC
CwmScreen::
createXorGC(CwmColor *)
{
  GC gc = CwmMachineInst->createXorGC();

  return gc;
}

bool
CwmScreen::
selectWMInput()
{
  return cxscreen_->selectWMInput();
}

bool
CwmScreen::
getWindows(Window **windows, int *num_windows)
{
  return cxscreen_->getWindows(windows, num_windows);
}

void
CwmScreen::
processDeskMenu()
{
  desk_mgr_->processMenu();
}
##concat##CwmScreenMenu.cpp
#include <CwmI.h>

void
CwmScreenMenu::
moveProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  CwmMoveWindowInst->move(window);
}

void
CwmScreenMenu::
resizeProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  CwmResizeWindowInst->resize(window, CWM_RESIZE_FREE);
}

void
CwmScreenMenu::
iconiseProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->iconise();
}

void
CwmScreenMenu::
maximizeProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->maximize();
}

void
CwmScreenMenu::
minimizeProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->minimize();
}

void
CwmScreenMenu::
restoreProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->restoreSize();
}

void
CwmScreenMenu::
raiseProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->raise();
}

void
CwmScreenMenu::
lowerProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->lower();
}

void
CwmScreenMenu::
circulateUpProc(CwmScreen &screen, CwmData)
{
  screen.circulateUp();
}

void
CwmScreenMenu::
circulateDownProc(CwmScreen &screen, CwmData)
{
  screen.circulateDown();
}

void
CwmScreenMenu::
focusNextProc(CwmScreen &screen, CwmData)
{
  CwmMachineInst->focusNext(screen);
}

void
CwmScreenMenu::
focusPrevProc(CwmScreen &screen, CwmData)
{
  CwmMachineInst->focusPrev(screen);
}

void
CwmScreenMenu::
selectNextProc(CwmScreen &screen, CwmData)
{
  screen.selectNext();
}

void
CwmScreenMenu::
selectPrevProc(CwmScreen &screen, CwmData)
{
  screen.selectPrev();
}

void
CwmScreenMenu::
rollUpProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->rollUp();
}

void
CwmScreenMenu::
rollDownProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->rollDown();
}

void
CwmScreenMenu::
closeProc(CwmScreen &screen, CwmData)
{
  CwmWMWindow *window = CwmEventMgrInst->selectWindow(screen);

  if (window == 0)
    return;

  window->close();
}

void
CwmScreenMenu::
processNamedMenuProc(CwmScreen &screen, CwmData data)
{
  std::string *name = (string *) data;

  CwmMenu::processNamedMenu(screen, *name);
}

void
CwmScreenMenu::
runCommandProc(CwmScreen &screen, CwmData data)
{
  std::string *cmd = (string *) data;

  UnixCmd command(screen, *cmd);

  command.run();
}

void
CwmScreenMenu::
runXCommandProc(CwmScreen &screen, CwmData data)
{
  std::string *cmd = (string *) data;

  UnixCmd command(screen, *cmd);

  command.setAddDisplay(true);

  command.run();
}

void
CwmScreenMenu::
setRootImageProc(CwmScreen &screen, CwmData data)
{
  std::string *name = (string *) data;

  CwmDesk *desk = screen.getCurrentDesk();

  desk->setRootImage(*name);

  desk->drawRootImage();
}

void
CwmScreenMenu::
toggleDisplayedProc(CwmScreen &, CwmData)
{
}

void
CwmScreenMenu::
refreshCwmProc(CwmScreen &screen, CwmData)
{
  screen.refresh();
}

void
CwmScreenMenu::
restartCwmProc(CwmScreen &screen, CwmData data)
{
  std::string *cmd = (string *) data;

  if (cmd == 0 || *cmd == "") {
    int    argc;
    char **argv;

    CwmInst->getArgs(&argc, &argv);

    std::string cmd1;

    for (int i = 0; i < argc; ++i) {
      cmd1 += argv[i];
      cmd1 += " ";
    }

    CwmInst->restart(screen, cmd1);
  }
  else
    CwmInst->restart(screen, *cmd);
}

void
CwmScreenMenu::
quitCwmProc(CwmScreen &, CwmData)
{
  CwmInst->quit();
}

void
CwmScreenMenu::
changeDeskProc(CwmScreen &screen, CwmData data)
{
  std::string *str = (string *) data;

  int desk_num = CStrUtil::toInteger(*str);

  screen.changeDesk(desk_num - 1);
}
##concat##CwmTabWindow.cpp
#include <CwmI.h>

CwmTabWindow::
CwmTabWindow(CwmScreen &screen) :
 screen_(screen), xwindow_(0), graphics_(0)
{
  init();
}

CwmTabWindow::
~CwmTabWindow()
{
  delete graphics_;
  delete xwindow_;
}

void
CwmTabWindow::
show(const std::string &str)
{
  int x = screen_.getWidth ()/2;
  int y = screen_.getHeight()/2;

  int width, height;

  graphics_->getTextSize(str, &width, &height);

  width  += 4;
  height += 4;

  x -= width /2;
  y -= height/2;

  if (xwindow_ != 0  && str_    == str    &&
      x_       == x     && y_      == y      &&
      width_   == width && height_ == height)
    return;

  hide();

  str_    = str;
  x_      = x;
  y_      = y;
  width_  = width;
  height_ = height;

  xwindow_ =
    new CwmWindow(screen_, screen_.getRoot(),
                  x_, y_, width_, height_,
                  0, CWM_CURSOR_TITLE);

  xwindow_->setBackground(graphics_);

  xwindow_->mapRaised();

  graphics_->drawTextCentered(xwindow_,
                              2, 2, width_ - 4, height_ - 4,
                              str_);

  graphics_->drawButtonOut(xwindow_,
                           0, 0, width_, height_,
                           1);
}

void
CwmTabWindow::
hide()
{
  delete xwindow_;

  xwindow_ = 0;
}

void
CwmTabWindow::
init()
{
  CwmColor *color = CwmResourceDataInst->getInfoColor(screen_);
  CwmFont  *font  = CwmResourceDataInst->getInfoFont (screen_);

  graphics_ = new CwmGraphics(screen_, font, color);
}
##concat##CwmToolBarClock.cpp
#include <CwmToolBarI.h>
#include <CXtTimer.h>
#include <COSTime.h>

class CwmToolBarClockTimer : public CXtTimer {
 private:
  CwmToolBarClock *clock_;

 public:
  CwmToolBarClockTimer(CwmToolBarClock *clock);

  void timeOut();
};

CwmToolBarClock::
CwmToolBarClock(CwmToolBar &toolbar1) :
 toolbar_(toolbar1)
{
  CwmScreen &screen = toolbar_.getScreen();

  //------

  CwmColor *color = CwmResourceDataInst->getToolBarClockColor(screen);
  CwmFont  *font  = CwmResourceDataInst->getToolBarClockFont (screen);

  graphics_ = new CwmGraphics(screen, font, color);

  //------

  format_ = toolbar_.getTimeFormat();

  //------

  timer_ = 0;

  //------

  std::string time_string;

  if (format_ != "")
    time_string = COSTime::getTimeString(format_);
  else
    time_string = COSTime::getTimeString("%H:%M:%S");

  int len = time_string.size();

  for (int i = 0; i < len; i++)
    time_string[i] = 'X';

  int width1, height1;

  graphics_->getTextSize(time_string, &width1, &height1);

  int width = width1 + 4;

  int height = std::min(graphics_->getFontHeight() + 4, toolbar_.getHeight() - 6);

  //------

  xwindow_ =
    new CwmWindow(screen, toolbar_.getXWindow(), toolbar_.getWidth() - width - 4,
                  (toolbar_.getHeight() - height)/2, width, height, 0, CWM_CURSOR_TITLE);

  xwindow_->setBackground(graphics_);

  xwindow_->map();

  //------

  xwindow_->addCallback(CWM_CALLBACK_IDLE, &CwmToolBarClock::idleProc, (CwmData) this);

  enable();
}

CwmToolBarClock::
~CwmToolBarClock()
{
  delete xwindow_;
}

void
CwmToolBarClock::
redraw()
{
  xwindow_->clear();

  std::string time_string;

  if (format_ != "")
    time_string = COSTime::getTimeString(format_);
  else
    time_string = COSTime::getTimeString("%H:%M:%S");

  graphics_->drawTextCentered(xwindow_, 2, 2, xwindow_->getWidth() - 4,
                              xwindow_->getHeight() - 4, time_string);

  graphics_->drawButtonIn(xwindow_, 0, 0, xwindow_->getWidth(), xwindow_->getHeight(), 1);
}

void
CwmToolBarClock::
enable()
{
  redraw();

  delete timer_;

  timer_ = new CwmToolBarClockTimer(this);
}

void
CwmToolBarClock::
disable()
{
  delete timer_;

  timer_ = 0;
}

int
CwmToolBarClock::
getWidth() const
{
  return xwindow_->getWidth() + 2;
}

int
CwmToolBarClock::
getHeight() const
{
  return xwindow_->getHeight();
}

void
CwmToolBarClock::
idleProc(CwmWindow *, CwmData data, CwmData detail)
{
  CwmToolBarClock *clock      = (CwmToolBarClock *) data;
  CwmIdleState    *idle_state = (CwmIdleState    *) detail;

  CwmScreen &screen = clock->toolbar_.getScreen();

  if (idle_state->getActive()) {
    std::string time_string = COSTime::getTimeString("%c");

    screen.showInfo(time_string);
  }
  else
    screen.hideInfo();
}

CwmToolBarClockTimer::
CwmToolBarClockTimer(CwmToolBarClock *clock) :
 CXtTimer(1000, CTIMER_FLAGS_REPEAT), clock_(clock)
{
}

void
CwmToolBarClockTimer::
timeOut()
{
  clock_->redraw();
}
##concat##CwmToolBarCmd.cpp
#include <CwmToolBarI.h>

CwmToolBarCmd::
CwmToolBarCmd(CwmToolBar &toolbar, CwmToolBarIconDef *icon_def, int x) :
 toolbar_(toolbar), screen_(toolbar.getScreen())
{
  std::string fg_color = icon_def->getFg();

  if (fg_color == "")
    fg_color = CwmResourceDataInst->getIconForeground();

  Pixel fg = screen_.getPixel(fg_color, screen_.getBlackPixel());

  std::string bg_color = icon_def->getBg();

  if (bg_color == "")
    bg_color = CwmResourceDataInst->getIconBackground();

  Pixel bg = screen_.getPixel(bg_color, screen_.getWhitePixel());

  CwmColor *color = screen_.getColor(fg, bg);

  CwmFont *font = CwmResourceDataInst->getIconFont(screen_);

  graphics_ = new CwmGraphics(screen_, font, color);

  //------

  image_ = CwmImageMgrInst->getImage(screen_, icon_def->getIcon(),
                                     16, 16);

  if (image_ == 0)
    image_ = CwmImageMgrInst->getImage(screen_, "", 16, 16);

  //------

  command_ = icon_def->getCommand();

  add_display_ = icon_def->getAddDisplay();

  //------

  label_ = icon_def->getLabel();

  //------

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask   |
                    KeyPressMask    | ExposureMask;

  int y = (toolbar_.getHeight() - image_->getHeight())/2;

  xwindow_ =
    new CwmWindow(screen_, toolbar_.getXWindow(),
                   x + 2, y,
                   image_->getWidth () + 2,
                   image_->getHeight() + 2,
                   event_mask,
                   CWM_CURSOR_TITLE);

  //------

  active_  = false;
  pressed_ = false;

  //------

  xwindow_->addCallback(CWM_CALLBACK_ENTER,
                        CwmToolBarCmd::enterProc,
                        (CwmData) this);
  xwindow_->addCallback(CWM_CALLBACK_LEAVE,
                        CwmToolBarCmd::leaveProc,
                        (CwmData) this);
  xwindow_->addCallback(CWM_CALLBACK_BUTTON_PRESS,
                        &CwmToolBarCmd::pressProc,
                        (CwmData) this);
  xwindow_->addCallback(CWM_CALLBACK_BUTTON_RELEASE,
                        &CwmToolBarCmd::releaseProc,
                        (CwmData) this);
  xwindow_->addCallback(CWM_CALLBACK_SINGLE_CLICK_1,
                        &CwmToolBarCmd::invokeProc,
                        (CwmData) this);
  xwindow_->addCallback(CWM_CALLBACK_IDLE,
                        &CwmToolBarCmd::idleProc,
                        (CwmData) this);

  //------

  xwindow_->map();
}

CwmToolBarCmd::
~CwmToolBarCmd()
{
  delete xwindow_;

  delete graphics_;
}

void
CwmToolBarCmd::
redraw()
{
  xwindow_->setBackground(graphics_);

  xwindow_->clear();

  if      (pressed_)
    graphics_->drawButtonIn(xwindow_,
                            0, 0,
                            xwindow_->getWidth (),
                            xwindow_->getHeight(),
                            1);
  else if (active_)
    graphics_->drawButtonOut(xwindow_,
                             0, 0,
                             xwindow_->getWidth (),
                             xwindow_->getHeight(),
                             1);

  image_->draw(xwindow_, graphics_, 1, 1);
}

void
CwmToolBarCmd::
pressProc(CwmWindow *, CwmData data, CwmData detail)
{
  CwmToolBarCmd *icon = (CwmToolBarCmd *) data;

  XButtonPressedEvent *event = (XButtonPressedEvent *) detail;

  if (event->button != 1)
    return;

  icon->pressed_ = true;

  icon->redraw();
}

void
CwmToolBarCmd::
releaseProc(CwmWindow *, CwmData data, CwmData detail)
{
  CwmToolBarCmd *icon = (CwmToolBarCmd *) data;

  XButtonPressedEvent *event = (XButtonPressedEvent *) detail;

  if (event->button != 1)
    return;

  icon->pressed_ = false;

  icon->redraw();
}

void
CwmToolBarCmd::
invokeProc(CwmWindow *, CwmData data, CwmData)
{
  CwmToolBarCmd *icon = (CwmToolBarCmd *) data;

  icon->invoke();
}

void
CwmToolBarCmd::
invoke()
{
  if (command_ != "") {
    UnixCmd command(screen_, command_);

    command.setAddDisplay(add_display_);

    command.run();
  }
}

int
CwmToolBarCmd::
getWidth() const
{
  return xwindow_->getWidth() + 4;
}

void
CwmToolBarCmd::
enterProc(CwmWindow *, CwmData data, CwmData)
{
  CwmToolBarCmd *icon = (CwmToolBarCmd *) data;

  icon->active_ = true;

  icon->redraw();
}

void
CwmToolBarCmd::
leaveProc(CwmWindow *, CwmData data, CwmData)
{
  CwmToolBarCmd *icon = (CwmToolBarCmd *) data;

  icon->active_ = false;

  icon->redraw();
}

void
CwmToolBarCmd::
idleProc(CwmWindow *, CwmData data, CwmData detail)
{
  CwmToolBarCmd *icon       = (CwmToolBarCmd *) data;
  CwmIdleState  *idle_state = (CwmIdleState  *) detail;

  if (idle_state->getActive())
    icon->screen_.showInfo(icon->label_);
  else
    icon->screen_.hideInfo();
}
##concat##CwmToolBar.cpp
#include <CwmToolBarI.h>

CwmToolBarMgr::
CwmToolBarMgr(CwmDesk &desk1) :
 desk_(desk1)
{
  toolbar_ = new CwmToolBar(*this);

  CwmDeskMgr *desk_mgr = desk_.getDeskMgr();

  desk_mgr->addNotifyProc(CWM_DESK_MGR_NOTIFY_CHANGE_START,
                          &CwmToolBarMgr::deskChangeStartNotifyProc,
                          this);
  desk_mgr->addNotifyProc(CWM_DESK_MGR_NOTIFY_CHANGE_END,
                          &CwmToolBarMgr::deskChangeEndNotifyProc,
                          this);
}

CwmToolBarMgr::
~CwmToolBarMgr()
{
  CwmDeskMgr *desk_mgr = desk_.getDeskMgr();

  desk_mgr->removeNotifyProc(CWM_DESK_MGR_NOTIFY_CHANGE_START,
                             &CwmToolBarMgr::deskChangeStartNotifyProc,
                             this);
  desk_mgr->removeNotifyProc(CWM_DESK_MGR_NOTIFY_CHANGE_END,
                             &CwmToolBarMgr::deskChangeEndNotifyProc,
                             this);

  delete toolbar_;
}

void
CwmToolBarMgr::
deskChangeStartNotifyProc(CwmDeskMgr *desk_mgr, CwmDeskMgrNotifyType,
                          CwmData data)
{
  CwmToolBarMgr *mgr = (CwmToolBarMgr *) data;

  if (desk_mgr->getCurrentDesk() == &mgr->desk_)
    mgr->toolbar_->unmap();
}

void
CwmToolBarMgr::
deskChangeEndNotifyProc(CwmDeskMgr *desk_mgr, CwmDeskMgrNotifyType,
                        CwmData data)
{
  CwmToolBarMgr *mgr = (CwmToolBarMgr *) data;

  if (desk_mgr->getCurrentDesk() == &mgr->desk_)
    mgr->toolbar_->map();
}

void
CwmToolBarMgr::
enable()
{
  toolbar_->enable();
}

void
CwmToolBarMgr::
disable()
{
  toolbar_->disable();
}

CwmToolBar::
CwmToolBar(CwmToolBarMgr &mgr1) :
 mgr_(mgr1)
{
  CwmScreen &screen = getScreen();

  //------

  Pixel fg = CwmResourceDataInst->getToolBarForeground(screen);
  Pixel bg = CwmResourceDataInst->getToolBarBackground(screen);

  CwmColor *color = screen.getColor(fg, bg);

  CwmFont *font = CwmResourceDataInst->getToolBarFont(screen);

  graphics_ = new CwmGraphics(screen, font, color);

  //------

  int height1 = CwmResourceDataInst->getToolBarHeight();

  if (height1 <= 0)
    height1 = graphics_->getFontHeight() + 10;

  int x      = 0;
  int y      = screen.getHeight() - height1;
  int width  = screen.getWidth();
  int height = height1;

  border_ = 2;

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask   |
                    KeyPressMask    | ExposureMask;

  xwindow_ =
    new CwmWindow(screen, screen.getRoot(),
                   x, y, width, height,
                   event_mask, CWM_CURSOR_TITLE);

  xwindow_->setBackground(graphics_);

  //------

  show_clock_ = CwmResourceDataInst->getToolBarShowClock();

  add_icons_   = CwmResourceDataInst->getToolBarAddIcons();
  add_windows_ = CwmResourceDataInst->getToolBarAddWindows();

  time_format_ = CwmResourceDataInst->getToolBarClockTimeFormat();

  //------

  icon_area_x1_ = 2;
  icon_area_x2_ = width - 2;

  //------

  if (show_clock_) {
    clock_ = new CwmToolBarClock(*this);

    icon_area_x2_ -= clock_->getWidth();
  }
  else
    clock_ = 0;

  //------

  menu_ = new CwmToolBarMenu(*this);

  icon_area_x1_ += menu_->getWidth();

  //------

  CwmToolBarIconDefMgrInst->addToolBarIcons(*this);

  //------

  icon_area_ = new CwmToolBarIconArea(*this, icon_area_x1_,
                                      icon_area_x2_ - icon_area_x1_);

  //------

  CwmWindowGlobalNotifyMgrInst->
    addProc(CWM_WINDOW_NOTIFY_CREATE,
            &CwmToolBar::createNotifyProc,
            this);
  CwmWindowGlobalNotifyMgrInst->
    addProc(CWM_WINDOW_NOTIFY_ICONISE,
            &CwmToolBar::iconiseNotifyProc,
            this);
}

CwmToolBar::
~CwmToolBar()
{
  CwmWindowGlobalNotifyMgrInst->
    removeProc(CWM_WINDOW_NOTIFY_CREATE,
               &CwmToolBar::createNotifyProc,
               this);
  CwmWindowGlobalNotifyMgrInst->
    removeProc(CWM_WINDOW_NOTIFY_ICONISE,
               &CwmToolBar::iconiseNotifyProc,
               this);

  //------

  delete graphics_;

  delete icon_area_;

  delete clock_;

  delete menu_;

  delete xwindow_;
}

void
CwmToolBar::
addCmdIcon(CwmToolBarIconDef *icon_def)
{
  CwmToolBarCmd *cmd_icon =
    new CwmToolBarCmd(*this, icon_def, icon_area_x1_);

  cmd_icons_.push_back(cmd_icon);

  icon_area_x1_ += cmd_icon->getWidth();
}

void
CwmToolBar::
addIcon(CwmWMWindow *window)
{
  icon_area_->addIcon(window);
}

void
CwmToolBar::
removeIcon(CwmWMWindow *window)
{
  icon_area_->removeIcon(window);
}

CwmScreen &
CwmToolBar::
getScreen() const
{
  return mgr_.getDesk().getScreen();
}

void
CwmToolBar::
redraw()
{
  graphics_->drawButtonOut(xwindow_, 0, 0,
                          xwindow_->getWidth(),
                          xwindow_->getHeight(),
                          border_);

  if (clock_ != 0)
    clock_->redraw();

  menu_->redraw();

  ToolBarCmdList::const_iterator picon1 = cmd_icons_.begin();
  ToolBarCmdList::const_iterator picon2 = cmd_icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    (*picon1)->redraw();

  icon_area_->redraw();
}

bool
CwmToolBar::
isWindow(CwmWindow *xwindow1)
{
  return (xwindow_ == xwindow1);
}

bool
CwmToolBar::
isWindow(Window xwin)
{
  return (xwindow_->getXWin() == xwin);
}

bool
CwmToolBar::
isMenuWindow(CwmWindow *xwindow)
{
  return (menu_->getXWindow() == xwindow);
}

bool
CwmToolBar::
isMenuWindow(Window xwin)
{
  return (menu_->getXWindow()->getXWin() == xwin);
}

bool
CwmToolBar::
isToolIcon(CwmWindow *xwindow)
{
  return (getToolIcon(xwindow) != 0);
}

bool
CwmToolBar::
isToolIcon(Window xwin)
{
  return (getToolIcon(xwin) != 0);
}

bool
CwmToolBar::
isToolIcon(CwmWMWindow *window)
{
  return (getToolIcon(window) != 0);
}

CwmToolBarIcon *
CwmToolBar::
getToolIcon(CwmWindow *xwindow)
{
  return icon_area_->getIcon(xwindow);
}

CwmToolBarIcon *
CwmToolBar::
getToolIcon(Window xwin)
{
  return icon_area_->getIcon(xwin);
}

CwmToolBarIcon *
CwmToolBar::
getToolIcon(CwmWMWindow *window)
{
  return icon_area_->getIcon(window);
}

void
CwmToolBar::
processMenu()
{
  CwmScreen &screen = getScreen();

  CwmCirculateWindowStack &window_stack = screen.getCirculateWindowStack();

  CwmMenuDef *menu_def = buildMenu(window_stack);

  CwmMenu::processWindowMenu(screen, xwindow_, menu_def);

  delete menu_def;
}

void
CwmToolBar::
processMenuMenu()
{
  menu_->processMenu();
}

CwmMenuDef *
CwmToolBar::
buildMenu(CwmCirculateWindowStack &window_stack)
{
  CwmMenuDef *menu_def = new CwmMenuDef();

  menu_def->addTitle   ("Window List");
  menu_def->addSplitter("-----------");

  for (int i = 0; i < window_stack.size(); i++) {
    CwmWindowGroup &window_group = window_stack[i];

    if (window_group.size() == 0)
      continue;

    CwmWMWindow &window = window_group.getBottomWindow();

    if (window_group.size() > 1) {
      CwmMenuDef *menu_def1 = buildMenuCascade(window_group);

      menu_def->addCascade(window.getName(), menu_def1);
    }
    else
      menu_def->addButton("",
                          window.getName(), '\0', "",
                          (CwmMenuProc) raiseWindowProc,
                          (CwmData) &window);
  }

  return menu_def;
}

CwmMenuDef *
CwmToolBar::
buildMenuCascade(CwmWindowGroup &window_group)
{
  CwmMenuDef *menu_def = new CwmMenuDef();

  CwmWMWindow &bottom_window = window_group.getBottomWindow();

  for (int i = 0; i < window_group.size(); i++) {
    CwmWMWindow &window = window_group[i];

    if (&window != &bottom_window)
      menu_def->addButton("",
                          window.getName(), '\0', "",
                          (CwmMenuProc) raiseWindowProc,
                          (CwmData) &window);
  }

  return menu_def;
}

void
CwmToolBar::
raiseWindowProc(CwmWMWindow *window, CwmData)
{
  if (window->isIconised())
    window->restore();
  else
    window->raise();

  CwmToolBar *toolbar = window->getDesk()->getToolBar();

  if (toolbar != 0 && toolbar->getAddWindows())
    toolbar->redraw();
}

void
CwmToolBar::
map()
{
  xwindow_->map();
}

void
CwmToolBar::
unmap()
{
  xwindow_->unmap();
}

void
CwmToolBar::
enable()
{
  if (clock_ != 0)
    clock_->enable();
}

void
CwmToolBar::
disable()
{
  if (clock_ != 0)
    clock_->disable();
}

int
CwmToolBar::
getWidth() const
{
  return xwindow_->getWidth();
}

int
CwmToolBar::
getHeight() const
{
  return xwindow_->getHeight();
}

void
CwmToolBar::
createNotifyProc(CwmWMWindow *window, CwmWindowNotifyType, void *data)
{
  if (window->getToolBarSkip())
    return;

  CwmToolBar *toolbar = (CwmToolBar *) data;

  if (toolbar->getAddWindows())
    toolbar->addIcon(window);
}

void
CwmToolBar::
iconiseNotifyProc(CwmWMWindow *window, CwmWindowNotifyType, void *data)
{
  if (window->getToolBarSkip())
    return;

  CwmToolBar *toolbar = (CwmToolBar *) data;

  if (toolbar->getAddIcons())
    toolbar->addIcon(window);
}

bool
CwmToolBar::
processExpose(CwmWindow *xwindow)
{
  if (isWindow(xwindow)) {
    redraw();

    return true;
  }

  CwmToolBarIcon *icon = getToolIcon(xwindow);

  if (icon != 0) {
    icon->redraw();

    return true;
  }

  return false;
}

bool
CwmToolBar::
processButtonPress(Window xwin, int button)
{
  if (isWindow(xwin)) {
    if      (button == 1)
      getScreen().processDeskMenu();
    else if (button == 3)
      processMenu();

    return true;
  }

  if (isMenuWindow(xwin)) {
    if      (button == 1)
      processMenuMenu();
    else if (button == 3)
      processMenuMenu();

    return true;
  }

  CwmToolBarIcon *tool_icon = getToolIcon(xwin);

  if (tool_icon != 0) {
    if      (button == 1) {
      CwmWMWindow *window = tool_icon->getWindow();

      if (! window->isIconised())
        window->raise();
    }
    else if (button == 3) {
      CwmWMWindow *window = tool_icon->getWindow();

      if (  window->isIconised())
        tool_icon->processMenu();
      else
        window->processWindowMenu();
    }

    return true;
  }

  return false;
}
##concat##CwmToolBarIconArea.cpp
#include <CwmToolBarI.h>

static const int MIN_ICON_WIDTH = 16;
static const int DEF_ICON_WIDTH = 96;

static const int ICONIZED_BUTTON_WIDTH  = 8;
static const int ICONIZED_BUTTON_HEIGHT = 6;

CwmToolBarIconArea::
CwmToolBarIconArea(CwmToolBar &toolbar1, int x, int width) :
 toolbar_(toolbar1)
{
  CwmScreen &screen = toolbar_.getScreen();

  //------

  Pixel fg = CwmResourceDataInst->getToolBarForeground(screen);
  Pixel bg = CwmResourceDataInst->getToolBarBackground(screen);

  CwmColor *color = screen.getColor(fg, bg);

  CwmFont *font = CwmResourceDataInst->getToolBarFont(screen);

  graphics_ = new CwmGraphics(screen, font, color);

  //------

  def_icon_width_ = CwmResourceDataInst->getToolBarIconWidth();

  if (def_icon_width_ <= 0 || def_icon_width_ >= screen.getWidth())
    def_icon_width_ = DEF_ICON_WIDTH;

  icon_width_ = def_icon_width_;

  xwindow_ =
    new CwmWindow(screen, toolbar_.getXWindow(),
                   x, 2, width, toolbar_.getHeight() - 4,
                   0, CWM_CURSOR_TITLE);

  xwindow_->map();

  //------

  restore_event_ = 0;
  close_event_   = 0;
}

CwmToolBarIconArea::
~CwmToolBarIconArea()
{
  delete xwindow_;
}

void
CwmToolBarIconArea::
addIcon(CwmWMWindow *window)
{
  CwmToolBarIcon *icon = new CwmToolBarIcon(*this, window);

  icons_.push_back(icon);

  redraw();
}

void
CwmToolBarIconArea::
removeIcon(CwmWMWindow *window)
{
  ToolBarIconList::iterator picon1 = icons_.begin();
  ToolBarIconList::iterator picon2 = icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    if ((*picon1)->getWindow() == window)
      break;

  if (picon1 != picon2) {
    CwmToolBarIcon *icon = *picon1;

    icons_.erase(picon1);

    delete icon;

    redraw();
  }
}

CwmToolBarIcon *
CwmToolBarIconArea::
getIcon(CwmWindow *xwindow)
{
  ToolBarIconList::const_iterator picon1 = icons_.begin();
  ToolBarIconList::const_iterator picon2 = icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    if ((*picon1)->getXWindow() == xwindow)
      return *picon1;

  return 0;
}

CwmToolBarIcon *
CwmToolBarIconArea::
getIcon(Window xwin)
{
  ToolBarIconList::const_iterator picon1 = icons_.begin();
  ToolBarIconList::const_iterator picon2 = icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    if ((*picon1)->getXWindow()->getXWin() == xwin)
      return *picon1;

  return 0;
}

CwmToolBarIcon *
CwmToolBarIconArea::
getIcon(CwmWMWindow *window)
{
  ToolBarIconList::const_iterator picon1 = icons_.begin();
  ToolBarIconList::const_iterator picon2 = icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    if ((*picon1)->getWindow() == window)
      return *picon1;

  return 0;
}

void
CwmToolBarIconArea::
redraw()
{
  xwindow_->setBackground(graphics_);

  xwindow_->clear();

  resizeIcons();

  sortIcons();

  ToolBarIconList::const_iterator picon1 = icons_.begin();
  ToolBarIconList::const_iterator picon2 = icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    if ((*picon1)->onCurrentDesk())
      (*picon1)->getXWindow()->map();
    else
      (*picon1)->getXWindow()->unmap();

  picon1 = icons_.begin();

  for ( ; picon1 != picon2; ++picon1)
    if ((*picon1)->onCurrentDesk())
      (*picon1)->redraw();
}

void
CwmToolBarIconArea::
sortIcons()
{
  if (! toolbar_.getAddWindows())
    return;

  icons_.sort(CwmToolBarIcon::CwmToolIconCmp());

  int j = 0;

  ToolBarIconList::const_iterator picon1 = icons_.begin();
  ToolBarIconList::const_iterator picon2 = icons_.end  ();

  for ( ; picon1 != picon2; ++picon1) {
    if (! (*picon1)->onCurrentDesk())
      continue;

    (*picon1)->move(j*icon_width_, 0);

    j++;
  }
}

void
CwmToolBarIconArea::
resizeIcons()
{
  int num_icons = 0;

  ToolBarIconList::const_iterator picon1 = icons_.begin();
  ToolBarIconList::const_iterator picon2 = icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    if ((*picon1)->onCurrentDesk())
      num_icons++;

  if (num_icons == 0)
    return;

  int width = num_icons*icon_width_;

  int delta = width - getWidth();

  if (delta > 0) {
    while (delta > 0) {
      delta -= num_icons;

      icon_width_--;
    }

    if (icon_width_ < MIN_ICON_WIDTH)
      icon_width_ = MIN_ICON_WIDTH;
  }
  else {
    while (delta < 0) {
      delta += num_icons;

      icon_width_++;
    }

    if (delta > 0)
      icon_width_--;

    if (icon_width_ > def_icon_width_)
      icon_width_ = def_icon_width_;
  }

  int j = 0;

  picon1 = icons_.begin();

  for ( ; picon1 != picon2; ++picon1) {
    if (! (*picon1)->onCurrentDesk())
      continue;

    (*picon1)->moveResize(j*icon_width_, 0,
                          icon_width_, xwindow_->getHeight(),
                          true);

    j++;
  }
}

int
CwmToolBarIconArea::
getX() const
{
  return xwindow_->getX();
}

int
CwmToolBarIconArea::
getWidth() const
{
  return xwindow_->getWidth();
}

CXNamedEvent *
CwmToolBarIconArea::
getRestoreEvent()
{
  if (restore_event_ == 0)
    restore_event_ = new CXNamedEvent("Alt<Key>F5");

  return restore_event_;
}

CXNamedEvent *
CwmToolBarIconArea::
getCloseEvent()
{
  if (close_event_ == 0)
    close_event_ = new CXNamedEvent("Alt<Key>F4");

  return close_event_;
}

CwmToolBarIcon::
CwmToolBarIcon(CwmToolBarIconArea &icon_area1, CwmWMWindow *window1) :
 icon_area_(icon_area1), toolbar_(icon_area1.getToolBar()), window_(window1)
{
  CwmScreen &screen = toolbar_.getScreen();

  //------

  Pixel fg = CwmResourceDataInst->getToolBarIconForeground(screen);
  Pixel bg = CwmResourceDataInst->getToolBarIconBackground(screen);

  CwmColor *color = screen.getColor(fg, bg);

  CwmFont *font = CwmResourceDataInst->getToolBarIconFont(screen);

  normal_graphics_ = new CwmGraphics(screen, font, color);

  //------

  fg = CwmResourceDataInst->getToolBarIconFocusForeground(screen);
  bg = CwmResourceDataInst->getToolBarIconFocusBackground(screen);

  color = screen.getColor(fg, bg);

  font = CwmResourceDataInst->getToolBarIconFocusFont(screen);

  focus_graphics_ = new CwmGraphics(screen, font, color);

  //------

  graphics_ = normal_graphics_;

  //------

  border_     = toolbar_.getBorder();
  positioned_ = false;
  image_      = 0;

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask   |
                    KeyPressMask    | ExposureMask;

  xwindow_ = new CwmWindow(screen, icon_area_.getXWindow(),
                           0, 2,
                           icon_area_.getIconWidth(),
                           toolbar_.getHeight() - 4,
                           event_mask,
                           CWM_CURSOR_TITLE);

  xwindow_->setBackground(graphics_);

  xwindow_->addCallback(CWM_CALLBACK_DOUBLE_CLICK_1,
                        &CwmToolBarIcon::doubleClickProc,
                        (CwmData) this);
  xwindow_->addCallback(CWM_CALLBACK_IDLE,
                        &CwmToolBarIcon::idleProc,
                        (CwmData) this);

  //------

  setImage();

  //------

  menu_def_ = 0;

  //------

  window_->addNotifyProc(CWM_WINDOW_NOTIFY_MOVE,
                         &CwmToolBarIcon::moveNotifyProc,
                         this);
  window_->addNotifyProc(CWM_WINDOW_NOTIFY_ICONISE,
                         &CwmToolBarIcon::iconiseNotifyProc,
                         this);
  window_->addNotifyProc(CWM_WINDOW_NOTIFY_RESTORE,
                         &CwmToolBarIcon::restoreNotifyProc,
                         this);
  window_->addNotifyProc(CWM_WINDOW_NOTIFY_DESTROY,
                         &CwmToolBarIcon::destroyNotifyProc,
                         this);
  window_->addNotifyProc(CWM_WINDOW_NOTIFY_FOCUS_IN,
                         &CwmToolBarIcon::focusInNotifyProc,
                         this);
  window_->addNotifyProc(CWM_WINDOW_NOTIFY_FOCUS_OUT,
                         &CwmToolBarIcon::focusOutNotifyProc,
                         this);
}

CwmToolBarIcon::
~CwmToolBarIcon()
{
  window_->removeNotifyProc(CWM_WINDOW_NOTIFY_MOVE,
                            &CwmToolBarIcon::moveNotifyProc,
                            this);
  window_->removeNotifyProc(CWM_WINDOW_NOTIFY_ICONISE,
                            &CwmToolBarIcon::iconiseNotifyProc,
                            this);
  window_->removeNotifyProc(CWM_WINDOW_NOTIFY_RESTORE,
                            &CwmToolBarIcon::restoreNotifyProc,
                            this);
  window_->removeNotifyProc(CWM_WINDOW_NOTIFY_DESTROY,
                            &CwmToolBarIcon::destroyNotifyProc,
                            this);
  window_->removeNotifyProc(CWM_WINDOW_NOTIFY_FOCUS_IN,
                            &CwmToolBarIcon::focusInNotifyProc,
                            this);
  window_->removeNotifyProc(CWM_WINDOW_NOTIFY_FOCUS_OUT,
                            &CwmToolBarIcon::focusOutNotifyProc,
                            this);

  //------

  delete xwindow_;
}

void
CwmToolBarIcon::
setImage()
{
  image_ = window_->getImage(16, 16);
}

void
CwmToolBarIcon::
redraw()
{
  if (window_->isIconised())
    graphics_ = normal_graphics_;

  xwindow_->setBackground(graphics_);

  xwindow_->clear();

  graphics_->drawButtonOut(xwindow_,
                           0, 0,
                           xwindow_->getWidth(),
                           xwindow_->getHeight(),
                           border_);

  if (image_ != 0) {
    int x1 = border_ + 2;
    int y1 = xwindow_->getHeight()/2;

    image_->draw(xwindow_, graphics_, x1, y1 - 8);
  }

  if (window_->isIconised()) {
    int x1 = xwindow_->getWidth() - border_ - 2 - ICONIZED_BUTTON_WIDTH;
    int y1 = xwindow_->getHeight()/2;

    graphics_->drawButtonOut(xwindow_,
                             x1, y1 - 3,
                             ICONIZED_BUTTON_WIDTH, ICONIZED_BUTTON_HEIGHT,
                             border_);
  }

  std::string name = window_->getIconName();

  int x1 = border_ + 2;

  if (image_ != 0)
    x1 += image_->getWidth() + 2;

  int y1 = border_ + 1;

  int width1  = xwindow_->getWidth()  - x1 - 2;
  int height1 = xwindow_->getHeight() - y1 - 1;

  if (window_->isIconised())
    width1 -= 10;

  graphics_->drawTextCentered(xwindow_,
                              x1, y1, width1, height1,
                              name);
}

void
CwmToolBarIcon::
moveResize(int x, int y, int width, int height, bool force)
{
  if (force || ! positioned_) {
    xwindow_->moveResize(x, y, width, height);

    positioned_ = true;
  }
}

void
CwmToolBarIcon::
move(int x, int y)
{
  xwindow_->move(x, y);
}

bool
CwmToolBarIcon::
onCurrentDesk()
{
  return window_->onCurrentDesk();
}

void
CwmToolBarIcon::
processKeyPress(XKeyPressedEvent *event)
{
  XEvent *event1 = (XEvent *) event;

  if      (icon_area_.getRestoreEvent()->matchEvent(event1))
    window_->restore();
  else if (icon_area_.getCloseEvent  ()->matchEvent(event1))
    window_->close();
}

void
CwmToolBarIcon::
focusIn()
{
  graphics_ = focus_graphics_;

  redraw();
}

void
CwmToolBarIcon::
focusOut()
{
  graphics_ = normal_graphics_;

  redraw();
}

void
CwmToolBarIcon::
processMenu()
{
  if (menu_def_ == 0)
    createMenuDef();

  CwmScreen &screen = window_->getScreen();

  CwmMenu::processWindowMenu(screen, xwindow_, menu_def_);
}

void
CwmToolBarIcon::
createMenuDef()
{
  menu_def_ = new CwmMenuDef();

  menu_def_->addButton("",
                       "Restore", 'R', "Alt<Key>F5",
                       (CwmMenuProc) CwmToolBarIcon::restoreProc,
                       (CwmData) this);

  if (window_->getCloseFunctionHint()) {
    menu_def_->addSplitter("--------");

    menu_def_->addButton("",
                         "Close", 'C', "Alt<Key>F4",
                         (CwmMenuProc) CwmToolBarIcon::closeProc,
                         (CwmData) this);
  }
}

void
CwmToolBarIcon::
doubleClickProc(CwmWindow *, CwmData data, CwmData)
{
  CwmToolBarIcon *icon = (CwmToolBarIcon *) data;

  if (icon->window_->isIconised())
    icon->window_->restore();
}

void
CwmToolBarIcon::
restoreProc(CwmToolBarIcon *icon, CwmData)
{
  icon->window_->restore();
}

void
CwmToolBarIcon::
closeProc(CwmToolBarIcon *icon, CwmData)
{
  icon->window_->close();
}

void
CwmToolBarIcon::
idleProc(CwmWindow *, CwmData data, CwmData detail)
{
  CwmToolBarIcon *icon       = (CwmToolBarIcon *) data;
  CwmIdleState   *idle_state = (CwmIdleState *) detail;

  std::string name = icon->window_->getName();

  CwmScreen &screen = icon->window_->getScreen();

  if (idle_state->getActive())
    screen.showInfo(name);
  else
    screen.hideInfo();
}

void
CwmToolBarIcon::
moveNotifyProc(CwmWMWindow *, CwmWindowNotifyType, void *data)
{
  CwmToolBarIcon *icon = (CwmToolBarIcon *) data;

  icon->toolbar_.redraw();
}

void
CwmToolBarIcon::
iconiseNotifyProc(CwmWMWindow *, CwmWindowNotifyType, void *data)
{
  CwmToolBarIcon *icon = (CwmToolBarIcon *) data;

  icon->toolbar_.redraw();
}

void
CwmToolBarIcon::
restoreNotifyProc(CwmWMWindow *window, CwmWindowNotifyType, void *data)
{
  CwmToolBarIcon *icon = (CwmToolBarIcon *) data;

  CwmToolBar &toolbar = icon->getToolBar();

  if (toolbar.getAddIcons())
    toolbar.removeIcon(window);
  else
    toolbar.redraw();
}

void
CwmToolBarIcon::
destroyNotifyProc(CwmWMWindow *window, CwmWindowNotifyType, void *data)
{
  CwmToolBarIcon *icon = (CwmToolBarIcon *) data;

  CwmToolBar &toolbar = icon->getToolBar();

  toolbar.removeIcon(window);
}

void
CwmToolBarIcon::
focusInNotifyProc(CwmWMWindow *, CwmWindowNotifyType, void *data)
{
  CwmToolBarIcon *icon = (CwmToolBarIcon *) data;

  icon->focusIn();
}

void
CwmToolBarIcon::
focusOutNotifyProc(CwmWMWindow *, CwmWindowNotifyType, void *data)
{
  CwmToolBarIcon *icon = (CwmToolBarIcon *) data;

  icon->focusOut();
}

int
CwmToolBarIcon::CwmToolIconCmp::
operator()(CwmToolBarIcon *icon1, CwmToolBarIcon *icon2)
{
  if (  icon1->getWindow()->isIconised() &&
      ! icon2->getWindow()->isIconised())
    return false;

  if (! icon1->getWindow()->isIconised() &&
        icon2->getWindow()->isIconised())
    return true;

  CwmUserWindow *user1 = icon1->getWindow()->getUser();
  CwmUserWindow *user2 = icon2->getWindow()->getUser();

  if (user1 == 0 || user2 == 0)
    return false;

  int cmp = user1->getX() - user2->getX();

  if (cmp == 0)
    cmp = user1->getY() - user2->getY();

  return (cmp < 0);
}
##concat##CwmToolBarIconDef.cpp
#include <CwmToolBarI.h>

CwmToolBarIconDefMgr *
CwmToolBarIconDefMgr::
getInstance()
{
  static CwmToolBarIconDefMgr *instance;

  if (! instance)
    instance = new CwmToolBarIconDefMgr();

  return instance;
}

CwmToolBarIconDefMgr::
CwmToolBarIconDefMgr()
{
}

CwmToolBarIconDefMgr::
~CwmToolBarIconDefMgr()
{
  ToolBarIconDefList::const_iterator picon1 = toolbar_icons_.begin();
  ToolBarIconDefList::const_iterator picon2 = toolbar_icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    delete *picon1;
}

void
CwmToolBarIconDefMgr::
addToolBarIcon(const std::string &icon, const std::string &label,
               const std::string &command, bool add_display,
               const std::string &bg, const std::string &fg)
{
  CwmToolBarIconDef *toolbar_icon =
    new CwmToolBarIconDef(icon, label, command, add_display, bg, fg);

  toolbar_icons_.push_back(toolbar_icon);
}

void
CwmToolBarIconDefMgr::
addToolBarIcons(CwmToolBar &toolbar)
{
  ToolBarIconDefList::const_iterator picon1 = toolbar_icons_.begin();
  ToolBarIconDefList::const_iterator picon2 = toolbar_icons_.end  ();

  for ( ; picon1 != picon2; ++picon1)
    toolbar.addCmdIcon(*picon1);
}

CwmToolBarIconDef::
CwmToolBarIconDef(const std::string &icon, const std::string &label,
                  const std::string &command, bool add_display,
                  const std::string &bg, const std::string &fg) :
 icon_(icon), label_(label), command_(command),
 add_display_(add_display), bg_(bg), fg_(fg)
{
}

CwmToolBarIconDef::
~CwmToolBarIconDef()
{
}
##concat##CwmToolBarMenu.cpp
#include <CwmToolBarI.h>
#include <CImageLib.h>

const char *
CwmToolBarMenu::menu_image[] = {
"34 16 3 1",
"       c None",
"+      c #000000",
"@      c #2671A4",
"                                  ",
"                                  ",
"      ++++                        ",
"     +@@@@+                       ",
"    +@@++@@+                      ",
"   +@@+  +++++  ++  +++++++++++   ",
"  +@@+     +@+ +++ +@@+@@@@@@@@+  ",
"  +@+      +@@+@@@+@@++@@+@@+@@+  ",
"  +@+      +@@+@+@+@++@@++@@+@++  ",
"  +@+    ++++@@@+@@@++@@+@@++@+   ",
"  +@@++++@@++@@++@@+ +@++@@++@+   ",
"   +@@@@@++ +@+ +@++ +@++@+ +@+   ",
"    ++++++  +++ +++  ++ +++ ++    ",
"                                  ",
"                                  ",
"                                  "};

CwmToolBarMenu::
CwmToolBarMenu(CwmToolBar &toolbar) :
 toolbar_(toolbar)
{
  CwmScreen &screen = toolbar_.getScreen();

  //------

  Pixel fg = CwmResourceDataInst->getToolBarForeground(screen);
  Pixel bg = CwmResourceDataInst->getToolBarBackground(screen);

  CwmColor *color = screen.getColor(fg, bg);

  CwmFont *font = CwmResourceDataInst->getToolBarFont(screen);

  graphics_ = new CwmGraphics(screen, font, color);

  //------

  std::string name = "CwmToolBarMenu/menu_image";

  image_ = CwmImageMgrInst->getImage(screen, name);

  if (image_ == 0) {
    CImageNameSrc src(name);

    CImagePtr image1 = CImageMgrInst->createImage(src);

    image1->readXPM(menu_image, int(sizeof(menu_image)/sizeof(char *)));

    image_ = CwmImageMgrInst->addImage(name, image1)->getImage(screen);
  }

  int width  = image_->getWidth ();
  int height = image_->getHeight();

  //------

  uint event_mask = ButtonPressMask | ButtonReleaseMask |
                    EnterWindowMask | LeaveWindowMask   |
                    KeyPressMask    | ExposureMask;

  xwindow_ =
    new CwmWindow(screen, toolbar_.getXWindow(),
                   2, (toolbar_.getHeight() - height)/2,
                   width + 2, height + 2,
                   event_mask, CWM_CURSOR_TITLE);

  //------

  xwindow_->setBackground(graphics_);

  xwindow_->map();
}

CwmToolBarMenu::
~CwmToolBarMenu()
{
  delete xwindow_;
}

void
CwmToolBarMenu::
redraw()
{
  xwindow_->setBackground(graphics_);

  xwindow_->clear();

  graphics_->drawButtonOut(xwindow_,
                           0, 0,
                           xwindow_->getWidth(),
                           xwindow_->getHeight(),
                           2);

  image_->draw(xwindow_, graphics_, 1, 1);
}

int
CwmToolBarMenu::
getWidth() const
{
  return xwindow_->getWidth();
}

int
CwmToolBarMenu::
getHeight() const
{
  return xwindow_->getHeight();
}

void
CwmToolBarMenu::
processMenu()
{
  std::string name = "ToolBar Run Menu";

  CwmMenuDef *menu_def = CwmNamedMenuMgrInst->lookupMenuDef(name);

  if (menu_def != 0) {
    CwmScreen &screen = toolbar_.getScreen();

    menu_def->setClientData(&screen, 0, 0);

    CwmMenu::processWindowMenu(screen, xwindow_, menu_def, 0, 0,
                               CHALIGN_TYPE_LEFT, CVALIGN_TYPE_BOTTOM);
  }
}
##concat##CwmUnixCmd.cpp
#include <CwmI.h>
#include <COSSignal.h>
#include <sys/wait.h>

UnixCmd::
UnixCmd(CwmScreen &screen, const std::string &command) :
 screen_(screen), command_(command), status_(0), add_display_(false)
{
}

void
UnixCmd::
run()
{
  pid_t pid = fork();

  if (pid == 0) {
    COSSignal::defaultSignal(SIGHUP );
    COSSignal::defaultSignal(SIGINT );
    COSSignal::defaultSignal(SIGQUIT);
    COSSignal::defaultSignal(SIGTERM);

    std::string command_string;

    string::size_type pos = command_.rfind('&');

    if (pos != string::npos)
      command_string += command_.substr(0, pos);
    else
      command_string += command_;

    if (add_display_) {
      std::string name = CwmMachineInst->getDisplayName();

      if (name != "")
        command_string += " -display " + name;
    }

    command_string += " &";

    execl("/bin/sh", "sh", "-c", command_string.c_str(), 0);

    _exit(255);
  }

  CwmSigHandler sig_hup  = (CwmSigHandler) COSSignal::getSignalHandler(SIGHUP );
  CwmSigHandler sig_int  = (CwmSigHandler) COSSignal::getSignalHandler(SIGINT );
  CwmSigHandler sig_quit = (CwmSigHandler) COSSignal::getSignalHandler(SIGQUIT);
  CwmSigHandler sig_term = (CwmSigHandler) COSSignal::getSignalHandler(SIGTERM);

  COSSignal::ignoreSignal(SIGHUP );
  COSSignal::ignoreSignal(SIGINT );
  COSSignal::ignoreSignal(SIGQUIT);
  COSSignal::ignoreSignal(SIGTERM);

  int status;

  pid_t child_pid = wait(&status);

  while (child_pid != pid && child_pid != -1)
    child_pid = wait(&status);

  if (child_pid == -1)
    status = -1;

  COSSignal::addSignalHandler(SIGHUP , sig_hup );
  COSSignal::addSignalHandler(SIGINT , sig_int );
  COSSignal::addSignalHandler(SIGQUIT, sig_quit);
  COSSignal::addSignalHandler(SIGTERM, sig_term);

  status_ = status;
}
##concat##CwmUserWindow.cpp
#include <CwmI.h>

CwmUserWindow::
CwmUserWindow(CwmWMWindow *window, Window xwin, int x, int y,
              int width, int height, int border) :
 window_(window), border_(border)
{
  xwindow_ = new CwmWindow(window_->getScreen(), xwin,
                           x, y, width, height, true);
}

CwmUserWindow::
~CwmUserWindow()
{
  xwindow_->map();

  delete xwindow_;
}

Window
CwmUserWindow::
getXWin() const
{
  return xwindow_->getXWin();
}

void
CwmUserWindow::
map()
{
  xwindow_->map();
}

void
CwmUserWindow::
unmap()
{
  xwindow_->unmap();
}

void
CwmUserWindow::
setXWindow(Window xwin)
{
  xwindow_->setXWin(xwin);
}

void
CwmUserWindow::
fixSize(int *width, int *height)
{
  *width  -= window_->getBaseWidthHint ();
  *height -= window_->getBaseHeightHint();

  incrementRound(width , window_->getWidthIncHint ());
  incrementRound(height, window_->getHeightIncHint());

  *width  += window_->getBaseWidthHint ();
  *height += window_->getBaseHeightHint();
}

void
CwmUserWindow::
moveResize(int x, int y, int width, int height)
{
  x_ = x;
  y_ = y;

  xwindow_->moveResize(0, 0, width, height);

  sendConfigureNotify();
}

void
CwmUserWindow::
resize(int width, int height)
{
  xwindow_->resize(width, height);

  sendConfigureNotify();
}

void
CwmUserWindow::
sizeToUser(int *width, int *height)
{
  *width  = getWidth ();
  *height = getHeight();

  *width  -= window_->getBaseWidthHint();
  *height -= window_->getBaseHeightHint();

  *width  = (*width  + window_->getWidthIncHint ()/2)/
            window_->getWidthIncHint ();
  *height = (*height + window_->getHeightIncHint()/2)/
            window_->getHeightIncHint();
}

void
CwmUserWindow::
sendConfigureNotify()
{
  if (! xwindow_->isValid())
    return;

  CwmFrameWindow *frame = window_->getFrame();

  CwmMachineInst->sendConfigureNotifyEvent(xwindow_->getXWin(),
                                           x_, y_, getWidth(), getHeight(), 0,
                                           frame->getXWindow()->getXWin());
}

int
CwmUserWindow::
getWidth() const
{
  return xwindow_->getWidth();
}

int
CwmUserWindow::
getHeight() const
{
  return xwindow_->getHeight();
}

void
CwmUserWindow::
incrementRound(int *number, int increment)
{
  if (increment <= 1)
    return;

  *number = ((*number + increment/2)/increment)*increment;
}
##concat##CwmWindow.cpp
#include <CwmI.h>

CwmWindow::
CwmWindow(CwmScreen &screen, CwmWindow *parent, int x, int y,
          int width, int height, uint event_mask, CwmCursorType cursor) :
 screen_(screen), x_(x), y_(y), width_(width), height_(height)
{
  mapped_ = false;

  create(screen_, parent->xwin_, event_mask, cursor);

  CwmMachineInst->addXWindow(this);
}

CwmWindow::
CwmWindow(CwmScreen &screen, Window parent, int x, int y,
          int width, int height, uint event_mask, CwmCursorType cursor) :
 screen_(screen), x_(x), y_(y), width_(width), height_(height)
{
  mapped_ = false;

  create(screen_, parent, event_mask, cursor);

  CwmMachineInst->addXWindow(this);
}

CwmWindow::
CwmWindow(CwmScreen &screen, Window xwin, int x, int y,
          int width, int height, bool mapped) :
 screen_(screen), xwin_(xwin), x_(x), y_(y),
 width_(width), height_(height), mapped_(mapped)
{
  owner_ = false;

  CwmMachineInst->addXWindow(this);
}

void
CwmWindow::
create(CwmScreen &screen, Window parent,
       uint event_mask, CwmCursorType cursor)
{
  XSetWindowAttributes attr;

  attr.event_mask        = event_mask;
  attr.cursor            = screen.getCursor(cursor);
  attr.override_redirect = True;

  uint attr_mask = CWEventMask | CWCursor | CWOverrideRedirect;

  xwin_ =
    CwmMachineInst->createWindow(parent,
                                 x_, y_, width_, height_, 0,
                                 attr_mask, &attr);

  owner_ = true;
}

CwmWindow::
~CwmWindow()
{
  std::for_each(callbacks_.begin(), callbacks_.end(), CDeletePointer());

  callbacks_.clear();

  CwmMachineInst->removeXWindow(this);

  if (owner_ && CwmMachineInst->isValidWindow(xwin_)) {
    CwmMachineInst->destroyWindow(xwin_);

    int event_mask = ButtonPressMask   | ButtonReleaseMask        |
                     EnterWindowMask   | LeaveWindowMask          |
                     KeyPressMask      | ExposureMask             |
                     FocusChangeMask   | PropertyChangeMask       |
                     PointerMotionMask | SubstructureRedirectMask |
                     ColormapChangeMask;

    CwmMachineInst->flushWindowEvents(xwin_, event_mask);
  }
}

void
CwmWindow::
setBackground(CwmGraphics *graphics)
{
  CwmColor *color = graphics->getColor();

  CwmMachineInst->setWindowBackgroundColor(xwin_, color->getBg());
}

void
CwmWindow::
setBackgroundPixmap(CwmXPixmap *pixmap)
{
  CwmMachineInst->setWindowBackgroundPixmap(xwin_, pixmap->getXPixmap());
}

void
CwmWindow::
setSaveUnder(bool flag)
{
  XSetWindowAttributes attr;

  attr.save_under = flag;

  CwmMachineInst->changeWindowAtributes(xwin_, CWSaveUnder, &attr);
}

void
CwmWindow::
map()
{
  if (mapped_)
    return;

  CwmMachineInst->mapWindow(xwin_);

  CwmMachineInst->flushWindowEvent(xwin_, MapNotify);

  mapped_ = true;
}

void
CwmWindow::
mapRaised()
{
  if (mapped_)
    return;

  CwmMachineInst->mapWindowRaised(xwin_);

  CwmMachineInst->flushWindowEvent(xwin_, MapNotify);

  mapped_ = true;
}

void
CwmWindow::
mapSubwindows()
{
  CwmMachineInst->mapWindowChildren(xwin_);
}

void
CwmWindow::
unmap()
{
  if (! mapped_)
    return;

  CwmMachineInst->unmapWindow(xwin_);

  CwmMachineInst->flushWindowEvent(xwin_, UnmapNotify);

  mapped_ = false;
}

void
CwmWindow::
lower()
{
  CwmMachineInst->lowerWindow(xwin_);
}

void
CwmWindow::
raise()
{
  CwmMachineInst->raiseWindow(xwin_);
}

void
CwmWindow::
move(int x, int y)
{
  if (x == x_ && y == y_)
    return;

  x_ = x;
  y_ = y;

  CwmMachineInst->moveWindow(xwin_, x_, y_);
}

void
CwmWindow::
resize(int width, int height)
{
  if (width == width_ && height == height_)
    return;

  width_  = width;
  height_ = height;

  CwmMachineInst->resizeWindow(xwin_, width_, height_);
}

void
CwmWindow::
moveResize(int x, int y, int width, int height)
{
  if (x_ == x && y_ == y && width_ == width && height_ == height)
    return;

  x_      = x;
  y_      = y;
  width_  = width;
  height_ = height;

  CwmMachineInst->moveResizeWindow(xwin_, x_, y_, width_, height_);
}

void
CwmWindow::
clear()
{
  CwmMachineInst->clearWindow(xwin_);
}

void
CwmWindow::
setStackMode(int stack_mode, CwmWMWindow *sibling)
{
  XWindowChanges xwc;

  int mask = CWStackMode;

  xwc.stack_mode = stack_mode;

  if (sibling != 0) {
    xwc.sibling = sibling->getXWin();

    mask |= CWSibling;
  }

  CwmMachineInst->debugf("Stack Mode = %d\n", xwc.stack_mode);

  if (sibling != 0)
    CwmMachineInst->debugf("Sibling %s\n", sibling->getName().c_str());

  CwmMachineInst->configureWindow(xwin_, mask, &xwc);
}

void
CwmWindow::
configure(uint mask, XWindowChanges *xwc)
{
  CwmMachineInst->configureWindow(xwin_, mask, xwc);
}

bool
CwmWindow::
isValid()
{
  return CwmMachineInst->isValidWindow(xwin_);
}

void
CwmWindow::
warpPointer(int x, int y)
{
  CwmMachineInst->warpPointer(xwin_, x, y);
}

bool
CwmWindow::
selectInput(uint event_mask)
{
  CwmMachineInst->trapStart();

  CwmMachineInst->selectInput(xwin_, event_mask);

  if (! CwmMachineInst->trapEnd())
    return false;

  return true;
}

bool
CwmWindow::
addInput(uint event_mask)
{
  int win_event_mask = CwmMachineInst->getWindowEventMask(xwin_);

  if (! (win_event_mask & event_mask)) {
    if (! selectInput(win_event_mask | event_mask))
      return false;
  }

  return true;
}

bool
CwmWindow::
getChildWindows(Window **windows, int *num_windows)
{
  CwmMachineInst->trapStart();

  bool flag =
    CwmMachineInst->getWindowChildren(xwin_, windows, num_windows);

  if (! CwmMachineInst->trapEnd())
    return false;

  return flag;
}

void
CwmWindow::
grabButtonPress()
{
  Cursor cursor = screen_.getCursor(CWM_CURSOR_TITLE);

  CwmMachineInst->grabButton(xwin_, AnyButton, AnyModifier, ButtonPressMask,
                             cursor);
}

void
CwmWindow::
grabButton1Press()
{
  Cursor cursor = screen_.getCursor(CWM_CURSOR_TITLE);

  CwmMachineInst->grabButton(xwin_, Button1, AnyModifier, ButtonPressMask,
                             cursor);
}

void
CwmWindow::
ungrabButtonPress()
{
  CwmMachineInst->ungrabButton(xwin_, AnyButton, AnyModifier);
}

void
CwmWindow::
ungrabButton1Press()
{
  CwmMachineInst->ungrabButton(xwin_, Button1, AnyModifier);
}

bool
CwmWindow::
grab(uint event_mask, CwmCursorType cursor_type)
{
  CwmIdleInst->disable();

  Cursor cursor = screen_.getCursor(cursor_type);

  if (! CwmMachineInst->grabPointer(xwin_, event_mask, cursor))
    return false;

  if (! CwmMachineInst->grabKeyboard(xwin_)) {
    CwmMachineInst->ungrabPointer();
    return false;
  }

  return true;
}

bool
CwmWindow::
ungrab()
{
  CwmMachineInst->ungrabKeyboard();

  CwmMachineInst->ungrabPointer();

  CwmIdleInst->enable();

  return true;
}

bool
CwmWindow::
grabPointer(uint event_mask, CwmCursorType cursor_type)
{
  CwmIdleInst->disable();

  Cursor cursor = screen_.getCursor(cursor_type);

  if (! CwmMachineInst->grabPointer(xwin_, event_mask, cursor))
    return false;

  return true;
}

bool
CwmWindow::
ungrabPointer()
{
  CwmMachineInst->ungrabPointer();

  CwmIdleInst->enable();

  return true;
}

bool
CwmWindow::
getPointerPosition(int *x, int *y)
{
  return CwmMachineInst->queryPointer(xwin_, x, y);
}

void
CwmWindow::
coordsToRoot(int x, int y, int *root_x, int *root_y)
{
  Window child;

  CwmMachineInst->translateCoords(xwin_, screen_.getRoot()->xwin_,
                                  x, y, root_x, root_y, &child);
}

void
CwmWindow::
setBorderWidth(int width)
{
  CwmMachineInst->setWindowBorderWidth(xwin_, width);
}

void
CwmWindow::
addToSaveSet()
{
  CwmMachineInst->addToSaveSet(xwin_);
}

void
CwmWindow::
removeFromSaveSet()
{
  CwmMachineInst->removeFromSaveSet(xwin_);
}

void
CwmWindow::
sendEvent(XEvent *event, int event_mask)
{
  CwmMachineInst->sendEvent(xwin_, False, event, event_mask);
}

void
CwmWindow::
sendPointerEvent(XEvent *event)
{
  CwmMachineInst->sendEvent(PointerWindow, True, event, 0);
}

void
CwmWindow::
allowPointerEvents()
{
  CwmMachineInst->allowEvents(SyncPointer);

  CwmMachineInst->flushEvents();
}

void
CwmWindow::
replayPointerEvents()
{
  CwmMachineInst->allowEvents(ReplayPointer);

  CwmMachineInst->flushEvents();
}

void
CwmWindow::
addCallback(CwmXWindowCallType type, CwmXWindowCallProc proc, CwmData data)
{
  CwmXWindowCallback *callback =
   new CwmXWindowCallback(this, type, proc, data);

  callbacks_.push_back(callback);
}

void
CwmWindow::
callCallbacks(CwmXWindowCallType type, CwmData detail)
{
  XWindowCallbackList callbacks = callbacks_;

  XWindowCallbackList::const_iterator pcallback1 = callbacks.begin();
  XWindowCallbackList::const_iterator pcallback2 = callbacks.end  ();

  for ( ; pcallback1 != pcallback2; ++pcallback1)
    (*pcallback1)->invokeIfType(type, detail);
}

void
CwmWindow::
deleteCallback(CwmXWindowCallType type, CwmXWindowCallProc proc,
               CwmData data)
{
  XWindowCallbackList::const_iterator pcallback1 = callbacks_.begin();
  XWindowCallbackList::const_iterator pcallback2 = callbacks_.end  ();

  while (pcallback1 != pcallback2) {
    if ((*pcallback1)->match(type, proc, data)) {
      callbacks_.remove(*pcallback1);

      delete *pcallback1;

      pcallback1 = callbacks_.begin();
      pcallback2 = callbacks_.end  ();
    }
    else
      ++pcallback1;
  }
}

Pixmap
CwmWindow::
toMask()
{
  CImageNameSrc src(string("mask_") + CStrUtil::toString(xwin_) +
                    "?width="  + CStrUtil::toString(width_) +
                    "?height=" + CStrUtil::toString(height_));

  CImagePtr image = CImageMgrInst->createImage(src);

  image.cast<CXImage>()->getXImage(xwin_, 0, 0, width_, height_);

  Pixmap mask_pixmap = image.cast<CXImage>()->getXMask();

  return mask_pixmap;
}

void
CwmWindow::
reparent(CwmWindow *parent, int x, int y)
{
  CwmMachineInst->reparentWindow(xwin_, parent->xwin_, x, y);

  CwmMachineInst->flushWindowEvent(xwin_, MapNotify);
  CwmMachineInst->flushWindowEvent(xwin_, ReparentNotify);
  CwmMachineInst->flushWindowEvent(xwin_, UnmapNotify);
}

bool
CwmWindow::
isViewable()
{
  return CwmMachineInst->getWindowViewable(xwin_);
}

void
CwmWindow::
getPosition(int *x, int *y)
{
  CwmMachineInst->getWindowGeometry(xwin_, x, y, 0, 0, 0);
}

void
CwmWindow::
getSize(int *width, int *height)
{
  CwmMachineInst->getWindowGeometry(xwin_, 0, 0, width, height, 0);
}

void
CwmWindow::
getGeometry(int *x, int *y, int *width, int *height, int *border)
{
  CwmMachineInst->getWindowGeometry(xwin_, x, y, width, height, border);
}

bool
CwmWindow::
translateCoords(CwmWindow *dest, int src_x, int src_y,
                int *dest_x, int *dest_y)
{
  Window child;

  if (! CwmMachineInst->translateCoords(xwin_, dest->xwin_,
                                        src_x, src_y, dest_x, dest_y,
                                        &child))
    return false;

  return true;
}

CwmXWindowCallback::
CwmXWindowCallback(CwmWindow *xwindow, CwmXWindowCallType type,
                   CwmXWindowCallProc proc, CwmData data) :
 xwindow_(xwindow), type_(type), proc_(proc), data_(data)
{
}

CwmXWindowCallback::
~CwmXWindowCallback()
{
}

void
CwmXWindowCallback::
invokeIfType(CwmXWindowCallType type, CwmData detail)
{
  if (type_ == type)
    proc_(xwindow_, data_, detail);
}

void
CwmXWindowCallback::
invoke(CwmData detail)
{
  proc_(xwindow_, data_, detail);
}

bool
CwmXWindowCallback::
match(CwmXWindowCallType type, CwmXWindowCallProc proc, CwmData data)
{
  return (type == type_) && (proc == proc_) && (data == data_);
}
##concat##CwmWindowImageList.cpp
#include <CwmI.h>
#include MCXScreen.h>

CwmWindowImageList::
CwmWindowImageList(CwmWMWindow *window) :
 window_(window)
{
  CwmScreen &screen = window->getScreen();

  std::string image_file = CwmCustomDeskIconMgrInst->getIcon(window);

  if (image_file != "") {
    CwmImage *image = CwmImageMgrInst->getImage(screen, image_file);

    if (image != 0)
      addImage(image, image_file);
  }

  image_file = CwmCustomDeskIconMgrInst->getIconSmall(window);

  if (image_file != "") {
    CwmImage *image = CwmImageMgrInst->getImage(screen, image_file);

    if (image != 0)
      addImage(image, image_file);
  }

  image_file = CwmResourceDataInst->getIconImage();

  if (image_file != "") {
    CwmImage *image = CwmImageMgrInst->getImage(screen, image_file);

    if (image != 0)
      addImage(image, image_file);
  }

  Window xwin = window->getWMIconWindowHint();

  if (! CwmMachineInst->isValidWindow(xwin))
    xwin = None;

  if (xwin != None) {
    std::string name = " " + window->getNameHint() + "_icon_window";

    CwmImage *image = CwmImageMgrInst->getImage(screen, name);

    if (image == 0) {
      CXScreen *cxscreen = screen.getCXScreen();

      CImagePtr cimage;

      cxscreen->windowToImage(xwin, cimage);

      CwmImageMgrInst->addImage(name, cimage);

      image = CwmImageMgrInst->getImage(screen, name);
    }

    addImage(image, name);
  }

  Pixmap pixmap = window->getIconPixmapHint();

  if (pixmap != None) {
    std::string name = "Cwm/" + window->getNameHint() + "_icon_pixmap";

    CwmImage *image = CwmImageMgrInst->getImage(screen, name);

    if (image == 0) {
      CXScreen *cxscreen = screen.getCXScreen();

      CImagePtr cimage;

      cxscreen->windowToImage(pixmap, cimage);

      Pixmap mask_pixmap = window->getIconMaskHint();

      if (mask_pixmap != None) {
        CImagePtr mask_cimage;

        cxscreen->windowToImage(mask_pixmap, mask_cimage);

        mask_cimage->setAlphaByGray(true);

        CImageNameSrc src(name);

        CImagePtr mask_image = CImageMgrInst->createImage(src);

        mask_image = mask_cimage;

        cimage->alphaMask(mask_image);
      }

      CwmImageMgrInst->addImage(name, cimage);

      image = CwmImageMgrInst->getImage(screen, name);
    }

    addImage(image, name);
  }
}

CwmWindowImageList::
~CwmWindowImageList()
{
  std::for_each(images_.begin(), images_.end(), CDeletePointer());
}

void
CwmWindowImageList::
addImage(CwmImage *image, const std::string &name)
{
  CwmWindowImage *window_image = new CwmWindowImage(image, name);

  images_.push_back(window_image);
}

CwmImage *
CwmWindowImageList::
getImage(int width, int height)
{
  CwmWindowImage *image = 0;
  int             dxy   = 0;

  WindowImageList::const_iterator pimage1 = images_.begin();
  WindowImageList::const_iterator pimage2 = images_.end  ();

  for ( ; pimage1 != pimage2; ++pimage1) {
    int dx = abs((*pimage1)->getWidth () - width );
    int dy = abs((*pimage1)->getHeight() - height);

    int dxy1 = dx*dx + dy*dy;

    if (image == 0 || dxy1 < dxy) {
      image = *pimage1;

      dxy = dxy1;
    }
  }

  if (image == 0)
    return 0;

  int dx = width  - image->getWidth ();
  int dy = height - image->getHeight();

  if (dx < 0 || dy < 0) {
    CwmImage *image1 =
      CwmImageMgrInst->getImage(window_->getScreen(), image->getName(),
                                width, height);

    addImage(image1, image->getName());

    return image1;
  }
  else
    return image->getImage();
}

CwmImage *
CwmWindowImageList::
getImage()
{
  if (images_.size() == 0)
    return 0;

  return images_[0]->getImage();
}

CwmWindowImage::
CwmWindowImage(CwmImage *image, const std::string &name) :
 image_(image), name_(name)
{
}

CwmWindowImage::
~CwmWindowImage()
{
}

int
CwmWindowImage::
getWidth() const
{
  return image_->getWidth();
}

int
CwmWindowImage::
getHeight() const
{
  return image_->getHeight();
}
##concat##CwmWindowMenu.cpp
#include <CwmI.h>

CwmWindowMenu::
CwmWindowMenu(CwmWMWindow *window1) :
 window(window1)
{
  menu_def = new CwmMenuDef();

  if (window->getMoveFunctionHint())
    menu_def->addButton("",
                        "Move", 'M', "Alt<Key>F7",
                        (CwmMenuProc) &CwmWindowMenu::moveProc,
                        (CwmData) window);

  if (window->getResizeFunctionHint())
    menu_def->addButton("",
                        "Resize", 's', "Alt<Key>F8",
                        (CwmMenuProc) &CwmWindowMenu::resizeProc,
                        (CwmData) window);

  if (window->getIconiseFunctionHint())
    menu_def->addButton("",
                        "Iconise", 'I', "Alt<Key>F9",
                        (CwmMenuProc) &CwmWindowMenu::iconiseProc,
                        (CwmData) window);

  if (window->getMaximizeFunctionHint())
    menu_def->addButton("",
                        "Maximize", 'x', "Alt<Key>F10",
                        (CwmMenuProc) &CwmWindowMenu::maximizeProc,
                        (CwmData) window);

  if (window->getMinimizeFunctionHint())
    menu_def->addButton("",
                        "Minimize", 'n', "Alt<Key>F11",
                        (CwmMenuProc) &CwmWindowMenu::minimizeProc,
                        (CwmData) window);

  if (window->getRestoreFunctionHint())
    menu_def->addButton("",
                        "Restore", 'R', "Alt<Key>F5",
                        (CwmMenuProc) &CwmWindowMenu::restoreProc,
                        (CwmData) window);

  if (window->getRaiseFunctionHint())
    menu_def->addButton("",
                        "Raise", 'a', "Alt<Key>F2",
                        (CwmMenuProc) &CwmWindowMenu::raiseProc,
                        (CwmData) window);

  if (window->getLowerFunctionHint())
    menu_def->addButton("",
                        "Lower", 'L', "Alt<Key>F3",
                        (CwmMenuProc) &CwmWindowMenu::lowerProc,
                        (CwmData) window);

  if (window->getRollUpFunctionHint())
    menu_def->addButton("",
                        "Roll Up", 'U', "",
                        (CwmMenuProc) &CwmWindowMenu::rollUpProc,
                        (CwmData) window);

  if (window->getRollDownFunctionHint())
    menu_def->addButton("",
                        "Roll Down", 'D', "",
                        (CwmMenuProc) &CwmWindowMenu::rollDownProc,
                        (CwmData) window);

  if (window->getCloseFunctionHint()) {
    menu_def->addSplitter("--------");

    menu_def->addButton("",
                        "Close", 'C', "Alt<Key>F4",
                        (CwmMenuProc) &CwmWindowMenu::closeProc,
                        (CwmData) window);
  }
}

CwmWindowMenu::
~CwmWindowMenu()
{
  delete menu_def;
}

void
CwmWindowMenu::
process()
{
  CwmScreen &screen = window->getScreen();

  screen.uninstallColormap();

  CwmMenu::processWindowMenu(screen, screen.getRoot(), menu_def);

  screen.installColormap(window);
}

void
CwmWindowMenu::
processAtPosition(CwmWindow *xwindow, int x, int y)
{
  CwmScreen &screen = window->getScreen();

  screen.uninstallColormap();

  CwmMenu::processWindowMenu(screen, xwindow, menu_def, x, y);

  screen.installColormap(window);
}

void
CwmWindowMenu::
moveProc(CwmWMWindow *window, CwmData)
{
  CwmMoveWindowInst->move(window);
}

void
CwmWindowMenu::
resizeProc(CwmWMWindow *window, CwmData)
{
  CwmResizeWindowInst->resize(window, CWM_RESIZE_FREE);
}

void
CwmWindowMenu::
resizeToSizeProc(CwmWMWindow *window, CwmData data)
{
  std::string *size_string = (string *) data;

  int width, height;

  if (sscanf(size_string->c_str(), "%dx%d", &width, &height) != 2) {
    CwmMachineInst->logf("Invalid size std::string %s\n", (*size_string).c_str());
    return;
  }

  int width1  = window->getBaseWidthHint()  + width *window->getWidthIncHint() ;
  int height1 = window->getBaseHeightHint() + height*window->getHeightIncHint();

  window->resizeUser(width1, height1);
}

void
CwmWindowMenu::
iconiseProc(CwmWMWindow *window, CwmData)
{
  window->iconise();
}

void
CwmWindowMenu::
maximizeProc(CwmWMWindow *window, CwmData)
{
  window->maximize();
}

void
CwmWindowMenu::
minimizeProc(CwmWMWindow *window, CwmData)
{
  window->minimize();
}

void
CwmWindowMenu::
restoreProc(CwmWMWindow *window, CwmData)
{
  window->restoreSize();
}

void
CwmWindowMenu::
raiseProc(CwmWMWindow *window, CwmData)
{
  window->raise();
}

void
CwmWindowMenu::
lowerProc(CwmWMWindow *window, CwmData)
{
  window->lower();
}

void
CwmWindowMenu::
rollUpProc(CwmWMWindow *window, CwmData)
{
  window->rollUp();
}

void
CwmWindowMenu::
rollDownProc(CwmWMWindow *window, CwmData)
{
  window->rollDown();
}

void
CwmWindowMenu::
circulateUpProc(CwmWMWindow *window, CwmData)
{
  window->getScreen().circulateUp();
}

void
CwmWindowMenu::
circulateDownProc(CwmWMWindow *window, CwmData)
{
  window->getScreen().circulateDown();
}

void
CwmWindowMenu::
focusNextProc(CwmWMWindow *window, CwmData)
{
  CwmMachineInst->focusNext(window->getScreen());
}

void
CwmWindowMenu::
focusPrevProc(CwmWMWindow *window, CwmData)
{
  CwmMachineInst->focusPrev(window->getScreen());
}

void
CwmWindowMenu::
closeProc(CwmWMWindow *window, CwmData)
{
  window->close();
}

void
CwmWindowMenu::
processNamedMenuProc(CwmWMWindow *window, CwmData data)
{
  std::string *name = (string *) data;

  CwmMenu::processNamedMenu(window, *name);
}

void
CwmWindowMenu::
pasteProc(CwmWMWindow *window, CwmData data)
{
  std::string *text = (string *) data;

  if (data != 0)
    CwmPaste::pasteText(window, *text);
}

void
CwmWindowMenu::
runCommandProc(CwmWMWindow *window, CwmData data)
{
  std::string *cmd = (string *) data;

  UnixCmd command(window->getScreen(), *cmd);

  command.run();
}

void
CwmWindowMenu::
runXCommandProc(CwmWMWindow *window, CwmData data)
{
  std::string *cmd = (string *) data;

  UnixCmd command(window->getScreen(), *cmd);

  command.setAddDisplay(true);

  command.run();
}
##concat##CwmWindowStack.cpp
#include <CwmI.h>

// Window Group of Base Window and Transient Children in Top to Bottom Order

CwmWindowGroup::
CwmWindowGroup(CwmWMWindow *window)
{
  stackChildren(window);

  window_stack_.push_back(window);

  stackParents(window);
}

CwmWindowGroup::
~CwmWindowGroup()
{
}

void
CwmWindowGroup::
stackChildren(CwmWMWindow *window)
{
  const CwmWMWindow::WMWindowList children = window->getChildren();

  CwmWMWindow::WMWindowList::const_iterator pchild1 = children.begin();
  CwmWMWindow::WMWindowList::const_iterator pchild2 = children.end  ();

  for ( ; pchild1 != pchild2; ++pchild1) {
    stackChildren(*pchild1);

    window_stack_.push_back(*pchild1);
  }
}

void
CwmWindowGroup::
stackParents(CwmWMWindow *window)
{
  CwmWMWindow *parent = window->getParent();

  if (parent == 0)
    return;

  const CwmWMWindow::WMWindowList children = parent->getChildren();

  CwmWMWindow::WMWindowList::const_iterator pchild1 = children.begin();
  CwmWMWindow::WMWindowList::const_iterator pchild2 = children.end  ();

  for ( ; pchild1 != pchild2; ++pchild1) {
    if (*pchild1 == window)
      continue;

    stackChildren(*pchild1);

    window_stack_.push_back(*pchild1);
  }

  window_stack_.push_back(parent);

  stackParents(parent);
}

void
CwmWindowGroup::
restack()
{
  if (window_stack_.empty())
    return;

  Window *windows = new Window [window_stack_.size()];

  int num_window_stacks = window_stack_.size();

  for (int i = 0; i < num_window_stacks; ++i)
    windows[i] = window_stack_[i]->getFrameWindow()->getXWin();

  CwmMachineInst->restackWindows(windows, window_stack_.size());

  delete [] windows;
}

void
CwmWindowGroup::
map()
{
  int num_window_stacks = window_stack_.size();

  for (int i = 0; i < num_window_stacks; ++i)
    window_stack_[i]->getFrameWindow()->map();
}

void
CwmWindowGroup::
unmap()
{
  int num_window_stacks = window_stack_.size();

  for (int i = 0; i < num_window_stacks; ++i)
    window_stack_[i]->getFrameWindow()->unmap();
}

bool
CwmWindowGroup::
contains(CwmWMWindow *window)
{
  int num_window_stacks = window_stack_.size();

  for (int i = 0; i < num_window_stacks; ++i)
    if (window_stack_[i] == window)
      return true;

  return false;
}

int
CwmWindowGroup::
size() const
{
  return window_stack_.size();
}

CwmWMWindow &
CwmWindowGroup::
getTopWindow() const
{
  return *(window_stack_[0]);
}

CwmWMWindow &
CwmWindowGroup::
getBottomWindow() const
{
  return *(window_stack_[window_stack_.size() - 1]);
}

CwmWMWindow &
CwmWindowGroup::
operator[](int i) const
{
  if (i < 0 || i >= (int) window_stack_.size())
    throw "Invalid Index";

  return *(window_stack_[i]);
}

CwmCirculateWindowStack::
CwmCirculateWindowStack(CwmScreen &screen) :
 screen_(screen), screen_window_groups_(0)
{
  update();
}

void
CwmCirculateWindowStack::
update()
{
  delete screen_window_groups_;

  int types = CWM_WINDOW_TYPE_NORMAL;

  if (! CwmResourceDataInst->getCirculateSkipIcons())
    types |= CWM_WINDOW_TYPE_ICONISED;

  window_groups_.clear();

  screen_window_groups_ = new CwmScreenWindowGroups(screen_);

  int num_screen_window_groups_ = screen_window_groups_->size();

  for (int i = 0; i < num_screen_window_groups_; ++i) {
    CwmWMWindow &window = (*screen_window_groups_)[i].getBottomWindow();

    if (window.getCirculateSkip())
      continue;

    if (window.isIconised()) {
      if (! (types & CWM_WINDOW_TYPE_ICONISED))
        continue;

      CwmDeskMgr *desk_mgr = screen_.getDeskMgr();

      CwmDesk *desk = desk_mgr->getCurrentDesk();

      CwmDeskIconMgr *desk_icon_mgr = desk->getDeskIconMgr();

      CwmDeskIcon *desk_icon = desk_icon_mgr->lookup(&window);

      if (desk_icon == 0)
        continue;
    }

    window_groups_.push_back(&(*screen_window_groups_)[i]);
  }
}

CwmCirculateWindowStack::
~CwmCirculateWindowStack()
{
  delete screen_window_groups_;
}

void
CwmCirculateWindowStack::
circulateUp()
{
  int num_window_groups = window_groups_.size();

  if (num_window_groups > 1)
    raise(&getBottomGroup().getBottomWindow());
}

void
CwmCirculateWindowStack::
circulateDown()
{
  int num_window_groups = window_groups_.size();

  if (num_window_groups > 1)
    lower(&getTopGroup().getBottomWindow());
}

void
CwmCirculateWindowStack::
lower(CwmWMWindow *window)
{
  int num_window_groups = window_groups_.size();

  if (num_window_groups < 2) {
    window->getFrameWindow()->lower();
    return;
  }

  CwmWindowGroup *bottom_group = &getBottomGroup();
  CwmWindowGroup *lower_group  = getWindowGroup(window);

  if (lower_group == 0) {
    window->getFrameWindow()->lower();
    return;
  }

  CwmWMWindow &bottom_window = bottom_group->getBottomWindow();
  CwmWMWindow &lower_window  = lower_group ->getTopWindow();

  XWindowChanges xwc;

  xwc.sibling    = bottom_window.getFrameWindow()->getXWin();
  xwc.stack_mode = Below;

  CwmMachineInst->configureWindow(lower_window.getFrameWindow()->getXWin(),
                                  CWSibling | CWStackMode,
                                  &xwc);

  lower_group->restack();
}

void
CwmCirculateWindowStack::
raise(CwmWMWindow *window)
{
  int num_window_groups = window_groups_.size();

  if (num_window_groups < 2) {
    window->getFrameWindow()->raise();
    return;
  }

  CwmWindowGroup *top_group   = &getTopGroup();
  CwmWindowGroup *raise_group = getWindowGroup(window);

  if (raise_group == 0) {
    window->getFrameWindow()->raise();
    return;
  }

  CwmWMWindow &top_window   = top_group  ->getTopWindow();
  CwmWMWindow &raise_window = raise_group->getTopWindow();

  XWindowChanges xwc;

  xwc.sibling    = top_window.getFrameWindow()->getXWin();
  xwc.stack_mode = Above;

  CwmMachineInst->configureWindow(raise_window.getFrameWindow()->getXWin(),
                                  CWSibling | CWStackMode,
                                  &xwc);

  raise_group->restack();
}

CwmWindowGroup *
CwmCirculateWindowStack::
getWindowGroup(CwmWMWindow *window)
{
  for (int i = 0; i < (int) window_groups_.size(); i++)
    if (window_groups_[i]->contains(window))
      return window_groups_[i];

  return 0;
}

void
CwmCirculateWindowStack::
restack()
{
  int num_window_groups = window_groups_.size();

  for (int i = 0; i < num_window_groups; i++)
    window_groups_[i]->restack();

  update();
}

int
CwmCirculateWindowStack::
size() const
{
  int num_window_groups = window_groups_.size();

  return num_window_groups;
}

CwmWindowGroup &
CwmCirculateWindowStack::
getTopGroup() const
{
  return *(window_groups_[0]);
}

CwmWindowGroup &
CwmCirculateWindowStack::
getBottomGroup() const
{
  return *(window_groups_[window_groups_.size() - 1]);
}

CwmWindowGroup &
CwmCirculateWindowStack::
operator[](int i) const
{
  int num_window_groups = window_groups_.size();

  if (i < 0 || i >= num_window_groups)
    throw "Invalid Index";

  return *window_groups_[i];
}

bool
CwmCirculateWindowStack::
isTop(CwmWMWindow *window)
{
  int num_window_groups = window_groups_.size();

  if (num_window_groups == 0)
    return false;

  CwmWindowGroup &window_group = getTopGroup();

  CwmWMWindow *top_window = &window_group.getTopWindow();

  return (window == top_window);
}

CwmScreenWindowGroups::
CwmScreenWindowGroups(CwmScreen &screen)
{
  Window root_xwin = screen.getRoot()->getXWin();

  if (! CwmMachineInst->isValidWindow(root_xwin))
    return;

  Window *children;
  int     num_children;

  if (! CwmMachineInst->getWindowChildren(root_xwin, &children, &num_children))
    return;

  for (int i = (int) num_children - 1; i >= 0; i--) {
    CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(children[i]);

    if (window == 0 || window->getParent() != 0)
      continue;

    CwmWindowGroup *window_group = new CwmWindowGroup(window);

    window_groups_.push_back(window_group);
  }

  if (children != 0)
    XFree((char *) children);
}

CwmScreenWindowGroups::
~CwmScreenWindowGroups()
{
  int num_window_groups = window_groups_.size();

  for (int i = 0; i < num_window_groups; i++)
    delete window_groups_[i];
}

int
CwmScreenWindowGroups::
size() const
{
  int num_window_groups = window_groups_.size();

  return num_window_groups;
}

CwmWindowGroup &
CwmScreenWindowGroups::
getTopGroup() const
{
  return (*window_groups_[0]);
}

CwmWindowGroup &
CwmScreenWindowGroups::
getBottomGroup() const
{
  return (*window_groups_[window_groups_.size() - 1]);
}

CwmWindowGroup &
CwmScreenWindowGroups::
operator[](int i) const
{
  int num_window_groups = window_groups_.size();

  if (i < 0 || i >= num_window_groups)
    throw "Invalid Index";

  return *(window_groups_[i]);
}
##concat##CwmWMWindow.cpp
#include <CwmI.h>
#include <CXAtom.h>

struct CwmWindowEventDef {
  std::string event;
  std::string function;
};

struct CwmWindowEventFunction {
  CwmWMWindow    *window;
  CGlob          *compile;
  int             area;
  CXNamedEvent   *event;
  CwmFunctionDef *function;
  CwmData         data;

  CwmWindowEventFunction(CwmWMWindow *window1, int area1,
                         CXNamedEvent *event1,
                         CwmFunctionDef *function1, CwmData data1) :
   window(window1), compile(0), area(area1), event(event1),
   function(function1), data(data1) {
  }

  CwmWindowEventFunction(const std::string &pattern1, int area1,
                         CXNamedEvent *event1,
                         CwmFunctionDef *function1, CwmData data1) :
   window(0), compile(0), area(area1), event(event1),
   function(function1), data(data1) {
    compile = new CGlob(pattern1);
  }

 ~CwmWindowEventFunction() {
    delete compile;
    delete event;
    delete function;
  }
};

CwmWindowEventDef
window_event_defs[] = {
  { "Alt<Key>F2" , "f.raise"   , },
  { "Alt<Key>F3" , "f.lower"   , },
  { "Alt<Key>F4" , "f.close"   , },
  { "Alt<Key>F5" , "f.restore" , },
  { "Alt<Key>F7" , "f.move"    , },
  { "Alt<Key>F8" , "f.resize"  , },
  { "Alt<Key>F9" , "f.iconise" , },
  { "Alt<Key>F10", "f.maximize", },
  { "Alt<Key>F11", "f.minimize", },
  { ""           , ""          , },
};

//-------------------------------

CwmWindowEventFunctionMgr *
CwmWindowEventFunctionMgr::
getInstance()
{
  static CwmWindowEventFunctionMgr *instance;

  if (! instance)
    instance = new CwmWindowEventFunctionMgr();

  return instance;
}

CwmWindowEventFunctionMgr::
CwmWindowEventFunctionMgr()
{
}

void
CwmWindowEventFunctionMgr::
add(CwmWindowEventFunction *event_function)
{
  event_functions_.push_back(event_function);
}

void
CwmWindowEventFunctionMgr::
remove(CwmWindowEventFunction *event_function)
{
  event_functions_.remove(event_function);
}

void
CwmWindowEventFunctionMgr::
addEventFunction(CwmWMWindow *window, int area, CXNamedEvent *event,
                 CwmFunctionDef *function, CwmData data)
{
  CwmWindowEventFunction *event_function =
    new CwmWindowEventFunction(window, area, event, function, data);

  CwmWindowEventFunctionMgrInst->add(event_function);
}

void
CwmWindowEventFunctionMgr::
addPatternEventFunction(const std::string &pattern, int area, CXNamedEvent *event,
                        CwmFunctionDef *function, CwmData data)
{
  CwmWindowEventFunction *event_function =
    new CwmWindowEventFunction(pattern, area, event, function, data);

  CwmWindowEventFunctionMgrInst->add(event_function);
}

void
CwmWindowEventFunctionMgr::
processEventFunction(CwmWMWindow *window, int area, XEvent *event)
{
  std::string res_name  = window->getResName ();
  std::string res_class = window->getResClass();

  WindowEventFunctionList::const_iterator pef1 = event_functions_.begin();
  WindowEventFunctionList::const_iterator pef2 = event_functions_.end  ();

  for ( ; pef1 != pef2; ++pef1) {
    if (! ((*pef1)->area & area))
      continue;

    if      ((*pef1)->window != 0) {
      if ((*pef1)->window != window)
        continue;
    }
    else if ((*pef1)->compile != 0) {
      if (! (*pef1)->compile->compare(res_name) &&
          ! (*pef1)->compile->compare(res_class))
        continue;
    }

    if ((*pef1)->event->matchEvent(event)) {
      (*pef1)->function->processWindow
        (window, (*pef1)->data);

      return;
    }
  }
}

void
CwmWindowEventFunctionMgr::
removeEventFunctions(CwmWMWindow *window)
{
  WindowEventFunctionList::const_iterator pef1 = event_functions_.begin();
  WindowEventFunctionList::const_iterator pef2 = event_functions_.end  ();

  while (pef1 != pef2) {
    if ((*pef1)->window == window) {
      event_functions_.remove(*pef1);

      delete *pef1;

      pef1 = event_functions_.begin();
      pef2 = event_functions_.end  ();
    }
    else
      ++pef1;
  }
}

void
CwmWindowEventFunctionMgr::
removeAllEventFunctions()
{
  std::for_each(event_functions_.begin(), event_functions_.end(), CDeletePointer());

  event_functions_.clear();
}

void
CwmWindowEventFunctionMgr::
grabEventKeys(CwmWMWindow *window)
{
  WindowEventFunctionList::const_iterator pef1 = event_functions_.begin();
  WindowEventFunctionList::const_iterator pef2 = event_functions_.end  ();

  for ( ; pef1 != pef2; ++pef1) {
    if ((*pef1)->window != window)
      continue;

    if (! ((*pef1)->area & CWM_WINDOW_USER_AREA))
      continue;

    XKeyPressedEvent *event = (*pef1)->event->getKeyPressedEvent();

    if (event != 0)
      CwmMachineInst->grabKey(window->getFrame()->getXWindow()->getXWin(),
                              event->keycode, event->state);
  }
}

void
CwmWindowEventFunctionMgr::
ungrabEventKeys(CwmWMWindow *window)
{
  WindowEventFunctionList::const_iterator pef1 = event_functions_.begin();
  WindowEventFunctionList::const_iterator pef2 = event_functions_.end  ();

  for ( ; pef1 != pef2; ++pef1) {
    if ((*pef1)->window != window)
      continue;

    if (! ((*pef1)->area & CWM_WINDOW_USER_AREA))
      continue;

    XKeyPressedEvent *event = (*pef1)->event->getKeyPressedEvent();

    if (event != 0)
      CwmMachineInst->ungrabKey(window->getFrame()->getXWindow()->getXWin(),
                                event->keycode, event->state);
  }
}

//-------------------------------

CwmWindowGlobalNotifyMgr *
CwmWindowGlobalNotifyMgr::
getInstance()
{
  static CwmWindowGlobalNotifyMgr *instance;

  if (! instance)
    instance = new CwmWindowGlobalNotifyMgr();

  return instance;
}

CwmWindowGlobalNotifyMgr::
CwmWindowGlobalNotifyMgr()
{
}

CwmWindowGlobalNotifyMgr::
~CwmWindowGlobalNotifyMgr()
{
}

void
CwmWindowGlobalNotifyMgr::
add(CwmWindowNotifyData *notify_proc)
{
  notify_procs_.push_back(notify_proc);
}

void
CwmWindowGlobalNotifyMgr::
remove(CwmWindowNotifyData *notify_proc)
{
  notify_procs_.remove(notify_proc);
}

void
CwmWindowGlobalNotifyMgr::
clear()
{
  notify_procs_.clear();
}

void
CwmWindowGlobalNotifyMgr::
addProc(CwmWindowNotifyType type, CwmWindowNotifyProc proc, void *data)
{
  CwmWindowNotifyData *notify_proc =
    new CwmWindowNotifyData(type, proc, data);

  add(notify_proc);
}

void
CwmWindowGlobalNotifyMgr::
removeProc(CwmWindowNotifyType type, CwmWindowNotifyProc proc, void *data)
{
  WindowNotifyDataList::const_iterator pnp1 = notify_procs_.begin();
  WindowNotifyDataList::const_iterator pnp2 = notify_procs_.end  ();

  while (pnp1 != pnp2) {
    if ((*pnp1)->match(type, proc, data)) {
      remove(*pnp1);

      delete *pnp1;

      pnp1 = notify_procs_.begin();
      pnp2 = notify_procs_.end  ();
    }
    else
      ++pnp1;
  }
}

void
CwmWindowGlobalNotifyMgr::
callProcs(CwmWMWindow *window, CwmWindowNotifyType type)
{
  WindowNotifyDataList::const_iterator pnp1 = notify_procs_.begin();
  WindowNotifyDataList::const_iterator pnp2 = notify_procs_.end  ();

  for ( ; pnp1 != pnp2; ++pnp1)
    (*pnp1)->setCalled(false);

  pnp1 = notify_procs_.begin();

  while (pnp1 != pnp2) {
    if ((*pnp1)->isType(type) && ! (*pnp1)->getCalled()) {
      (*pnp1)->setCalled(true);

      (*pnp1)->call(window);

      pnp1 = notify_procs_.begin();
      pnp2 = notify_procs_.end  ();
    }
    else
      ++pnp1;
  }
}

//-------------------------------

CwmWMWindowMgr::
CwmWMWindowMgr()
{
}

CwmWMWindowMgr::
~CwmWMWindowMgr()
{
  term();
}

void
CwmWMWindowMgr::
term()
{
  std::for_each(window_list_.begin(), window_list_.end(), CDeletePointer());

  window_list_.clear();
}

CwmWMWindow *
CwmWMWindowMgr::
addWindow(CwmScreen &screen, Window xwin)
{
  CwmWMWindow *window = new CwmWMWindow(screen, xwin);

  window_list_.push_back(window);

  return window;
}

void
CwmWMWindowMgr::
removeWindow(CwmWMWindow *window)
{
  window_list_.remove(window);
}

CwmWMWindow *
CwmWMWindowMgr::
lookupFromWindow(Window xwin)
{
  if (! CwmMachineInst->isValidWindow(xwin)) {
    CwmWMWindow *window = lookupFromUserWindow(xwin);

    if (window != 0) {
      CwmUserWindow *user = window->getUser();

      if (user != 0)
        user->setXWindow(None);

      window->remove();
    }

    return 0;
  }

  Window parent = CwmMachineInst->getWindowTop(xwin);

  CwmWindow *parent_xwindow = CwmMachineInst->getWindowCwmXWindow(parent);

  if (parent_xwindow == 0)
    return 0;

  WindowList::iterator p1 = window_list_.begin();
  WindowList::iterator p2 = window_list_.end  ();

  for ( ; p1 != p2; ++p1)
    if ((*p1)->isFrame(parent_xwindow))
      return *p1;

  return 0;
}

CwmWMWindow *
CwmWMWindowMgr::
lookupFromUserWindow(Window xwin)
{
  WindowList::iterator p1 = window_list_.begin();
  WindowList::iterator p2 = window_list_.end  ();

  for ( ; p1 != p2; ++p1) {
    CwmUserWindow *user = (*p1)->getUser();

    if (user != 0 && user->getXWin() == xwin)
      return *p1;
  }

  return 0;
}

//-------------------------------

void
CwmWMWindow::
processEvents()
{
  while (true) {
    XEvent *event = CwmEventMgrInst->processNextEvent();

    processEvent(event);
  }
}

void
CwmWMWindow::
processPendingEvents()
{
  XEvent event;

  while (CwmMachineInst->eventPending()) {
    CwmMachineInst->nextEvent(&event);

    processEvent(&event);
  }
}

void
CwmWMWindow::
processEvent(XEvent *event)
{
  switch (event->type) {
    case ButtonPress: {
      if (CwmResourceDataInst->getWindowPressRaise()) {
        Window window = CwmMachineInst->getEventWindow(event);

        CwmWMWindow *cwm_window = CwmMachineInst->getWindowWMWindow(window);

        if (cwm_window != 0) {
          CwmScreen &screen = cwm_window->getScreen();

          if (! screen.isTop(cwm_window)) {
            CwmWindow *xwindow = cwm_window->getScreen().getPointerWindow();

            if (xwindow == 0 || cwm_window->isUser(xwindow)) {
              CwmWindow *xwindow = cwm_window->getUserWindow();

              if (xwindow != 0) {
                CwmMachineInst->focusLeave(cwm_window);

                cwm_window->raise();

                CwmMachineInst->flushEvents();

                xwindow->replayPointerEvents();
              }

              break;
            }
          }
        }
      }

      processButtonPress((XButtonPressedEvent *) event);

      break;
    }
    case ButtonRelease:
      processButtonRelease((XButtonReleasedEvent *) event);
      break;
    case KeyPress:
      processKeyPress((XKeyPressedEvent *) event);
      break;
    case KeyRelease:
      processKeyRelease((XKeyReleasedEvent *) event);
      break;
    case MotionNotify:
      break;
    case EnterNotify:
      processEnterNotify((XEnterWindowEvent *) event);
      break;
    case LeaveNotify:
      processLeaveNotify((XLeaveWindowEvent *) event);
      break;
    case ClientMessage:
      processClientMessage((XClientMessageEvent *) event);
      break;
    default:
      CwmMachineInst->logf("Unhandled Event Type %d\n", event->type);
      break;
  }
}

void
CwmWMWindow::
sendToUser(XEvent *event)
{
  Window window = CwmMachineInst->getEventWindow(event);

  CwmWMWindow *cwm_window = CwmMachineInst->getWindowWMWindow(window);

  if (cwm_window == 0)
    return;

  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(window);

  if (cwm_window->isUser(xwindow)) {
    CwmMachineInst->focusLeave(cwm_window);

    xwindow->sendEvent((XEvent *) event, 0xFFFF);

    CwmMachineInst->focusEnter(cwm_window);
  }
}

void
CwmWMWindow::
processButtonPress(XButtonPressedEvent *event)
{
  CwmScreen &screen = CwmMachineInst->getWindowScreen(event->window);

  if (event->window == screen.getRoot()->getXWin()) {
    CwmRootEventFunctionMgrInst->process(screen, (XEvent *) event);

    return;
  }

  //------

  CwmToolBar *toolbar = screen.getCurrentDesk()->getToolBar();

  if (toolbar != 0)
    toolbar->processButtonPress(event->window, event->button);

  //------

  CwmCmdIcon *cmdicon = CwmCmdIconMgrInst->lookup(event->window);

  if (cmdicon != 0) {
    if (event->button == 2)
      cmdicon->move();

    return;
  }

  //------

  CwmDeskMgr *desk_mgr = screen.getDeskMgr();

  CwmDesk *desk = desk_mgr->getCurrentDesk();

  CwmDeskIconMgr *desk_icon_mgr = desk->getDeskIconMgr();

  if (desk_icon_mgr != 0) {
    CwmDeskIcon *desk_icon = desk_icon_mgr->lookup(event->window);

    if (desk_icon != 0) {
      if      (event->button == 1)
        desk_icon->raise();
      else if (event->button == 2)
        desk_icon->move();
      else if (event->button == 3)
        desk_icon->processMenu();
    }
  }

  //------

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  if (window == 0)
    return;

  //------

  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

  if      (event->button == 1) {
    if (CwmResourceDataInst->getClickToFocus())
      CwmMachineInst->setFocusWindow(window);
  }

  if (window->decoration_->processButtonPress(event)) {
    return;
  }

  if      (event->button == 1) {
    if (window->isFrame(xwindow))
      window->raise();
  }
  else if (event->button == 2) {
    if (window->isFrame(xwindow))
      CwmMoveWindowInst->moveDelayed(window);
  }
  else if (event->button == 3) {
    window->processWindowMenu();
  }
}

void
CwmWMWindow::
processButtonRelease(XButtonReleasedEvent *)
{
}

void
CwmWMWindow::
processKeyPress(XKeyPressedEvent *event)
{
  CwmScreen &screen = CwmMachineInst->getWindowScreen(event->window);

  if (event->window == screen.getRoot()->getXWin()) {
    CwmRootEventFunctionMgrInst->process(screen, (XEvent *) event);

    return;
  }

  CwmToolBar *toolbar = screen.getCurrentDesk()->getToolBar();

  if (toolbar != 0) {
    CwmToolBarIcon *tool_icon = toolbar->getToolIcon(event->window);

    if (tool_icon != 0) {
      tool_icon->processKeyPress(event);

      return;
    }
  }

  CwmDeskMgr *desk_mgr = screen.getDeskMgr();

  CwmDesk *desk = desk_mgr->getCurrentDesk();

  CwmDeskIconMgr *desk_icon_mgr = desk->getDeskIconMgr();

  if (desk_icon_mgr != 0) {
    CwmDeskIcon *desk_icon = desk_icon_mgr->lookup(event->window);

    if (desk_icon != 0) {
      desk_icon->processKeyPress(event);

      return;
    }
  }

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  if (window != 0)
    CwmWindowEventFunctionMgrInst->
      processEventFunction(window, CWM_WINDOW_ANY_AREA, (XEvent *) event);
}

void
CwmWMWindow::
processKeyRelease(XKeyReleasedEvent *event)
{
  CwmScreen &screen = CwmMachineInst->getWindowScreen(event->window);

  if (event->window == screen.getRoot()->getXWin()) {
    CwmRootEventFunctionMgrInst->process(screen, (XEvent *) event);

    return;
  }

  CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(event->window);

  if (window != 0)
    CwmWindowEventFunctionMgrInst->
      processEventFunction(window, CWM_WINDOW_ANY_AREA, (XEvent *) event);
}

void
CwmWMWindow::
processEnterNotify(XEnterWindowEvent *event)
{
  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

  if (xwindow == 0 || ! xwindow->isValid())
    return;

  if (! CwmResourceDataInst->getClickToFocus()) {
    CwmScreen &screen = xwindow->getScreen();

    CwmWMWindow *window = CwmMachineInst->getWindowWMWindow(xwindow);

    if (window != 0) {
      CwmMachineInst->setFocusWindow(window);

      goto done;
    }

    CwmToolBar *toolbar = screen.getCurrentDesk()->getToolBar();

    if (toolbar != 0) {
      CwmToolBarIcon *tool_icon = toolbar->getToolIcon(xwindow);

      if (tool_icon != 0 && ! tool_icon->getWindow()->isIconised()) {
        CwmMachineInst->setFocusWindow(tool_icon->getWindow());

        goto done;
      }
    }

    CwmMachineInst->setFocusWindow(0);
  }

 done:
  xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

  if (xwindow != 0 && xwindow->isValid())
    xwindow->callCallbacks(CWM_CALLBACK_ENTER, 0);
}

void
CwmWMWindow::
processLeaveNotify(XLeaveWindowEvent *event)
{
  CwmWindow *xwindow = CwmMachineInst->getWindowCwmXWindow(event->window);

  if (xwindow == 0 || ! xwindow->isValid())
    return;

  xwindow->callCallbacks(CWM_CALLBACK_LEAVE, 0);
}

void
CwmWMWindow::
processClientMessage(XClientMessageEvent *)
{
}

CwmWMWindow::
CwmWMWindow(CwmScreen &screen, Window xwin) :
 screen_(screen)
{
  cmap_ = CwmMachineInst->getWindowColormap(xwin);

  //------

  CwmColor *color = CwmResourceDataInst->getColor(screen);
  CwmFont  *font  = CwmResourceDataInst->getFont (screen);

  normal_graphics_ = new CwmGraphics(screen, font, color);

  //------

  color = CwmResourceDataInst->getFocusColor(screen);
  font  = CwmResourceDataInst->getFocusFont (screen);

  focus_graphics_ = new CwmGraphics(screen, font, color);

  //------

  graphics_ = normal_graphics_;

  //------

  rolled_up_ = false;

  //------

  int user_x, user_y, user_width, user_height, user_border;

  CwmMachineInst->getWindowGeometry(xwin, &user_x, &user_y,
                                    &user_width, &user_height,
                                    &user_border);

  if (CwmMachineInst->isValidWindow(xwin))
    user_ = new CwmUserWindow(this, xwin,
                              user_x, user_y,
                              user_width, user_height,
                              user_border);
  else
    user_ = 0;

  frame_ = new CwmFrameWindow(this);

  //------

  hints_ = new CwmHints(this);

  //------

  decoration_ = new CwmDecoration(this);

  //------

  state_ = CWM_WINDOW_STATE_NORMAL;

  //------

  if (user_ != 0) {
    normal_x_      = user_->getX();
    normal_y_      = user_->getY();
    normal_width_  = user_->getWidth();
    normal_height_ = user_->getHeight();
  }
  else {
    normal_x_      = 0;
    normal_y_      = 0;
    normal_width_  = 1;
    normal_height_ = 1;
  }

  //------

  parent_ = 0;

  Window transient_for = getTransientForHint();

  if (transient_for != None)
    parent_ = CwmMachineInst->getWindowWMWindow(transient_for);

  if (parent_ != 0)
    parent_->children_.push_back(this);

  //------

  image_list_ = new CwmWindowImageList(this);

  //------

  focus_auto_raise_ = CwmResourceDataInst->getFocusAutoRaise();

  if (! CwmCustomHintMgrInst->getCustomHintValue
         (getResName(), CwmNfocusAutoRaise, (CwmData) &focus_auto_raise_))
    CwmCustomHintMgrInst->getCustomHintValue
     (getResClass(), CwmNfocusAutoRaise, (CwmData) &focus_auto_raise_);

  //------

  circulate_skip_ = false;

  if (! CwmCustomHintMgrInst->getCustomHintValue
         (getResName(), CwmNcirculateSkip, (CwmData) &circulate_skip_))
    CwmCustomHintMgrInst->getCustomHintValue
     (getResClass(), CwmNcirculateSkip, (CwmData) &circulate_skip_);

  //------

  toolbar_skip_ = false;

  if (! CwmCustomHintMgrInst->getCustomHintValue
         (getResName(), CwmNtoolbarSkip, (CwmData) &toolbar_skip_))
    CwmCustomHintMgrInst->getCustomHintValue
     (getResClass(), CwmNtoolbarSkip, (CwmData) &toolbar_skip_);

  //------

  window_menu_ = new CwmWindowMenu(this);

  //------

  decorate();

  //------

  int desk_num = getDeskProperty();

  CwmDesk *desk = screen.getDesk(desk_num);

  desk->addWMWindow(this);

  setDeskProperty();

  //------

  CwmWindowGlobalNotifyMgrInst->callProcs(this, CWM_WINDOW_NOTIFY_CREATE);

  //------

  if      (isWMStateIconic())
    iconise();
  else if (getInitialStateHint() == IconicState)
    iconise();
  else
    setStateProperty();

  //------

  initUserWindow();

  //------

  addEvents();

  //------

  place();

  //------

  if (CwmMailMgrInst->isMailWindow(this))
    CwmMailMgrInst->addMailWindow(this);
}

CwmWMWindow::
~CwmWMWindow()
{
  CwmWindowGlobalNotifyMgrInst->callProcs(this, CWM_WINDOW_NOTIFY_DESTROY);

  callNotifyProcs(CWM_WINDOW_NOTIFY_DESTROY);

  //------

  if (CwmMachineInst->isFocus(this))
    CwmMachineInst->focusLeave(this);

  CwmMailMgrInst->deleteMailWindow(this);

  //------

  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow != 0 && user_xwindow->getXWin() != None) {
    int x      = 0;
    int y      = 0;
    int border = 0;

    if (user_ != 0) {
      x      = user_->getX();
      y      = user_->getY();
      border = user_->getBorder();
    }

    if (CwmResourceDataInst->getPositionIsFrame()) {
      x -= decoration_->getLeftBorder();
      y -= decoration_->getTitleHeight() +
           decoration_->getTopBorder();
    }

    user_xwindow->reparent(screen_.getRoot(), x, y);

    user_xwindow->setBorderWidth(border);

    user_xwindow->removeFromSaveSet();
  }

  //------

  delete normal_graphics_;
  delete focus_graphics_;

  //------

  delete user_;
  delete frame_;

  //------

  delete hints_;

  delete window_menu_;

  CwmWindowEventFunctionMgrInst->removeEventFunctions(this);

  //------

  delete image_list_;

  //------

  WMWindowList::const_iterator pwindow1 = children_.begin();
  WMWindowList::const_iterator pwindow2 = children_.end  ();

  for ( ; pwindow1 != pwindow2; ++pwindow1)
    (*pwindow1)->parent_ = 0;
}

CwmFont *
CwmWMWindow::
getFont() const
{
  return normal_graphics_->getFont();
}

CwmColor *
CwmWMWindow::
getColor() const
{
  return normal_graphics_->getColor();
}

GC
CwmWMWindow::
getGC() const
{
  return normal_graphics_->getGC();
}

int
CwmWMWindow::
getFontHeight() const
{
  return normal_graphics_->getFontHeight();
}

void
CwmWMWindow::
place()
{
  if (! CwmResourceDataInst->getInteractivePlacement())
    return;

  if (state_ != CWM_WINDOW_STATE_NORMAL)
    return;

  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow == 0)
    return;

  if (user_xwindow->isViewable())
    return;

  if (CwmResourceDataInst->getMoveOpaque()) {
    int x, y;

    screen_.getRoot()->getPointerPosition(&x, &y);

    CwmWindow *xwindow = frame_->getXWindow();

    xwindow->move(x, y);

    map();
  }

  CwmMoveWindowInst->movePlaced(this);

  if (! CwmResourceDataInst->getMoveOpaque())
    map();
}

void
CwmWMWindow::
remove()
{
  if (CwmMachineInst->isFocusWindow(this))
    CwmMachineInst->setFocusWindow(0);

  //------

  CwmDesk *desk = screen_.getDesk(this);

  desk->removeWMWindow(this);

  //------

  if (parent_ != 0)
    parent_->children_.remove(this);

  screen_.removeWMWindow(this);

  CwmMachineInst->removeWMWindow(this);

  //------

  delete this;
}

void
CwmWMWindow::
initUserWindow()
{
  uint attr_mask = CWEventMask | CWDontPropagate;

  XSetWindowAttributes attr;

  attr.event_mask = EnterWindowMask    | LeaveWindowMask      |
                    KeyPressMask       | KeyReleaseMask       |
                    FocusChangeMask    | VisibilityChangeMask |
                    PropertyChangeMask | StructureNotifyMask  |
                    PointerMotionMask  | ColormapChangeMask;

  attr.do_not_propagate_mask = ButtonPressMask | ButtonReleaseMask |
                               KeyPressMask    | KeyReleaseMask;

  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow == 0)
    return;

  CwmMachineInst->changeWindowAtributes(user_xwindow->getXWin(),
                                        attr_mask, &attr);

  user_xwindow->setBorderWidth(0);

  user_xwindow->addToSaveSet();

  if (CwmResourceDataInst->getClickToFocus())
    CwmMachineInst->setFocusWindow(this);
}

void
CwmWMWindow::
processWindowMenu()
{
  window_menu_->process();
}

void
CwmWMWindow::
processWindowMenuAtPosition(int x, int y)
{
  window_menu_->processAtPosition(frame_->getXWindow(), x, y);
}

void
CwmWMWindow::
processWindowMenu(CwmWMWindow *window, CwmData)
{
  window->processWindowMenuAtPosition(0, window->frame_->getHeight());
}

bool
CwmWMWindow::
isFrame(CwmWindow *xwindow)
{
  return (frame_ != 0 && xwindow == frame_->getXWindow());
}

bool
CwmWMWindow::
isUser(CwmWindow *xwindow)
{
  CwmWindow *user_xwindow = getUserWindow();

  return (xwindow == user_xwindow);
}

string
CwmWMWindow::
getName()
{
  std::string name = hints_->getName();

  if (name == "")
    name = hints_->getResName();

  if (name == "")
    name = "window";

  return name;
}

string
CwmWMWindow::
getResName()
{
  std::string name = hints_->getResName();

  if (name == "")
    name = "window";

  return name;
}

string
CwmWMWindow::
getResClass()
{
  std::string name = hints_->getResClass();

  if (name == "")
    name = hints_->getResName();

  if (name == "")
    name = "cwm";

  return name;
}

string
CwmWMWindow::
getIconName()
{
  std::string name = hints_->getIconName();

  if (name == "")
    name = hints_->getName();

  if (name == "")
    name = hints_->getResName();

  if (name == "")
    name = "icon";

  return name;
}

void
CwmWMWindow::
addEvents()
{
  for (int i = 0; window_event_defs[i].event != ""; ++i) {
    CXNamedEvent *event = new CXNamedEvent(window_event_defs[i].event);

    CwmFunctionDef *function =
      new CwmFunctionDef(window_event_defs[i].function);

    CwmWindowEventFunctionMgrInst->
      addEventFunction(this, CWM_WINDOW_ANY_AREA, event, function, 0);
  }
}

void
CwmWMWindow::
print()
{
  CwmMachineInst->logf("Window %s\n", getName().c_str());
  CwmMachineInst->logf(" Frame %x\n", (frame_ ? frame_->getXWindow() : 0));

  decoration_->print();

  CwmWindow *user_xwindow = getUserWindow();

  CwmMachineInst->logf("  User      %x\n", user_xwindow);
}

bool
CwmWMWindow::
onCurrentDesk()
{
  int desk_num = getDeskNum();

  return (desk_num == screen_.getCurrentDeskNum());
}

int
CwmWMWindow::
getDeskNum()
{
  return screen_.getDeskNum(this);
}

CwmDesk *
CwmWMWindow::
getDesk()
{
  return screen_.getDesk(this);
}

void
CwmWMWindow::
raise()
{
  screen_.raise(this);

  CwmMessageInst->updateChangeCount();
}

void
CwmWMWindow::
lower()
{
  screen_.lower(this);

  CwmMessageInst->updateChangeCount();
}

void
CwmWMWindow::
iconise()
{
  if (isIconised())
    return;

  setIconised();

  //------

  CwmWindowGroup window_group(this);

  window_group.unmap();

  //------

  CwmWindowGlobalNotifyMgrInst->callProcs(this, CWM_WINDOW_NOTIFY_ICONISE);

  callNotifyProcs(CWM_WINDOW_NOTIFY_ICONISE);

  //------

  setStateProperty();
}

void
CwmWMWindow::
restore()
{
  CwmWindowGroup window_group(this);

  window_group.map();

  //------

  CwmWindowGlobalNotifyMgrInst->callProcs(this, CWM_WINDOW_NOTIFY_RESTORE);

  callNotifyProcs(CWM_WINDOW_NOTIFY_RESTORE);

  //------

  setNormal();

  setStateProperty();

  //------

  raise();
}

void
CwmWMWindow::
minimize()
{
  if (isIconised())
    return;

  if (! isMinimized()) {
    if (isNormal()) {
      normal_x_      = frame_->getX();
      normal_y_      = frame_->getY();
      normal_width_  = frame_->getWidth();
      normal_height_ = frame_->getHeight();
    }

    frame_->minimize();

    setMinimised();
  }
  else {
    moveResize(normal_x_, normal_y_, normal_width_, normal_height_);

    redecorate();

    setNormal();
  }
}

void
CwmWMWindow::
maximize()
{
  if (isIconised())
    return;

  if (! isMaximized()) {
    if (isNormal()) {
      normal_x_      = frame_->getX();
      normal_y_      = frame_->getY();
      normal_width_  = frame_->getWidth();
      normal_height_ = frame_->getHeight();
    }

    frame_->maximize();

    setMaximised();
  }
  else {
    moveResize(normal_x_, normal_y_, normal_width_, normal_height_);

    redecorate();

    setNormal();
  }
}

void
CwmWMWindow::
restoreSize()
{
  if (isNormal())
    return;

  if (isIconised()) {
    restore();

    return;
  }

  moveResize(normal_x_, normal_y_, normal_width_, normal_height_);

  redecorate();

  setNormal();
}

void
CwmWMWindow::
close()
{
  if (getNotifyDeleteWindowHint())
    notifyDeleteWindow();
  else {
    CwmWindow *user_xwindow = getUserWindow();

    if (user_xwindow != 0)
      CwmMachineInst->killClient(user_xwindow->getXWin());
  }

  CwmMachineInst->flushEvents();

  closeInvalid();
}

void
CwmWMWindow::
closeInvalid()
{
  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow != 0 && ! user_xwindow->isValid()) {
    unmap();

    if (user_ != 0)
      user_->setXWindow(None);

    remove();
  }
}

void
CwmWMWindow::
notifyDeleteWindow()
{
  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow == 0)
    return;

  XClientMessageEvent event;

  event.type         = ClientMessage;
  event.window       = user_xwindow->getXWin();
  event.message_type = CwmMachineInst->getWMProtocolsAtom().getXAtom();
  event.format       = 32;

  event.data.l[0] = CwmMachineInst->getWMDeleteWindowAtom().getXAtom();
  event.data.l[1] = CurrentTime;

  user_xwindow->sendEvent((XEvent *) &event, 0);
}

void
CwmWMWindow::
focusIn()
{
  graphics_ = focus_graphics_;

  decoration_->focusIn(graphics_);

  redraw();

  //------

  CwmWindowGlobalNotifyMgrInst->callProcs(this, CWM_WINDOW_NOTIFY_FOCUS_IN);

  callNotifyProcs(CWM_WINDOW_NOTIFY_FOCUS_IN);
}

void
CwmWMWindow::
focusOut()
{
  graphics_ = normal_graphics_;

  decoration_->focusOut(graphics_);

  redraw();

  //------

  CwmWindowGlobalNotifyMgrInst->callProcs(this, CWM_WINDOW_NOTIFY_FOCUS_OUT);

  callNotifyProcs(CWM_WINDOW_NOTIFY_FOCUS_OUT);
}

void
CwmWMWindow::
focus()
{
  CwmMachineInst->setFocusWindow(this);
}

void
CwmWMWindow::
rollUp()
{
  rolled_up_ = true;

  decoration_->rollUp();

  if (user_ != 0)
    user_->unmap();

  CwmMachineInst->flushEvents();

  redecorate();
}

void
CwmWMWindow::
rollDown()
{
  rolled_up_ = false;

  if (user_ != 0)
    user_->map();

  redecorate();

  decoration_->rollDown();

  CwmMachineInst->flushEvents();

  redecorate();
}

void
CwmWMWindow::
map()
{
  CwmWindow *xwindow = frame_->getXWindow();

  xwindow->map();
}

void
CwmWMWindow::
unmap()
{
  CwmWindow *xwindow = frame_->getXWindow();

  xwindow->unmap();
}

void
CwmWMWindow::
decorate()
{
  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow == 0)
    return;

  int x = getXHint();
  int y = getYHint();

  bool already_mapped = user_xwindow->isViewable();

  if (already_mapped || ! CwmResourceDataInst->getClientAutoPlace())
    user_xwindow->getPosition(&x, &y);

  int user_x = x;
  int user_y = y;

  if (x != -1 && y != -1) {
    if (CwmResourceDataInst->getPositionIsFrame()) {
      user_x += decoration_->getLeftBorder();
      user_y += decoration_->getTitleHeight() + decoration_->getTopBorder();
    }
  }
  else
    user_xwindow->getPosition(&user_x, &user_y);

  if (user_ != 0) {
    int user_width  = user_->getWidth ();
    int user_height = user_->getHeight();

    user_->moveResize(user_x, user_y, user_width, user_height);
  }

  //------

  user_xwindow->unmap();

  decoration_->decorate();

  //------

  frame_->position();

  //------

  decoration_->reparent(user_xwindow);

  user_xwindow->map();

  if (already_mapped || ! CwmResourceDataInst->getInteractivePlacement())
    map();

  redecorate();
}

void
CwmWMWindow::
redecorate()
{
  decoration_->redecorate();

  if (! rolled_up_) {
    frame_->position();

    CwmWindow *user_xwindow = getUserWindow();

    if (user_xwindow != 0)
      user_xwindow->move(0, 0);
  }
  else
    frame_->position();
}

void
CwmWMWindow::
redraw()
{
  decoration_->redraw();

  if (! getResizeHandleDecorationHint() && getBorderDecorationHint())
    frame_->draw();
}

CwmWindow *
CwmWMWindow::
getFrameWindow() const
{
  return frame_->getXWindow();
}

CwmWindow *
CwmWMWindow::
getUserWindow() const
{
  if (user_ != 0)
    return user_->getXWindow();
  else
    return 0;
}

Window
CwmWMWindow::
getXWin() const
{
  CwmWindow *user_window = getUserWindow();

  if (user_window != 0)
    return user_window->getXWin();
  else
    return None;
}

CwmDecoration *
CwmWMWindow::
getDecoration() const
{
  return decoration_;
}

void
CwmWMWindow::
move()
{
  CwmMoveWindowInst->move(this);
}

void
CwmWMWindow::
move(int x, int y)
{
  if (CwmResourceDataInst->getPositionOnScreen()) {
    if (x < 0)
      x = 0;

    if (y < 0)
      y = 0;

    if (x + frame_->getWidth() > screen_.getWidth())
      x = screen_.getWidth()  - frame_->getWidth();

    if (y + frame_->getHeight() > screen_.getHeight())
      y = screen_.getHeight() - frame_->getHeight();
  }

  frame_->move(x, y);

  //------

  CwmWindowGlobalNotifyMgrInst->callProcs(this, CWM_WINDOW_NOTIFY_MOVE);

  callNotifyProcs(CWM_WINDOW_NOTIFY_MOVE);
}

void
CwmWMWindow::
moveResize(int x, int y, int width, int height)
{
  if (CwmResourceDataInst->getPositionOnScreen()) {
    if (x < 0)
      x = 0;

    if (y < 0)
      y = 0;

    if (width > screen_.getWidth())
      width = screen_.getWidth();

    if (height > screen_.getHeight())
      height = screen_.getHeight();

    if (x + width > screen_.getWidth())
      x = screen_.getWidth()  - width;

    if (y + height > screen_.getHeight())
      y = screen_.getHeight() - height;
  }

  frame_->moveResize(x, y, width, height);

  //------

  CwmWindowGlobalNotifyMgrInst->callProcs(this, CWM_WINDOW_NOTIFY_MOVE);

  callNotifyProcs(CWM_WINDOW_NOTIFY_MOVE);
}

void
CwmWMWindow::
resize()
{
  CwmResizeWindowInst->resize(this, CWM_RESIZE_FREE);
}

void
CwmWMWindow::
resizeUser(int width, int height)
{
  int x1 = frame_->getX();
  int y1 = frame_->getY();

  int user_width  = 1;
  int user_height = 1;

  if (user_ != 0) {
    user_width  = user_->getWidth ();
    user_height = user_->getHeight();
  }

  int width1  = frame_->getWidth () - (user_width  - width );
  int height1 = frame_->getHeight() - (user_height - height);

  if (CwmResourceDataInst->getPositionOnScreen()) {
    if (width1 > screen_.getWidth())
      width1 = screen_.getWidth();

    if (height1 > screen_.getHeight())
      height1 = screen_.getHeight();

    if (x1 + width1 > screen_.getWidth())
      x1 = screen_.getWidth()  - width1;

    if (y1 + height1 > screen_.getHeight())
      y1 = screen_.getHeight() - height1;
  }

  moveResize(x1, y1, width1, height1);

  redecorate();
}

void
CwmWMWindow::
setStateProperty()
{
  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow == 0)
    return;

  if (isIconised())
    CwmMachineInst->setWMStateNormal(user_xwindow->getXWin());
  else {
    CwmDeskMgr *desk_mgr = screen_.getDeskMgr();

    CwmDesk *desk = desk_mgr->getCurrentDesk();

    CwmDeskIconMgr *desk_icon_mgr = desk->getDeskIconMgr();

    if (desk_icon_mgr != 0) {
      CwmDeskIcon *desk_icon = desk_icon_mgr->lookup(this);

      if (desk_icon != 0)
        CwmMachineInst->setWMStateIconic(user_xwindow->getXWin(),
                                         desk_icon->getXWindow()->getXWin());
      else
        CwmMachineInst->setWMStateIconic(user_xwindow->getXWin(), None);
    }
  }
}

bool
CwmWMWindow::
isWMStateIconic()
{
  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow == 0)
    return false;

  return CwmMachineInst->isWMStateIconic(user_xwindow->getXWin());
}

void
CwmWMWindow::
setDeskProperty()
{
  int desk_num = screen_.getDeskNum(this);

  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow == 0)
    return;

  const CXAtom &atom = CwmMachineInst->getCwmDesktopAtom();

  CwmMachineInst->setIntegerProperty(user_xwindow->getXWin(), atom,
                                     desk_num + 1);
}

int
CwmWMWindow::
getDeskProperty()
{
  int desk_num;

  CwmWindow *user_xwindow = getUserWindow();

  if (user_xwindow == 0)
    return 0;

  const CXAtom &atom = CwmMachineInst->getCwmDesktopAtom();

  if (! CwmMachineInst->getIntegerProperty(user_xwindow->getXWin(), atom,
                                           &desk_num))
    return screen_.getCurrentDeskNum();

  return (desk_num - 1);
}

CwmImage *
CwmWMWindow::
getImage(int width, int height)
{
  return image_list_->getImage(width, height);
}

CwmImage *
CwmWMWindow::
getImage()
{
  return image_list_->getImage();
}

void
CwmWMWindow::
addNotifyProc(CwmWindowNotifyType type, CwmWindowNotifyProc proc, void *data)
{
  CwmWindowNotifyData *notify_proc =
    new CwmWindowNotifyData(type, proc, data);

  notify_procs_.push_back(notify_proc);
}

void
CwmWMWindow::
removeNotifyProc(CwmWindowNotifyType type, CwmWindowNotifyProc proc,
                 void *data)
{
  WindowNotifyDataList::const_iterator pnp1 = notify_procs_.begin();
  WindowNotifyDataList::const_iterator pnp2 = notify_procs_.end  ();

  while (pnp1 != pnp2) {
    if ((*pnp1)->match(type, proc, data)) {
      notify_procs_.remove(*pnp1);

      delete *pnp1;

      pnp1 = notify_procs_.begin();
      pnp2 = notify_procs_.end  ();
    }
    else
      ++pnp1;
  }
}

void
CwmWMWindow::
callNotifyProcs(CwmWindowNotifyType type)
{
  WindowNotifyDataList::const_iterator pnp1 = notify_procs_.begin();
  WindowNotifyDataList::const_iterator pnp2 = notify_procs_.end  ();

  for ( ; pnp1 != pnp2; ++pnp1)
    (*pnp1)->setCalled(false);

  pnp1 = notify_procs_.begin();

  while (pnp1 != pnp2) {
    if ((*pnp1)->isType(type) && ! (*pnp1)->getCalled()) {
      (*pnp1)->setCalled(true);

      (*pnp1)->call(this);

      pnp1 = notify_procs_.begin();
      pnp2 = notify_procs_.end  ();
    }
    else
      ++pnp1;
  }
}

Window
CwmWMWindow::
getWMIconWindowHint()
{
  CwmUserWindow *user = getUser();

  if (user != 0) {
    Window xwin = user->getXWin();

    return CwmMachineInst->getWMIconWindowHint(xwin);
  }
  else
    return None;
}
##concat##CwmXEvent.cpp
#include <CwmI.h>

CwmXEvent::
CwmXEvent()
{
}

CwmXEvent::
~CwmXEvent()
{
}

CwmXEvent *
CwmXEvent::
getInstance()
{
  static CwmXEvent *instance;

  if (! instance)
    instance = new CwmXEvent();

  return instance;
}

bool
CwmXEvent::
isKeyPressEvent(XKeyPressedEvent *event, int key)
{
  char key_string[2];

  key_string[0] = key;
  key_string[1] = '\0';

  KeySym keysym = XStringToKeysym(key_string);

  if (keysym == NoSymbol) {
    CwmMachineInst->logf("Unknowm KeySym Name %s\n", key_string);
    return false;
  }

  uint keycode = CwmMachineInst->keysymToKeycode(keysym);

  if (event->keycode == keycode &&
      (event->state == 0 || event->state == 1))
    return true;

  return false;
}

bool
CwmXEvent::
isEscapeKeyEvent(XKeyPressedEvent *event)
{
  KeySym keysym = XStringToKeysym("Escape");

  uint keycode = CwmMachineInst->keysymToKeycode(keysym);

  if (event->keycode == keycode && event->state == 0)
    return true;

  return false;
}
##concat##CwmXPixmap.cpp
#include <CwmI.h>

CwmXPixmapMgr *
CwmXPixmapMgr::
getInstance()
{
  static CwmXPixmapMgr *instance;

  if (! instance)
    instance = new CwmXPixmapMgr();

  return instance;
}

CwmXPixmapMgr::
CwmXPixmapMgr()
{
}

void
CwmXPixmapMgr::
add(CwmXPixmap *xpixmap)
{
  xpixmaps_.push_back(xpixmap);
}

void
CwmXPixmapMgr::
remove(CwmXPixmap *xpixmap)
{
  xpixmaps_.remove(xpixmap);
}

CwmXPixmap::
CwmXPixmap(CwmScreen &screen, int width, int height, int depth) :
 screen_(screen), xpixmap_(None), width_(width),
 height_(height), depth_(depth)
{
  if (depth_ <= 0)
    depth_ = screen.getDepth();

  if (width_ <= 0)
    width_ = -1;

  if (height_ <= 0)
    height_ = -1;

  xpixmap_ = CwmMachineInst->createPixmap(width_, height_, depth_);

  owner_ = true;

  CwmXPixmapMgrInst->add(this);
}

CwmXPixmap::
CwmXPixmap(CwmScreen &screen, Pixmap xpixmap,
           int width, int height, int depth) :
 screen_(screen), xpixmap_(xpixmap), width_(width),
 height_(height), depth_(depth)
{
  if (depth_ <= 0)
    depth_ = screen_.getDepth();

  if (width_ <= 0)
    width_ = -1;

  if (height_ <= 0)
    height_ = -1;

  owner_ = false;

  CwmXPixmapMgrInst->add(this);
}

CwmXPixmap::
~CwmXPixmap()
{
  CwmXPixmapMgrInst->remove(this);

  if (owner_ && xpixmap_ != None)
    CwmMachineInst->freePixmap(xpixmap_);
}

GC
CwmXPixmap::
createGC()
{
  GC gc = CwmMachineInst->createGC(xpixmap_, 0, 1);

  return gc;
}
